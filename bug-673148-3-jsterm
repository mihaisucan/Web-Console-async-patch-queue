# HG changeset patch
# Parent 889abde02d3de6f2317c1c24dc7f8fd02f0e2793
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1336504814 -10800

Bug 673148 - (async-webconsole) Part 3 - Make JS evaluation and object inspection async

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -56,26 +56,26 @@ Cu.import("resource://gre/modules/Servic
 Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", tempScope);
 Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
 
 let XPCOMUtils = tempScope.XPCOMUtils;
 let Services = tempScope.Services;
 let gConsoleStorage = tempScope.ConsoleAPIStorage;
 let WebConsoleUtils = tempScope.WebConsoleUtils;
 let l10n = WebConsoleUtils.l10n;
+let JSPropertyProvider = tempScope.JSPropertyProvider;
 tempScope = null;
 
 let _alive = true; // Track if this content script should still be alive.
 
 /**
  * The Web Console content instance manager.
  */
 let Manager = {
   get "window"() content,
-  get console() this.window.console,
   sandbox: null,
   hudId: null,
   _sequence: 0,
   _messageListeners: ["WebConsole:Init", "WebConsole:Destroy"],
   _messageHandlers: null,
   _enabledFeatures: null,
 
   /**
@@ -92,21 +92,17 @@ let Manager = {
     this._messageHandlers = {};
 
     this._messageListeners.forEach(function(aName) {
       addMessageListener(aName, this);
     }, this);
 
     // Need to track the owner XUL window to listen to the unload and TabClose
     // events, to avoid memory leaks.
-    let xulWindow = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
-                    .getInterface(Ci.nsIWebNavigation)
-                    .QueryInterface(Ci.nsIDocShell)
-                    .chromeEventHandler.ownerDocument.defaultView;
-
+    let xulWindow = this._xulWindow();
     xulWindow.addEventListener("unload", this._onXULWindowClose, false);
 
     let tabContainer = xulWindow.gBrowser.tabContainer;
     tabContainer.addEventListener("TabClose", this._onTabClose, false);
 
     // Need to track private browsing change and quit application notifications,
     // again to avoid memory leaks. The Web Console main process cannot notify
     // this content script when the XUL window close, tab close, private
@@ -389,29 +385,38 @@ let Manager = {
   {
     let tab = aEvent.target;
     if (_alive && tab.linkedBrowser.contentWindow === Manager.window) {
       Manager.destroy();
     }
   },
 
   /**
+   * Find the XUL window that owns the content script.
+   * @private
+   * @return Window
+   *         The XUL window that owns the content script.
+   */
+  _xulWindow: function Manager__xulWindow()
+  {
+    return this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+           .getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShell)
+           .chromeEventHandler.ownerDocument.defaultView;
+  },
+
+  /**
    * Destroy the Web Console content script instance.
    */
   destroy: function Manager_destroy()
   {
     Services.obs.removeObserver(this, "private-browsing-change-granted");
     Services.obs.removeObserver(this, "quit-application-granted");
 
     _alive = false;
-    let xulWindow = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
-                    .getInterface(Ci.nsIWebNavigation)
-                    .QueryInterface(Ci.nsIDocShell)
-                    .chromeEventHandler.ownerDocument.defaultView;
-
+    let xulWindow = this._xulWindow();
     xulWindow.removeEventListener("unload", this._onXULWindowClose, false);
     let tabContainer = xulWindow.gBrowser.tabContainer;
     tabContainer.removeEventListener("TabClose", this._onTabClose, false);
 
     let hudId = this.hudId;
 
     this._messageListeners.forEach(function(aName) {
       removeMessageListener(aName, this);
@@ -423,37 +428,364 @@ let Manager = {
     this._messageHandlers = null;
     Manager = ConsoleAPIObserver = JSTerm = ConsoleListener = null;
     Cc = Ci = Cu = XPCOMUtils = Services = gConsoleStorage =
       WebConsoleUtils = l10n = null;
   },
 };
 
 /**
+ * JSTermHelper
+ *
+ * Defines a set of functions ("helper functions") that are available from the
+ * WebConsole but not from the webpage.
+ * A list of helper functions used by Firebug can be found here:
+ *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ */
+// TODO: recheck jsterm helpers
+function JSTermHelper(aJSTerm)
+{
+  /**
+   * Returns the result of document.getElementById(aId).
+   *
+   * @param string aId
+   *        A string that is passed to window.document.getElementById.
+   * @returns nsIDOMNode or null
+   */
+  aJSTerm.sandbox.$ = function JSTH_$(aId)
+  {
+    return aJSTerm.window.document.getElementById(aId);
+  };
+
+  /**
+   * Returns the result of document.querySelectorAll(aSelector).
+   *
+   * @param string aSelector
+   *        A string that is passed to window.document.querySelectorAll.
+   * @returns array of nsIDOMNode
+   */
+  aJSTerm.sandbox.$$ = function JSTH_$$(aSelector)
+  {
+    return aJSTerm.window.document.querySelectorAll(aSelector);
+  };
+
+  /**
+   * Runs a xPath query and returns all matched nodes.
+   *
+   * @param string aXPath
+   *        xPath search query to execute.
+   * @param [optional] nsIDOMNode aContext
+   *        Context to run the xPath query on. Uses window.document if not set.
+   * @returns array of nsIDOMNode
+   */
+  aJSTerm.sandbox.$x = function JSTH_$x(aXPath, aContext)
+  {
+    let nodes = [];
+    let doc = aJSTerm.window.document;
+    let aContext = aContext || doc;
+
+    try {
+      let results = doc.evaluate(aXPath, aContext, null,
+                                 Ci.nsIDOMXPathResult.ANY_TYPE, null);
+      let node;
+      while (node = results.iterateNext()) {
+        nodes.push(node);
+      }
+    }
+    catch (ex) {
+      aJSTerm.console.error(ex.message);
+    }
+
+    return nodes;
+  };
+
+  /**
+   * Returns the currently selected object in the highlighter.
+   *
+   * Warning: this implementation crosses the process boundaries! This is not
+   * usable within a remote browser. To implement this feature correctly we need
+   * support for remote inspection capabilities within the Inspector as well.
+   *
+   * @returns nsIDOMNode or null
+   */
+  Object.defineProperty(aJSTerm.sandbox, "$0", {
+    get: function() {
+      try {
+        return Manager._xulWindow().InspectorUI.selection;
+      }
+      catch (ex) {
+        aJSTerm.console.error(ex.message);
+      }
+    },
+    enumerable: true,
+    configurable: false
+  });
+
+  /**
+   * Clears the output of the JSTerm.
+   */
+  aJSTerm.sandbox.clear = function JSTH_clear()
+  {
+    aJSTerm.helperEvaluated = true;
+    Manager.sendMessage("JSTerm:ClearOutput", {});
+  };
+
+  /**
+   * Returns the result of Object.keys(aObject).
+   *
+   * @param object aObject
+   *        Object to return the property names from.
+   * @returns array of string
+   */
+  aJSTerm.sandbox.keys = function JSTH_keys(aObject)
+  {
+    return Object.keys(WebConsoleUtils.unwrap(aObject));
+  };
+
+  /**
+   * Returns the values of all properties on aObject.
+   *
+   * @param object aObject
+   *        Object to display the values from.
+   * @returns array of string
+   */
+  aJSTerm.sandbox.values = function JSTH_values(aObject)
+  {
+    let arrValues = [];
+    let obj = WebConsoleUtils.unwrap(aObject);
+
+    // FIXME: isn't this a security issue? we can execute non-native getters
+    // here.
+    try {
+      for (let prop in obj) {
+        arrValues.push(obj[prop]);
+      }
+    }
+    catch (ex) {
+      aJSTerm.console.error(ex.message);
+    }
+    return arrValues;
+  };
+
+  /**
+   * Opens a help window in MDC
+   */
+  aJSTerm.sandbox.help = function JSTH_help()
+  {
+    aJSTerm.helperEvaluated = true;
+    aJSTerm.window.open(
+        "https://developer.mozilla.org/AppLinks/WebConsoleHelp?locale=" +
+        aJSTerm.window.navigator.language, "help", "");
+  };
+
+  /**
+   * Inspects the passed aObject. This is done by opening the PropertyPanel.
+   *
+   * @param object aObject
+   *        Object to inspect.
+   * @returns void
+   */
+  aJSTerm.sandbox.inspect = function JSTH_inspect(aObject)
+  {
+    if (!WebConsoleUtils.isResultInspectable(aObject)) {
+      return aObject;
+    }
+
+    aJSTerm.helperEvaluated = true;
+
+    let message = {
+      hudId: aJSTerm.hudId,
+      id: aJSTerm.sequenceId,
+      input: aJSTerm._evalInput,
+      objectCacheId: aJSTerm.sequenceId,
+    };
+
+    message.resultObject =
+      aJSTerm.prepareEvalResultObject(message.objectCacheId,
+                                      WebConsoleUtils.unwrap(aObject));
+
+    sendAsyncMessage("JSTerm:InspectObject", message);
+  };
+
+  aJSTerm.sandbox.inspectrules = function JSTH_inspectrules(aNode)
+  {
+    return "UNIMPLEMENTED";
+
+    // TODO: this needs e10s support in the CssRuleView code.
+
+    aJSTerm.helperEvaluated = true;
+    let doc = aJSTerm.parentNode.ownerDocument;
+    let win = doc.defaultView;
+    let panel = createElement(doc, "panel", {
+      label: "CSS Rules",
+      titlebar: "normal",
+      noautofocus: "true",
+      noautohide: "true",
+      close: "true",
+      width: 350,
+      height: (win.screen.height / 2)
+    });
+
+    let iframe = createAndAppendElement(panel, "iframe", {
+      src: "chrome://browser/content/devtools/cssruleview.xhtml",
+      flex: "1",
+    });
+
+    panel.addEventListener("load", function onLoad() {
+      panel.removeEventListener("load", onLoad, true);
+      let doc = iframe.contentDocument;
+      let view = new CssRuleView(doc);
+      let body = doc.getElementById("ruleview-body");
+      body.appendChild(view.element);
+      view.highlight(aNode);
+    }, true);
+
+    let parent = doc.getElementById("mainPopupSet");
+    parent.appendChild(panel);
+
+    panel.addEventListener("popuphidden", function onHide() {
+      panel.removeEventListener("popuphidden", onHide);
+      parent.removeChild(panel);
+    });
+
+    let footer = createElement(doc, "hbox", { align: "end" });
+    createAndAppendElement(footer, "spacer", { flex: 1});
+    createAndAppendElement(footer, "resizer", { dir: "bottomend" });
+    panel.appendChild(footer);
+
+    let anchor = win.gBrowser.selectedBrowser;
+    panel.openPopup(anchor, "end_before", 0, 0, false, false);
+  };
+
+  /**
+   * Prints aObject to the output.
+   *
+   * @param object aObject
+   *        Object to print to the output.
+   * @returns void
+   */
+  aJSTerm.sandbox.pprint = function JSTH_pprint(aObject)
+  {
+    aJSTerm.helperEvaluated = true;
+    if (aObject === null || aObject === undefined || aObject === true ||
+        aObject === false) {
+      aJSTerm.console.error(l10n.getStr("helperFuncUnsupportedTypeError"));
+      return;
+    }
+    else if (typeof aObject == "function") {
+      aJSTerm.helperRawOutput = true;
+      return aObject + "\n";
+    }
+
+    aJSTerm.helperRawOutput = true;
+
+    let output = [];
+    let pairs = WebConsoleUtils.namesAndValuesOf(WebConsoleUtils.unwrap(aObject));
+    pairs.forEach(function(aPair) {
+      output.push(aPair.name + ": " + aPair.value);
+    });
+
+    return "  " + output.join("\n  ");
+  };
+
+  /**
+   * Print a string to the output, as-is.
+   *
+   * @param string aString
+   *        A string you want to output.
+   * @returns void
+   */
+  aJSTerm.sandbox.print = function JSTH_print(aString)
+  {
+    aJSTerm.helperEvaluated = true;
+    aJSTerm.helperRawOutput = true;
+    return aString + "";
+  };
+}
+
+/**
  * The JavaScript terminal is meant to allow remote code execution for the Web
  * Console.
  */
 let JSTerm = {
+  get "window"() Manager.window,
+  get console() this.window.console,
+
+  sandbox: null,
+  _messageHandlers: {},
+
   /**
    * Evaluation result objects are cached in this object. The chrome process can
    * request any object based on its ID.
    */
   _objectCache: null,
 
   /**
    * Initialize the JavaScript terminal feature.
    */
   init: function JST_init()
   {
     this._objectCache = {};
+    this._messageHandlers = {
+      "JSTerm:EvalRequest": this.handleEvalRequest,
+      "JSTerm:GetEvalObject": this.handleGetEvalObject,
+      "JSTerm:Autocomplete": this.handleAutocomplete,
+      "JSTerm:ClearObjectCache": this.handleClearObjectCache,
+    };
 
-    Manager.addMessageHandler("JSTerm:GetEvalObject",
-                              this.handleGetEvalObject.bind(this));
-    Manager.addMessageHandler("JSTerm:ClearObjectCache",
-                              this.handleClearObjectCache.bind(this));
+    for (let name in this._messageHandlers) {
+      let handler = this._messageHandlers[name].bind(this);
+      Manager.addMessageHandler(name, handler);
+    }
+
+    this.createSandbox();
+  },
+
+  handleEvalRequest: function JST_handleEvalRequest(aRequest)
+  {
+    let id = aRequest.id;
+    let input = aRequest.str;
+    let result, error = null;
+
+    this.helperEvaluated = false;
+    this.helperRawOutput = false;
+    this._evalInput = input;
+    try {
+      result = this.evalInSandbox(input);
+    }
+    catch (ex) {
+      error = ex;
+    }
+    delete this._evalInput;
+
+    let inspectable = !error && WebConsoleUtils.isObjectInspectable(result);
+    let resultString = undefined;
+    if (!error) {
+      resultString = this.helperRawOutput ? result :
+                     WebConsoleUtils.formatResult(result);
+    }
+
+    let message = {
+      id: id,
+      input: input,
+      resultString: resultString,
+      error: error,
+      errorMessage: error ? error.toString() : null,
+      inspectable: inspectable,
+      helperResult: this.helperEvaluated,
+      helperRawOutput: this.helperRawOutput,
+    };
+
+    if (inspectable) {
+      message.childrenCacheId = aRequest.resultCacheId;
+      message.resultObject =
+        this.prepareObjectForRemote(result, message.childrenCacheId);
+    }
+
+    Manager.sendMessage("JSTerm:EvalResult", message);
   },
 
   /**
    * Handler for the remote "JSTerm:GetEvalObject" message. This allows the
    * remote Web Console instance to retrieve an object from the content process.
    *
    * @param object aRequest
    *        The message that requests the content object. Properties: cacheId,
@@ -514,37 +846,105 @@ let JSTerm = {
    *        given object may include references to other objects - those
    *        references will be stored in the given cache ID so the remote
    *        process can later retrieve them as well.
    * @return array
    *         An array that holds one element for each enumerable property and
    *         method in aObject. Each element describes the property. For details
    *         see WebConsoleUtils.namesAndValuesOf().
    */
-  prepareObjectForRemote:
-  function JST_prepareObjectForRemote(aObject, aCacheId)
+  prepareObjectForRemote: function JST_prepareObjectForRemote(aObject, aCacheId)
   {
     // Cache the properties that have inspectable values.
     let propCache = this._objectCache[aCacheId] || {};
     let result = WebConsoleUtils.namesAndValuesOf(aObject, propCache);
     if (!(aCacheId in this._objectCache) && Object.keys(propCache).length > 0) {
       this._objectCache[aCacheId] = propCache;
     }
 
     return result;
   },
 
+  handleAutocomplete: function JST_handleAutocomplete(aRequest)
+  {
+    let result = JSPropertyProvider(Manager.window, aRequest.input) || {};
+    let message = {
+      id: aRequest.id,
+      input: aRequest.input,
+      matches: result.matches || [],
+      matchProp: result.matchProp,
+    };
+    Manager.sendMessage("JSTerm:AutocompleteProperties", message);
+  },
+
+  createSandbox: function JST_createSandbox()
+  {
+    this.sandbox = new Cu.Sandbox(Manager.window, {
+      sandboxPrototype: Manager.window,
+      wantXrays: false,
+    });
+
+    this.sandbox.console = Manager.window.console;
+
+    JSTermHelper(this);
+  },
+
+  /**
+   * Evaluates a string in the sandbox.
+   *
+   * @param string aString
+   *        String to evaluate in the sandbox.
+   * @returns something
+   *          The result of the evaluation.
+   */
+  evalInSandbox: function JST_evalInSandbox(aString)
+  {
+    // The help function needs to be easy to guess, so we make the () optional
+    if (aString.trim() == "help" || aString.trim() == "?") {
+      aString = "help()";
+    }
+
+    let window = WebConsoleUtils.unwrap(this.sandbox.window);
+    let $ = null, $$ = null;
+
+    // We prefer to execute the page-provided implementations for the $() and
+    // $$() functions.
+    if (typeof window.$ == "function") {
+      $ = this.sandbox.$;
+      delete this.sandbox.$;
+    }
+    if (typeof window.$$ == "function") {
+      $$ = this.sandbox.$$;
+      delete this.sandbox.$$;
+    }
+
+    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8",
+                                  "Web Console", 1);
+
+    if ($) {
+      this.sandbox.$ = $;
+    }
+    if ($$) {
+      this.sandbox.$$ = $$;
+    }
+
+    return result;
+  },
+
   /**
    * Destroy the JSTerm instance.
    */
   destroy: function JST_destroy()
   {
-    Manager.removeMessageHandler("JSTerm:GetEvalObject");
-    Manager.removeMessageHandler("JSTerm:ClearObjectCache");
+    for (let name in this._messageHandlers) {
+      Manager.removeMessageHandler(name);
+    }
 
+    delete this.sandbox;
+    delete this._messageHandlers;
     delete this._objectCache;
   },
 };
 
 /**
  * The window.console API observer. This allows the window.console API messages
  * to be sent to the remote Web Console instance.
  */
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -52,20 +52,16 @@ const Cu = Components.utils;
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/NetworkHelper.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
 
-XPCOMUtils.defineLazyServiceGetter(this, "scriptError",
-                                   "@mozilla.org/scripterror;1",
-                                   "nsIScriptError");
-
 XPCOMUtils.defineLazyServiceGetter(this, "activityDistributor",
                                    "@mozilla.org/network/http-activity-distributor;1",
                                    "nsIHttpActivityDistributor");
 
 XPCOMUtils.defineLazyServiceGetter(this, "mimeService",
                                    "@mozilla.org/mime;1",
                                    "nsIMIMEService");
 
@@ -93,34 +89,24 @@ XPCOMUtils.defineLazyGetter(this, "NetUt
 
 XPCOMUtils.defineLazyGetter(this, "template", function () {
   var obj = {};
   Cu.import("resource:///modules/devtools/Templater.jsm", obj);
   return obj.template;
 });
 
 XPCOMUtils.defineLazyGetter(this, "PropertyPanel", function () {
-  var obj = {};
-  try {
-    Cu.import("resource:///modules/PropertyPanel.jsm", obj);
-  } catch (err) {
-    Cu.reportError(err);
-  }
+  let obj = {};
+  Cu.import("resource:///modules/PropertyPanel.jsm", obj);
   return obj.PropertyPanel;
 });
 
-XPCOMUtils.defineLazyGetter(this, "PropertyPanelAsync", function () {
+XPCOMUtils.defineLazyGetter(this, "PropertyTreeView", function () {
   let obj = {};
-  Cu.import("resource:///modules/PropertyPanelAsync.jsm", obj);
-  return obj.PropertyPanel;
-});
-
-XPCOMUtils.defineLazyGetter(this, "PropertyTreeViewAsync", function () {
-  let obj = {};
-  Cu.import("resource:///modules/PropertyPanelAsync.jsm", obj);
+  Cu.import("resource:///modules/PropertyPanel.jsm", obj);
   return obj.PropertyTreeView;
 });
 
 XPCOMUtils.defineLazyGetter(this, "AutocompletePopup", function () {
   var obj = {};
   try {
     Cu.import("resource:///modules/AutocompletePopup.jsm", obj);
   }
@@ -136,22 +122,16 @@ XPCOMUtils.defineLazyGetter(this, "Scrat
     Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", obj);
   }
   catch (err) {
     Cu.reportError(err);
   }
   return obj.ScratchpadManager;
 });
 
-XPCOMUtils.defineLazyGetter(this, "namesAndValuesOf", function () {
-  var obj = {};
-  Cu.import("resource:///modules/PropertyPanel.jsm", obj);
-  return obj.namesAndValuesOf;
-});
-
 XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
   let obj = {};
   Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
   return obj.WebConsoleUtils;
 });
 
 XPCOMUtils.defineLazyGetter(this, "l10n", function() {
   return WebConsoleUtils.l10n;
@@ -1778,19 +1758,16 @@ HUD_SERVICE.prototype =
    */
   unregisterDisplay: function HS_unregisterDisplay(aHUDId)
   {
     let hud = this.getHudReferenceById(aHUDId);
 
     // Remove children from the output. If the output is not cleared, there can
     // be leaks as some nodes has node.onclick = function; set and GC can't
     // remove the nodes then.
-    if (hud.jsterm) {
-      hud.jsterm.clearOutput();
-    }
     if (hud.gcliterm) {
       hud.gcliterm.clearOutput();
     }
 
     hud.destroy();
 
     // Make sure that the console panel does not try to call
     // deactivateHUDForContext() again.
@@ -1805,20 +1782,16 @@ HUD_SERVICE.prototype =
     }
 
     hud.HUDBox.parentNode.removeChild(hud.HUDBox);
 
     if (hud.splitter.parentNode) {
       hud.splitter.parentNode.removeChild(hud.splitter);
     }
 
-    if (hud.jsterm) {
-      hud.jsterm.autocompletePopup.destroy();
-    }
-
     delete this.hudReferences[aHUDId];
 
     for (let windowID in this.windowIds) {
       if (this.windowIds[windowID] == aHUDId) {
         delete this.windowIds[windowID];
       }
     }
 
@@ -1851,17 +1824,17 @@ HUD_SERVICE.prototype =
   {
     if (Object.keys(this.hudReferences).length > 0) {
       return;
     }
 
     // begin observing HTTP traffic
     this.startHTTPObservation();
 
-    HUDWindowObserver.init();
+    WebConsoleObserver.init();
   },
 
   /**
    * Suspend Web Console activity. This is called when all Web Consoles are
    * closed.
    *
    * @returns void
    */
@@ -1875,17 +1848,17 @@ HUD_SERVICE.prototype =
 
     this.openRequests = {};
     this.openResponseHeaders = {};
 
     delete this.defaultFilterPrefs;
 
     delete this.lastFinishedRequestCallback;
 
-    HUDWindowObserver.uninit();
+    WebConsoleObserver.uninit();
   },
 
   /**
    * Shutdown all HeadsUpDisplays on xpcom-shutdown
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
@@ -2443,39 +2416,16 @@ HUD_SERVICE.prototype =
                                                      null,
                                                      clipboardText);
 
     ConsoleUtils.outputMessageNode(messageNode, aActivityObject.hudId);
     return messageNode;
   },
 
   /**
-   * Initialize the JSTerm object to create a JS Workspace by attaching the UI
-   * into the given parent node, using the mixin.
-   *
-   * @param nsIDOMWindow aContext the context used for evaluating user input
-   * @param nsIDOMNode aParentNode where to attach the JSTerm
-   * @param object aConsole
-   *        Console object used within the JSTerm instance to report errors
-   *        and log data (by calling console.error(), console.log(), etc).
-   */
-  initializeJSTerm: function HS_initializeJSTerm(aContext, aParentNode, aConsole)
-  {
-    // create Initial JS Workspace:
-    var context = Cu.getWeakReference(aContext);
-
-    // Attach the UI into the target parent node using the mixin.
-    var firefoxMixin = new JSTermFirefoxMixin(context, aParentNode);
-    var jsTerm = new JSTerm(context, aParentNode, firefoxMixin, aConsole);
-
-    // TODO: injection of additional functionality needs re-thinking/api
-    // see bug 559748
-  },
-
-  /**
    * Creates a generator that always returns a unique number for use in the
    * indexes
    *
    * @returns Generator
    */
   createSequencer: function HS_createSequencer(aInt)
   {
     function sequencer(aInt)
@@ -2483,41 +2433,16 @@ HUD_SERVICE.prototype =
       while(1) {
         aInt++;
         yield aInt;
       }
     }
     return sequencer(aInt);
   },
 
-  // See jsapi.h (JSErrorReport flags):
-  // http://mxr.mozilla.org/mozilla-central/source/js/src/jsapi.h#3429
-  scriptErrorFlags: {
-    0: "error", // JSREPORT_ERROR
-    1: "warn", // JSREPORT_WARNING
-    2: "exception", // JSREPORT_EXCEPTION
-    4: "error", // JSREPORT_STRICT | JSREPORT_ERROR
-    5: "warn", // JSREPORT_STRICT | JSREPORT_WARNING
-    8: "error", // JSREPORT_STRICT_MODE_ERROR
-    13: "warn", // JSREPORT_STRICT_MODE_ERROR | JSREPORT_WARNING | JSREPORT_ERROR
-  },
-
-  /**
-   * replacement strings (L10N)
-   */
-  scriptMsgLogLevel: {
-    0: "typeError", // JSREPORT_ERROR
-    1: "typeWarning", // JSREPORT_WARNING
-    2: "typeException", // JSREPORT_EXCEPTION
-    4: "typeError", // JSREPORT_STRICT | JSREPORT_ERROR
-    5: "typeStrict", // JSREPORT_STRICT | JSREPORT_WARNING
-    8: "typeError", // JSREPORT_STRICT_MODE_ERROR
-    13: "typeWarning", // JSREPORT_STRICT_MODE_ERROR | JSREPORT_WARNING | JSREPORT_ERROR
-  },
-
   /**
    * onTabClose event handler function
    *
    * @param aEvent
    * @returns void
    */
   onTabClose: function HS_onTabClose(aEvent)
   {
@@ -2929,27 +2854,22 @@ function HeadsUpDisplay(aConfig)
   // content process.
   this.asyncRequests = {};
 
   // create a panel dynamically and attach to the parentNode
   this.createHUD();
 
   this.HUDBox.lastTimestamp = 0;
   // create the JSTerm input element
-  try {
-    this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    if (this.jsterm) {
-      this.jsterm.inputNode.focus();
-    }
-    if (this.gcliterm) {
-      this.gcliterm.inputNode.focus();
-    }
+  this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
+  if (this.jsterm) {
+    this.jsterm.inputNode.focus();
   }
-  catch (ex) {
-    Cu.reportError(ex);
+  if (this.gcliterm) {
+    this.gcliterm.inputNode.focus();
   }
 
   // A cache for tracking repeated CSS Nodes.
   this.cssNodes = {};
 
   this.setupMessageManager();
 }
 
@@ -2957,17 +2877,19 @@ HeadsUpDisplay.prototype = {
   /**
    * Message names that the HUD listens for. These messages come from the remote
    * Web Console content script.
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
-                      "WebConsole:CachedMessages", "WebConsole:PageError"],
+    "WebConsole:CachedMessages", "WebConsole:PageError", "JSTerm:EvalResult",
+    "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
+    "JSTerm:InspectObject"],
 
   consolePanel: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
@@ -3284,17 +3206,17 @@ HeadsUpDisplay.prototype = {
     }
     catch (ex) {}
 
     if (appName() == "FIREFOX") {
       if (!usegcli) {
         let context = Cu.getWeakReference(aWindow);
         let mixin = new JSTermFirefoxMixin(context, aParentNode,
                                            aExistingConsole);
-        this.jsterm = new JSTerm(context, aParentNode, mixin, this.console);
+        this.jsterm = new JSTerm(this, mixin);
       }
       else {
         this.gcliterm = new GcliTerm(aWindow, this.hudId, this.chromeDocument,
                                      this.console, this.hintNode, this.consoleWrap);
         aParentNode.appendChild(this.gcliterm.element);
       }
     }
     else {
@@ -3357,19 +3279,17 @@ HeadsUpDisplay.prototype = {
     this.contentDocument = this.contentWindow.document;
     this.uriSpec = this.contentWindow.location.href;
 
     if (this.consolePanel) {
       this.consolePanel.label = this.getPanelTitle();
     }
 
     if (this.jsterm) {
-      this.jsterm.context = Cu.getWeakReference(this.contentWindow);
       this.jsterm.console = this.console;
-      this.jsterm.createSandbox();
     }
     else if (this.gcliterm) {
       this.gcliterm.reattachConsole(this.contentWindow, this.console);
     }
     else {
       this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
     }
   },
@@ -3968,17 +3888,17 @@ HeadsUpDisplay.prototype = {
           return;
         }
 
         let options = {
           anchor: node,
           data: { object: node._stacktrace },
         };
 
-        let propPanel = this.jsterm.openPropertyPanelAsync(options);
+        let propPanel = this.jsterm.openPropertyPanel(options);
         propPanel.panel.setAttribute("hudId", this.hudId);
       }.bind(this));
     }
 
     ConsoleUtils.outputMessageNode(node, this.hudId);
 
     if (level == "dir") {
       // Initialize the inspector message node, by setting the PropertyTreeView
@@ -4091,19 +4011,27 @@ HeadsUpDisplay.prototype = {
   {
     if (!aMessage.json || aMessage.json.hudId != this.hudId) {
       Cu.reportError("JSTerm: received message " + aMessage.name +
                      " from wrong hudId.");
       return;
     }
 
     switch (aMessage.name) {
+      case "JSTerm:EvalResult":
       case "JSTerm:EvalObject":
+      case "JSTerm:AutocompleteProperties":
         this._receiveMessageWithCallback(aMessage.json);
         break;
+      case "JSTerm:ClearOutput":
+        this.jsterm.clearOutput();
+        break;
+      case "JSTerm:InspectObject":
+        this.handleInspectObject(aMessage.json);
+        break;
       case "WebConsole:ConsoleAPI":
         this.logConsoleAPIMessage(aMessage.json);
         break;
       case "WebConsole:PageError":
         this.reportPageError(aMessage.json.pageError);
         break;
       case "WebConsole:CachedMessages":
         this._displayCachedConsoleMessages(aMessage.json.messages);
@@ -4224,17 +4152,17 @@ HeadsUpDisplay.prototype = {
   },
 
   /**
    * Destroy the HUD object. Call this method to avoid memory leaks when the Web
    * Console is closed.
    */
   destroy: function HUD_destroy()
   {
-    this.sendMessageToContent("WebConsole:Destroy", {hudId: this.hudId});
+    this.sendMessageToContent("WebConsole:Destroy", {});
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.removeMessageListener(aName, this);
     }, this);
 
     if (this.jsterm) {
       this.jsterm.destroy();
     }
@@ -4281,559 +4209,64 @@ function NodeFactory(aFactoryType, ignor
       return aDocument.createElement(aTag);
     }
   }
   else {
     throw new Error('NodeFactory: Unknown factory type: ' + aFactoryType);
   }
 }
 
-//////////////////////////////////////////////////////////////////////////
-// JS Completer
-//////////////////////////////////////////////////////////////////////////
-
-const STATE_NORMAL = 0;
-const STATE_QUOTE = 2;
-const STATE_DQUOTE = 3;
-
-const OPEN_BODY = '{[('.split('');
-const CLOSE_BODY = '}])'.split('');
-const OPEN_CLOSE_BODY = {
-  '{': '}',
-  '[': ']',
-  '(': ')'
-};
-
-/**
- * Analyses a given string to find the last statement that is interesting for
- * later completion.
- *
- * @param   string aStr
- *          A string to analyse.
- *
- * @returns object
- *          If there was an error in the string detected, then a object like
- *
- *            { err: "ErrorMesssage" }
- *
- *          is returned, otherwise a object like
- *
- *            {
- *              state: STATE_NORMAL|STATE_QUOTE|STATE_DQUOTE,
- *              startPos: index of where the last statement begins
- *            }
- */
-function findCompletionBeginning(aStr)
-{
-  let bodyStack = [];
-
-  let state = STATE_NORMAL;
-  let start = 0;
-  let c;
-  for (let i = 0; i < aStr.length; i++) {
-    c = aStr[i];
-
-    switch (state) {
-      // Normal JS state.
-      case STATE_NORMAL:
-        if (c == '"') {
-          state = STATE_DQUOTE;
-        }
-        else if (c == '\'') {
-          state = STATE_QUOTE;
-        }
-        else if (c == ';') {
-          start = i + 1;
-        }
-        else if (c == ' ') {
-          start = i + 1;
-        }
-        else if (OPEN_BODY.indexOf(c) != -1) {
-          bodyStack.push({
-            token: c,
-            start: start
-          });
-          start = i + 1;
-        }
-        else if (CLOSE_BODY.indexOf(c) != -1) {
-          var last = bodyStack.pop();
-          if (!last || OPEN_CLOSE_BODY[last.token] != c) {
-            return {
-              err: "syntax error"
-            };
-          }
-          if (c == '}') {
-            start = i + 1;
-          }
-          else {
-            start = last.start;
-          }
-        }
-        break;
-
-      // Double quote state > " <
-      case STATE_DQUOTE:
-        if (c == '\\') {
-          i ++;
-        }
-        else if (c == '\n') {
-          return {
-            err: "unterminated string literal"
-          };
-        }
-        else if (c == '"') {
-          state = STATE_NORMAL;
-        }
-        break;
-
-      // Single quoate state > ' <
-      case STATE_QUOTE:
-        if (c == '\\') {
-          i ++;
-        }
-        else if (c == '\n') {
-          return {
-            err: "unterminated string literal"
-          };
-          return;
-        }
-        else if (c == '\'') {
-          state = STATE_NORMAL;
-        }
-        break;
-    }
-  }
-
-  return {
-    state: state,
-    startPos: start
-  };
-}
-
-/**
- * Provides a list of properties, that are possible matches based on the passed
- * scope and inputValue.
- *
- * @param object aScope
- *        Scope to use for the completion.
- *
- * @param string aInputValue
- *        Value that should be completed.
- *
- * @returns null or object
- *          If no completion valued could be computed, null is returned,
- *          otherwise a object with the following form is returned:
- *            {
- *              matches: [ string, string, string ],
- *              matchProp: Last part of the inputValue that was used to find
- *                         the matches-strings.
- *            }
- */
-function JSPropertyProvider(aScope, aInputValue)
-{
-  let obj = WebConsoleUtils.unwrap(aScope);
-
-  // Analyse the aInputValue and find the beginning of the last part that
-  // should be completed.
-  let beginning = findCompletionBeginning(aInputValue);
-
-  // There was an error analysing the string.
-  if (beginning.err) {
-    return null;
-  }
-
-  // If the current state is not STATE_NORMAL, then we are inside of an string
-  // which means that no completion is possible.
-  if (beginning.state != STATE_NORMAL) {
-    return null;
-  }
-
-  let completionPart = aInputValue.substring(beginning.startPos);
-
-  // Don't complete on just an empty string.
-  if (completionPart.trim() == "") {
-    return null;
-  }
-
-  let properties = completionPart.split('.');
-  let matchProp;
-  if (properties.length > 1) {
-    matchProp = properties.pop().trimLeft();
-    for (let i = 0; i < properties.length; i++) {
-      let prop = properties[i].trim();
-
-      // If obj is undefined or null, then there is no chance to run completion
-      // on it. Exit here.
-      if (typeof obj === "undefined" || obj === null) {
-        return null;
-      }
-
-      // Check if prop is a getter function on obj. Functions can change other
-      // stuff so we can't execute them to get the next object. Stop here.
-      if (WebConsoleUtils.isNonNativeGetter(obj, prop)) {
-        return null;
-      }
-      try {
-        obj = obj[prop];
-      }
-      catch (ex) {
-        return null;
-      }
-    }
-  }
-  else {
-    matchProp = properties[0].trimLeft();
-  }
-
-  // If obj is undefined or null, then there is no chance to run
-  // completion on it. Exit here.
-  if (typeof obj === "undefined" || obj === null) {
-    return null;
-  }
-
-  // Skip Iterators and Generators.
-  if (WebConsoleUtils.isIteratorOrGenerator(obj)) {
-    return null;
-  }
-
-  let matches = [];
-  for (let prop in obj) {
-    if (prop.indexOf(matchProp) == 0) {
-      matches.push(prop);
-    }
-  }
-
-  return {
-    matchProp: matchProp,
-    matches: matches.sort(),
-  };
-}
-
-//////////////////////////////////////////////////////////////////////////
-// JSTerm
-//////////////////////////////////////////////////////////////////////////
-
-/**
- * JSTermHelper
- *
- * Defines a set of functions ("helper functions") that are available from the
- * WebConsole but not from the webpage.
- * A list of helper functions used by Firebug can be found here:
- *   http://getfirebug.com/wiki/index.php/Command_Line_API
- */
-function JSTermHelper(aJSTerm)
-{
-  /**
-   * Returns the result of document.getElementById(aId).
-   *
-   * @param string aId
-   *        A string that is passed to window.document.getElementById.
-   * @returns nsIDOMNode or null
-   */
-  aJSTerm.sandbox.$ = function JSTH_$(aId)
-  {
-    try {
-      return aJSTerm._window.document.getElementById(aId);
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Returns the result of document.querySelectorAll(aSelector).
-   *
-   * @param string aSelector
-   *        A string that is passed to window.document.querySelectorAll.
-   * @returns array of nsIDOMNode
-   */
-  aJSTerm.sandbox.$$ = function JSTH_$$(aSelector)
-  {
-    try {
-      return aJSTerm._window.document.querySelectorAll(aSelector);
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Runs a xPath query and returns all matched nodes.
-   *
-   * @param string aXPath
-   *        xPath search query to execute.
-   * @param [optional] nsIDOMNode aContext
-   *        Context to run the xPath query on. Uses window.document if not set.
-   * @returns array of nsIDOMNode
-   */
-  aJSTerm.sandbox.$x = function JSTH_$x(aXPath, aContext)
-  {
-    let nodes = [];
-    let doc = aJSTerm._window.document;
-    let aContext = aContext || doc;
-
-    try {
-      let results = doc.evaluate(aXPath, aContext, null,
-                                  Ci.nsIDOMXPathResult.ANY_TYPE, null);
-
-      let node;
-      while (node = results.iterateNext()) {
-        nodes.push(node);
-      }
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-
-    return nodes;
-  };
-
-  /**
-   * Returns the currently selected object in the highlighter.
-   *
-   * @returns nsIDOMNode or null
-   */
-  Object.defineProperty(aJSTerm.sandbox, "$0", {
-    get: function() {
-      let mw = HUDService.currentContext();
-      try {
-        return mw.InspectorUI.selection;
-      }
-      catch (ex) {
-        aJSTerm.console.error(ex.message);
-      }
-    },
-    enumerable: true,
-    configurable: false
-  });
-
-  /**
-   * Clears the output of the JSTerm.
-   */
-  aJSTerm.sandbox.clear = function JSTH_clear()
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm.clearOutput(true);
-  };
-
-  /**
-   * Returns the result of Object.keys(aObject).
-   *
-   * @param object aObject
-   *        Object to return the property names from.
-   * @returns array of string
-   */
-  aJSTerm.sandbox.keys = function JSTH_keys(aObject)
-  {
-    try {
-      return Object.keys(WebConsoleUtils.unwrap(aObject));
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Returns the values of all properties on aObject.
-   *
-   * @param object aObject
-   *        Object to display the values from.
-   * @returns array of string
-   */
-  aJSTerm.sandbox.values = function JSTH_values(aObject)
-  {
-    let arrValues = [];
-    let obj = WebConsoleUtils.unwrap(aObject);
-
-    try {
-      for (let prop in obj) {
-        arrValues.push(obj[prop]);
-      }
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-    return arrValues;
-  };
-
-  /**
-   * Opens a help window in MDC
-   */
-  aJSTerm.sandbox.help = function JSTH_help()
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm._window.open(
-        "https://developer.mozilla.org/AppLinks/WebConsoleHelp?locale=" +
-        aJSTerm._window.navigator.language, "help", "");
-  };
-
-  /**
-   * Inspects the passed aObject. This is done by opening the PropertyPanel.
-   *
-   * @param object aObject
-   *        Object to inspect.
-   * @returns void
-   */
-  aJSTerm.sandbox.inspect = function JSTH_inspect(aObject)
-  {
-    aJSTerm.helperEvaluated = true;
-    let propPanel = aJSTerm.openPropertyPanel(null,
-                                              WebConsoleUtils.unwrap(aObject));
-    propPanel.panel.setAttribute("hudId", aJSTerm.hudId);
-  };
-
-  aJSTerm.sandbox.inspectrules = function JSTH_inspectrules(aNode)
-  {
-    aJSTerm.helperEvaluated = true;
-    let doc = aJSTerm.inputNode.ownerDocument;
-    let win = doc.defaultView;
-    let panel = createElement(doc, "panel", {
-      label: "CSS Rules",
-      titlebar: "normal",
-      noautofocus: "true",
-      noautohide: "true",
-      close: "true",
-      width: 350,
-      height: (win.screen.height / 2)
-    });
-
-    let iframe = createAndAppendElement(panel, "iframe", {
-      src: "chrome://browser/content/devtools/cssruleview.xul",
-      flex: "1",
-    });
-
-    panel.addEventListener("load", function onLoad() {
-      panel.removeEventListener("load", onLoad, true);
-      let doc = iframe.contentDocument;
-      let view = new CssRuleView(doc);
-      doc.documentElement.appendChild(view.element);
-      view.highlight(aNode);
-    }, true);
-
-    let parent = doc.getElementById("mainPopupSet");
-    parent.appendChild(panel);
-
-    panel.addEventListener("popuphidden", function onHide() {
-      panel.removeEventListener("popuphidden", onHide);
-      parent.removeChild(panel);
-    });
-
-    let footer = createElement(doc, "hbox", { align: "end" });
-    createAndAppendElement(footer, "spacer", { flex: 1});
-    createAndAppendElement(footer, "resizer", { dir: "bottomend" });
-    panel.appendChild(footer);
-
-    let anchor = win.gBrowser.selectedBrowser;
-    panel.openPopup(anchor, "end_before", 0, 0, false, false);
-
-  }
-
-  /**
-   * Prints aObject to the output.
-   *
-   * @param object aObject
-   *        Object to print to the output.
-   * @returns void
-   */
-  aJSTerm.sandbox.pprint = function JSTH_pprint(aObject)
-  {
-    aJSTerm.helperEvaluated = true;
-    if (aObject === null || aObject === undefined || aObject === true || aObject === false) {
-      aJSTerm.console.error(l10n.getStr("helperFuncUnsupportedTypeError"));
-      return;
-    }
-    else if (typeof aObject === TYPEOF_FUNCTION) {
-      aJSTerm.writeOutput(aObject + "\n", CATEGORY_OUTPUT, SEVERITY_LOG);
-      return;
-    }
-
-    let output = [];
-    let pairs = namesAndValuesOf(WebConsoleUtils.unwrap(aObject));
-
-    pairs.forEach(function(pair) {
-      output.push("  " + pair.display);
-    });
-
-    aJSTerm.writeOutput(output.join("\n"), CATEGORY_OUTPUT, SEVERITY_LOG);
-  };
-
-  /**
-   * Print a string to the output, as-is.
-   *
-   * @param string aString
-   *        A string you want to output.
-   * @returns void
-   */
-  aJSTerm.sandbox.print = function JSTH_print(aString)
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm.writeOutput("" + aString, CATEGORY_OUTPUT, SEVERITY_LOG);
-  };
-}
 
 /**
  * JSTerm
  *
  * JavaScript Terminal: creates input nodes for console code interpretation
  * and 'JS Workspaces'
  */
 
 /**
  * Create a JSTerminal or attach a JSTerm input node to an existing output node,
  * given by the parent node.
  *
- * @param object aContext
- *        Usually nsIDOMWindow, but doesn't have to be
- * @param nsIDOMNode aParentNode where to attach the JSTerm
- * @param object aMixin
- *        Gecko-app (or Jetpack) specific utility object
- * @param object aConsole
- *        Console object to use within the JSTerm.
+ * @param object aHud
+ *        The HeadsUpDisplay object that owns this JSTerm instance.
  */
-function JSTerm(aContext, aParentNode, aMixin, aConsole)
+// TODO: recheck comment.
+function JSTerm(aHud, aMixin)
 {
   // set the context, attach the UI by appending to aParentNode
 
   this.application = appName();
-  this.context = aContext;
-  this.parentNode = aParentNode;
+  this.hud = aHud;
+  this.context = Cu.getWeakReference(this.hud.contentWindow);
+  this.parentNode = this.hud.consoleWrap;
   this.mixins = aMixin;
-  this.console = aConsole;
-  this.document = aParentNode.ownerDocument
-
-  this.setTimeout = aParentNode.ownerDocument.defaultView.setTimeout;
-
-  let node = aParentNode;
-  while (!node.hasAttribute("id")) {
-    node = node.parentNode;
-  }
-  this.hudId = node.getAttribute("id");
-
+  this.console = this.hud.console;
+  this.document = this.parentNode.ownerDocument;
+
+  this.hudId = this.hud.hudId;
+
+  this.lastCompletion = {};
   this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
-  this.log = LogFactory("*** JSTerm:");
-  this.autocompletePopup = new AutocompletePopup(aParentNode.ownerDocument);
+  this.autocompletePopup = new AutocompletePopup(this.document);
   this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
   this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
   this.init();
 }
 
 JSTerm.prototype = {
   lastInputValue: "",
-  propertyProvider: JSPropertyProvider,
-
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   init: function JST_init()
   {
-    this.createSandbox();
-
     this.inputNode = this.mixins.inputNode;
     this.outputNode = this.mixins.outputNode;
     this.completeNode = this.mixins.completeNode;
 
     this._keyPress = this.keyPress.bind(this);
     this._inputEventHandler = this.inputEventHandler.bind(this);
 
     this.inputNode.addEventListener("keypress",
@@ -4854,203 +4287,113 @@ JSTerm.prototype = {
     this.mixins.generateUI();
   },
 
   attachUI: function JST_attachUI()
   {
     this.mixins.attachUI();
   },
 
-  createSandbox: function JST_setupSandbox()
-  {
-    // create a JS Sandbox out of this.context
-    this.sandbox = new Cu.Sandbox(this._window,
-      { sandboxPrototype: this._window, wantXrays: false });
-    this.sandbox.console = this.console;
-    JSTermHelper(this);
-  },
-
-  get _window()
-  {
-    return this.context.get().QueryInterface(Ci.nsIDOMWindow);
-  },
-
-  /**
-   * Evaluates a string in the sandbox.
+
+  /**
+   * Asynchronously evaluate a string in the content process sandbox.
    *
    * @param string aString
    *        String to evaluate in the sandbox.
-   * @returns something
-   *          The result of the evaluation.
-   */
-  evalInSandbox: function JST_evalInSandbox(aString)
+   */
+  // TODO: recheck comment
+  evalInContentSandbox: function JST_evalInContentSandbox(aString, aCallback)
   {
-    // The help function needs to be easy to guess, so we make the () optional
-    if (aString.trim() === "help" || aString.trim() === "?") {
-      aString = "help()";
-    }
-
-    let window = WebConsoleUtils.unwrap(this.sandbox.window);
-    let $ = null, $$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      $ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      $$ = this.sandbox.$$;
-      delete this.sandbox.$$;
-    }
-
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
-
-    if ($) {
-      this.sandbox.$ = $;
-    }
-    if ($$) {
-      this.sandbox.$$ = $$;
-    }
-
-    return result;
-  },
-
+    let message = {
+      str: aString,
+      resultCacheId: "HUDEval-" + HUDService.sequenceId(),
+    };
+
+    this.hud.sendMessageToContent("JSTerm:EvalRequest", message, aCallback);
+
+    return message;
+  },
+
+  _executeResultCallback:
+  function JST__executeResultCallback(aResponse, aRequest)
+  {
+    let errorMessage = aResponse.errorMessage;
+    let resultString = aResponse.resultString;
+
+    // Hide undefined results coming from JSTerm helper functions.
+    if (!errorMessage && resultString == "undefined" &&
+        aResponse.helperResult && !aResponse.inspectable &&
+        !aResponse.helperRawOutput) {
+      return;
+    }
+
+    let afterNode = aRequest.outputNode;
+
+    if (aResponse.errorMessage) {
+      this.writeOutput(aResponse.errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR,
+                       afterNode);
+    }
+    else if (aResponse.inspectable) {
+      let node = this.writeOutputJS(aResponse.resultString,
+                                    this._evalOutputClick.bind(this, aResponse),
+                                    afterNode);
+      node._evalCacheId = aResponse.childrenCacheId;
+    }
+    else {
+      this.writeOutput(aResponse.resultString, CATEGORY_OUTPUT, SEVERITY_LOG,
+                       afterNode);
+    }
+  },
 
   execute: function JST_execute(aExecuteString)
   {
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       this.writeOutput("no value to execute", CATEGORY_OUTPUT, SEVERITY_LOG);
       return;
     }
 
-    this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
-
-    try {
-      this.helperEvaluated = false;
-      let result = this.evalInSandbox(aExecuteString);
-
-      // Hide undefined results coming from helpers.
-      let shouldShow = !(result === undefined && this.helperEvaluated);
-      if (shouldShow) {
-        let inspectable = WebConsoleUtils.isObjectInspectable(result);
-        let resultString = WebConsoleUtils.formatResult(result);
-
-        if (inspectable) {
-          this.writeOutputJS(aExecuteString, result, resultString);
-        }
-        else {
-          this.writeOutput(resultString, CATEGORY_OUTPUT, SEVERITY_LOG);
-        }
-      }
-    }
-    catch (ex) {
-      this.writeOutput("" + ex, CATEGORY_OUTPUT, SEVERITY_ERROR);
-    }
+    let node = this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
+
+    let messageToContent =
+      this.evalInContentSandbox(aExecuteString,
+                                this._executeResultCallback.bind(this));
+    messageToContent.outputNode = node;
 
     this.history.push(aExecuteString);
     this.historyIndex++;
     this.historyPlaceHolder = this.history.length;
     this.setInputValue("");
     this.clearCompletion();
   },
 
   /**
-   * Opens a new PropertyPanel. The panel has two buttons: "Update" reexecutes
-   * the passed aEvalString and places the result inside of the tree. The other
-   * button closes the panel.
-   *
-   * @param string aEvalString
-   *        String that was used to eval the aOutputObject. Used as title
-   *        and to update the tree content.
-   * @param object aOutputObject
-   *        Object to display/inspect inside of the tree.
-   * @param nsIDOMNode aAnchor
-   *        A node to popup the panel next to (using "after_pointer").
-   * @returns object the created and opened propertyPanel.
-   */
-  openPropertyPanel: function JST_openPropertyPanel(aEvalString, aOutputObject,
-                                                    aAnchor)
-  {
-    let self = this;
-    let propPanel;
-    // The property panel has one button:
-    //    `Update`: reexecutes the string executed on the command line. The
-    //    result will be inspected by this panel.
-    let buttons = [];
-
-    // If there is a evalString passed to this function, then add a `Update`
-    // button to the panel so that the evalString can be reexecuted to update
-    // the content of the panel.
-    if (aEvalString !== null) {
-      buttons.push({
-        label: l10n.getStr("update.button"),
-        accesskey: l10n.getStr("update.accesskey"),
-        oncommand: function () {
-          try {
-            var result = self.evalInSandbox(aEvalString);
-
-            if (result !== undefined) {
-              // TODO: This updates the value of the tree.
-              // However, the states of opened nodes is not saved.
-              // See bug 586246.
-              propPanel.treeView.data = result;
-            }
-          }
-          catch (ex) {
-            self.console.error(ex);
-          }
-        }
-      });
-    }
-
-    let doc = self.document;
-    let parent = doc.getElementById("mainPopupSet");
-    let title = (aEvalString
-        ? l10n.getFormatStr("jsPropertyInspectTitle", [aEvalString])
-        : l10n.getStr("jsPropertyTitle"));
-
-    propPanel = new PropertyPanel(parent, doc, title, aOutputObject, buttons);
-    propPanel.linkNode = aAnchor;
-
-    let panel = propPanel.panel;
-    panel.openPopup(aAnchor, "after_pointer", 0, 0, false, false);
-    panel.sizeTo(350, 450);
-    return propPanel;
-  },
-
-  /**
    * Opens a new property panel that allows the inspection of the given object.
    * The object information can be retrieved both async and sync, depending on
    * the given options.
    *
    * @param object aOptions
    *        Property panel options:
    *        - title:
    *        Panel title.
    *        - anchor:
    *        The DOM element you want the panel to be anchored to.
    *        - updateButtonCallback:
    *        An optional function you want invoked when the user clicks the
    *        Update button. If this function is not provided the Update button is
    *        not shown.
    *        - data:
    *        An object that represents the object you want to inspect. Please see
-   *        the PropertyPanelAsync documentation - this object is passed to the
-   *        PropertyPanelAsync constructor
-   * @param object aResponse
-   *        The response object to display/inspect inside of the tree.
-   * @param nsIDOMNode aAnchor
-   *        A node to popup the panel next to (using "after_pointer").
+   *        the PropertyPanel documentation - this object is passed to the
+   *        PropertyPanel constructor
    * @return object
-   *         The new instance of PropertyPanelAsync.
-   */
-  openPropertyPanelAsync: function JST_openPropertyPanelAsync(aOptions)
+   *         The new instance of PropertyPanel.
+   */
+  openPropertyPanel: function JST_openPropertyPanel(aOptions)
   {
     // The property panel has one button:
     //    `Update`: reexecutes the string executed on the command line. The
     //    result will be inspected by this panel.
     let buttons = [];
 
     if (aOptions.updateButtonCallback) {
       buttons.push({
@@ -5060,17 +4403,17 @@ JSTerm.prototype = {
       });
     }
 
     let parent = this.document.getElementById("mainPopupSet");
     let title = aOptions.title ?
                 l10n.getFormatStr("jsPropertyInspectTitle", [aOptions.title]) :
                 l10n.getStr("jsPropertyTitle");
 
-    let propPanel = new PropertyPanelAsync(parent, title, aOptions.data, buttons);
+    let propPanel = new PropertyPanel(parent, title, aOptions.data, buttons);
 
     propPanel.panel.openPopup(aOptions.anchor, "after_pointer", 0, 0, false, false);
     propPanel.panel.sizeTo(350, 450);
 
     if (aOptions.anchor) {
       propPanel.panel.addEventListener("popuphiding", function onPopupHide() {
         propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
         aOptions.anchor._panelOpen = false;
@@ -5081,79 +4424,53 @@ JSTerm.prototype = {
     return propPanel;
   },
 
   /**
    * Writes a JS object to the JSTerm outputNode. If the user clicks on the
    * written object, openPropertyPanel is called to open up a panel to inspect
    * the object.
    *
-   * @param string aEvalString
-   *        String that was evaluated to get the aOutputObject.
-   * @param object aResultObject
-   *        The evaluation result object.
-   * @param object aOutputString
-   *        The output string to be written to the outputNode.
-   */
-  writeOutputJS: function JST_writeOutputJS(aEvalString, aOutputObject, aOutputString)
+   * @param object aResponse
+   *        The evaluation result object, coming from the content process.
+   */
+  // TODO: update comment.
+  writeOutputJS:
+  function JST_writeOutputJS(aOutputMessage, aCallback, aNodeAfter)
   {
-    let node = ConsoleUtils.createMessageNode(this.document,
-                                              CATEGORY_OUTPUT,
-                                              SEVERITY_LOG,
-                                              aOutputString,
-                                              this.hudId);
-
-    let linkNode = node.querySelector(".webconsole-msg-body");
-
-    linkNode.classList.add("hud-clickable");
-    linkNode.setAttribute("aria-haspopup", "true");
-
-    // Make the object bring up the property panel.
-    node.addEventListener("mousedown", function(aEvent) {
-      this._startX = aEvent.clientX;
-      this._startY = aEvent.clientY;
-    }, false);
-
-    let self = this;
-    node.addEventListener("click", function(aEvent) {
-      if (aEvent.detail != 1 || aEvent.button != 0 ||
-          (this._startX != aEvent.clientX &&
-           this._startY != aEvent.clientY)) {
-        return;
-      }
-
-      if (!this._panelOpen) {
-        let propPanel = self.openPropertyPanel(aEvalString, aOutputObject, this);
-        propPanel.panel.setAttribute("hudId", self.hudId);
-        this._panelOpen = true;
-      }
-    }, false);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
+    let node = this.writeOutput(aOutputMessage, CATEGORY_OUTPUT, SEVERITY_LOG,
+                                aNodeAfter);
+    if (aCallback) {
+      this.hud.makeOutputMessageLink(node, aCallback);
+    }
+    return node;
   },
 
   /**
    * Writes a message to the HUD that originates from the interactive
    * JavaScript console.
    *
    * @param string aOutputMessage
    *        The message to display.
    * @param number aCategory
    *        The category of message: one of the CATEGORY_ constants.
    * @param number aSeverity
    *        The severity of message: one of the SEVERITY_ constants.
    * @returns void
    */
-  writeOutput: function JST_writeOutput(aOutputMessage, aCategory, aSeverity)
+  // TODO: update comment.
+  writeOutput:
+  function JST_writeOutput(aOutputMessage, aCategory, aSeverity, aNodeAfter)
   {
-    let node = ConsoleUtils.createMessageNode(this.document,
-                                              aCategory, aSeverity,
-                                              aOutputMessage, this.hudId);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
+    let node = ConsoleUtils.createMessageNode(this.document, aCategory,
+                                              aSeverity, aOutputMessage,
+                                              this.hudId);
+
+    ConsoleUtils.outputMessageNode(node, this.hudId, aNodeAfter);
+    return node;
   },
 
   /**
    * Clear the Web Console output.
    *
    * @param boolean aClearStorage
    *        True if you want to clear the console messages storage associated to
    *        this Web Console.
@@ -5434,17 +4751,17 @@ JSTerm.prototype = {
   // Stores the data for the last completion.
   lastCompletion: null,
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
    * only if the selection/cursor is at the end of the string. If no completion
    * is found, the current inputNode value and cursor/selection stay.
    *
-   * @param int type possible values are
+   * @param int aType possible values are
    *    - this.COMPLETE_FORWARD: If there is more than one possible completion
    *          and the input value stayed the same compared to the last time this
    *          function was called, then the next completion of all possible
    *          completions is used. If the value changed, then the first possible
    *          completion is used and the selection is set from the current
    *          cursor position to the end of the completed text.
    *          If there is only one possible completion, then this completion
    *          value is used and the cursor is put at the end of the completion.
@@ -5453,102 +4770,158 @@ JSTerm.prototype = {
    *          then the previous completion of all possible completions is used.
    *    - this.COMPLETE_HINT_ONLY: If there is more than one possible
    *          completion and the input value stayed the same compared to the
    *          last time this function was called, then the same completion is
    *          used again. If there is only one possible completion, then
    *          the inputNode.value is set to this value and the selection is set
    *          from the current cursor position to the end of the completed text.
    *
+   * @param function aCallback
+   *        Optional function invoked when the autocomplete properties are
+   *        updated.
+   *
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
-  complete: function JSTF_complete(type)
+  complete: function JSTF_complete(aType, aCallback)
   {
     let inputNode = this.inputNode;
     let inputValue = inputNode.value;
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       return false;
     }
 
     // Only complete if the selection is empty and at the end of the input.
     if (inputNode.selectionStart == inputNode.selectionEnd &&
         inputNode.selectionEnd != inputValue.length) {
       this.clearCompletion();
       return false;
     }
 
+    // Update the completion results.
+    if (this.lastCompletion.value != inputValue) {
+      this.updateCompletionResult(aType, aCallback);
+      return false;
+    }
+
     let popup = this.autocompletePopup;
-
-    if (!this.lastCompletion || this.lastCompletion.value != inputValue) {
-      let properties = this.propertyProvider(this.sandbox.window, inputValue);
-      if (!properties || !properties.matches.length) {
-        this.clearCompletion();
-        return false;
-      }
-
-      let items = properties.matches.map(function(aMatch) {
-        return {label: aMatch};
-      });
-      popup.setItems(items);
-      this.lastCompletion = {value: inputValue,
-                             matchProp: properties.matchProp};
-
-      if (items.length > 1 && !popup.isOpen) {
-        popup.openPopup(this.inputNode);
-      }
-      else if (items.length < 2 && popup.isOpen) {
-        popup.hidePopup();
-      }
-
-      if (items.length == 1) {
-          popup.selectedIndex = 0;
-      }
-      this.onAutocompleteSelect();
-    }
-
     let accepted = false;
 
-    if (type != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+    if (aType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
       this.acceptProposedCompletion();
       accepted = true;
     }
-    else if (type == this.COMPLETE_BACKWARD) {
-      this.autocompletePopup.selectPreviousItem();
-    }
-    else if (type == this.COMPLETE_FORWARD) {
-      this.autocompletePopup.selectNextItem();
-    }
-
+    else if (aType == this.COMPLETE_BACKWARD) {
+      popup.selectPreviousItem();
+    }
+    else if (aType == this.COMPLETE_FORWARD) {
+      popup.selectNextItem();
+    }
+
+    aCallback && aCallback(this);
     return accepted || popup.itemCount > 0;
   },
 
+  updateCompletionResult: function JST_updateCompletionResult(aType, aCallback)
+  {
+    if (this.lastCompletion.value == this.inputNode.value) {
+      return;
+    }
+
+    let message = {
+      id: "HUDComplete-" + HUDService.sequenceId(),
+      input: this.inputNode.value,
+    };
+
+    this.lastCompletion = {requestId: message.id, completionType: aType};
+    let callback = this.receiveAutocompleteProperties.bind(this, aCallback);
+    this.hud.sendMessageToContent("JSTerm:Autocomplete", message, callback);
+  },
+
+
+  receiveAutocompleteProperties:
+  function JST_receiveAutocompleteProperties(aCallback, aMessage)
+  {
+    let inputNode = this.inputNode;
+    let inputValue = inputNode.value;
+    if (aMessage.input != inputValue ||
+        this.lastCompletion.value == inputValue ||
+        aMessage.id != this.lastCompletion.requestId) {
+      return;
+    }
+
+    let matches = aMessage.matches;
+    if (!matches.length) {
+      this.clearCompletion();
+      return;
+    }
+
+    let items = matches.map(function(aMatch) {
+      return { label: aMatch };
+    });
+
+    let popup = this.autocompletePopup;
+    popup.setItems(items);
+
+    let completionType = this.lastCompletion.completionType;
+    this.lastCompletion = {
+      value: inputValue,
+      matchProp: aMessage.matchProp,
+    };
+
+    if (items.length > 1 && !popup.isOpen) {
+      popup.openPopup(inputNode);
+    }
+    else if (items.length < 2 && popup.isOpen) {
+      popup.hidePopup();
+    }
+
+    if (items.length == 1) {
+      popup.selectedIndex = 0;
+    }
+
+    this.onAutocompleteSelect();
+
+    if (completionType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+      this.acceptProposedCompletion();
+    }
+    else if (completionType == this.COMPLETE_BACKWARD) {
+      popup.selectPreviousItem();
+    }
+    else if (completionType == this.COMPLETE_FORWARD) {
+      popup.selectNextItem();
+    }
+
+    aCallback && aCallback(this);
+  },
+
   onAutocompleteSelect: function JSTF_onAutocompleteSelect()
   {
     let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion) {
+    if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.updateCompleteNode(suffix);
     }
     else {
       this.updateCompleteNode("");
     }
   },
 
   /**
    * Clear the current completion information and close the autocomplete popup,
    * if needed.
    */
   clearCompletion: function JSTF_clearCompletion()
   {
     this.autocompletePopup.clearItems();
-    this.lastCompletion = null;
+    this.lastCompletion = {};
     this.updateCompleteNode("");
     if (this.autocompletePopup.isOpen) {
       this.autocompletePopup.hidePopup();
     }
   },
 
   /**
    * Accept the proposed input completion.
@@ -5557,17 +4930,17 @@ JSTerm.prototype = {
    *         True if there was a selected completion item and the input value
    *         was updated, false otherwise.
    */
   acceptProposedCompletion: function JSTF_acceptProposedCompletion()
   {
     let updated = false;
 
     let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion) {
+    if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.setInputValue(this.inputNode.value + suffix);
       updated = true;
     }
 
     this.clearCompletion();
 
@@ -5591,18 +4964,17 @@ JSTerm.prototype = {
    * Clear the object cache from the Web Console content instance.
    *
    * @param string aCacheId
    *        The cache ID you want to clear. Multiple objects are cached into one
    *        group which is given an ID.
    */
   clearObjectCache: function JST_clearObjectCache(aCacheId)
   {
-    let hud = HUDService.getHudReferenceById(this.hudId);
-    hud.sendMessageToContent("JSTerm:ClearObjectCache", {cacheId: aCacheId});
+    this.hud.sendMessageToContent("JSTerm:ClearObjectCache", {cacheId: aCacheId});
   },
 
   /**
    * The remote object provider allows you to retrieve a given object from
    * a specific cache and have your callback invoked when the desired object is
    * received from the Web Console content instance.
    *
    * @param string aCacheId
@@ -5619,28 +4991,139 @@ JSTerm.prototype = {
   function JST_remoteObjectProvider(aCacheId, aObjectId, aResultCacheId,
                                     aCallback) {
     let message = {
       cacheId: aCacheId,
       objectId: aObjectId,
       resultCacheId: aResultCacheId,
     };
 
-    let hud = HUDService.getHudReferenceById(this.hudId);
-    hud.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
+    this.hud.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
+  },
+
+  handleInspectObject: function JST_handleInspectObject(aRequest)
+  {
+    let options = {
+      title: aRequest.input,
+
+      data: {
+        rootCacheId: aRequest.objectCacheId,
+        panelCacheId: aRequest.objectCacheId,
+        remoteObject: aRequest.resultObject,
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      this.clearObjectCache(options.data.panelCacheId);
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
+  _evalOutputClick: function JST__evalOutputClick(aResponse, aLinkNode)
+  {
+    if (aLinkNode._panelOpen) {
+      return;
+    }
+
+    let options = {
+      title: aResponse.input,
+      anchor: aLinkNode,
+
+      // Data to inspect.
+      data: {
+        // This is where the resultObject children are cached.
+        rootCacheId: aResponse.childrenCacheId,
+        remoteObject: aResponse.resultObject,
+        // This is where all objects retrieved by the panel will be cached.
+        panelCacheId: "HUDPanel-" + HUDService.sequenceId(),
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    options.updateButtonCallback = function() {
+      this.evalInContentSandbox(aResponse.input,
+        this._updatePanelCallback.bind(this, options, propPanel, aResponse));
+    }.bind(this);
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      this.clearObjectCache(options.data.panelCacheId);
+
+      if (!aLinkNode.parentNode && aLinkNode._evalCacheId) {
+        this.clearObjectCache(aLinkNode._evalCacheId);
+      }
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
+  _updatePanelCallback:
+  function JST__updatePanelCallback(aOptions, aPropPanel, aOldResponse,
+                                    aNewResponse)
+  {
+    if (aNewResponse.errorMessage) {
+      this.writeOutput(aNewResponse.errorMessage, CATEGORY_OUTPUT,
+                       SEVERITY_ERROR);
+      return;
+    }
+
+    if (!aNewResponse.inspectable) {
+      // TODO: decide what to do here. clear treeView.data? output an error?
+      return;
+    }
+
+    this.clearObjectCache(aOptions.data.panelCacheId);
+    this.clearObjectCache(aOptions.data.rootCacheId);
+
+    if (aOptions.anchor && aOptions.anchor._evalCacheId) {
+      aOptions.anchor._evalCacheId = aNewResponse.childrenCacheId;
+    }
+
+    // Update the old response object such that when the panel is reopen, the
+    // user sees the new response.
+    aOldResponse.id = aNewResponse.id;
+    aOldResponse.childrenCacheId = aNewResponse.childrenCacheId;
+    aOldResponse.resultObject = aNewResponse.resultObject;
+    aOldResponse.resultString = aNewResponse.resultString;
+
+    aOptions.data.rootCacheId = aNewResponse.childrenCacheId;
+    aOptions.data.remoteObject = aNewResponse.resultObject;
+
+    // TODO: This updates the value of the tree.
+    // However, the states of open nodes is not saved.
+    // See bug 586246.
+    aPropPanel.treeView.data = aOptions.data;
   },
 
   /**
    * Destroy the JSTerm object. Call this method to avoid memory leaks.
    */
   destroy: function JST_destroy()
   {
+    this.clearCompletion();
+    this.clearOutput();
+
+    this.autocompletePopup.destroy();
+
     this.inputNode.removeEventListener("keypress", this._keyPress, false);
     this.inputNode.removeEventListener("input", this._inputEventHandler, false);
     this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
+
+    delete this.history;
   },
 };
 
 /**
  * Generates and attaches the JS Terminal part of the Web Console, which
  * essentially consists of the interactive JavaScript input facility.
  *
  * @param nsWeakPtr<nsIDOMWindow> aContext
@@ -5657,17 +5140,16 @@ JSTermFirefoxMixin(aContext,
                    aExistingConsole)
 {
   // aExisting Console is the existing outputNode to use in favor of
   // creating a new outputNode - this is so we can just attach the inputNode to
   // a normal HeadsUpDisplay console output, and re-use code.
   this.context = aContext;
   this.parentNode = aParentNode;
   this.existingConsoleNode = aExistingConsole;
-  this.setTimeout = aParentNode.ownerDocument.defaultView.setTimeout;
 
   if (aParentNode.ownerDocument) {
     this.xulElementFactory =
       NodeFactory("xul", "xul", aParentNode.ownerDocument);
 
     this.textFactory = NodeFactory("text", "xul", aParentNode.ownerDocument);
     this.generateUI();
     this.attachUI();
@@ -5930,17 +5412,17 @@ ConsoleUtils = {
       tree.appendChild(treecols);
 
       tree.appendChild(aDocument.createElement("treechildren"));
 
       bodyContainer.appendChild(tree);
       node.appendChild(bodyContainer);
       node.classList.add("webconsole-msg-inspector");
       // Create the treeView object.
-      let treeView = node.propertyTreeView = new PropertyTreeViewAsync();
+      let treeView = node.propertyTreeView = new PropertyTreeView();
 
       treeView.data = {
         rootCacheId: body.cacheId,
         panelCacheId: body.cacheId,
         remoteObject: body.remoteObject,
         remoteObjectProvider: body.remoteObjectProvider,
       };
 
@@ -6167,18 +5649,21 @@ ConsoleUtils = {
   /**
    * Filters a node appropriately, then sends it to the output, regrouping and
    * pruning output as necessary.
    *
    * @param nsIDOMNode aNode
    *        The message node to send to the output.
    * @param string aHUDId
    *        The ID of the HUD in which to insert this node.
-   */
-  outputMessageNode: function ConsoleUtils_outputMessageNode(aNode, aHUDId) {
+   * @param nsIDOMNode [aNodeAfter]
+   *        Insert the node after the given aNodeAfter (optional).
+   */
+  outputMessageNode:
+  function ConsoleUtils_outputMessageNode(aNode, aHUDId, aNodeAfter) {
     ConsoleUtils.filterMessageNode(aNode, aHUDId);
     let outputNode = HUDService.hudReferences[aHUDId].outputNode;
 
     let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
 
     let isRepeated = false;
     if (aNode.classList.contains("webconsole-msg-cssparser")) {
       isRepeated = this.filterRepeatedCSS(aNode, outputNode, aHUDId);
@@ -6187,17 +5672,17 @@ ConsoleUtils = {
     if (!isRepeated &&
         (aNode.classList.contains("webconsole-msg-console") ||
          aNode.classList.contains("webconsole-msg-exception") ||
          aNode.classList.contains("webconsole-msg-error"))) {
       isRepeated = this.filterRepeatedConsole(aNode, outputNode);
     }
 
     if (!isRepeated) {
-      outputNode.appendChild(aNode);
+      outputNode.insertBefore(aNode, aNodeAfter ? aNodeAfter.nextSibling : null);
     }
 
     HUDService.regroupOutput(outputNode);
 
     if (pruneConsoleOutputIfNecessary(aHUDId, aNode.category) == 0) {
       // We can't very well scroll to make the message node visible if the log
       // limit is zero and the node was destroyed in the first place.
       return;
@@ -6389,86 +5874,46 @@ HeadsUpDisplayUICommands = {
       }
       case "saveBodies": {
         let checked = aButton.getAttribute("checked") === "true";
         HUDService.saveRequestAndResponseBodies = checked;
         break;
       }
     }
   },
-
 };
 
-/**
- * A Console log entry
- *
- * @param JSObject aConfig, object literal with ConsolEntry properties
- * @param integer aId
- * @returns void
- */
-
-function ConsoleEntry(aConfig, id)
-{
-  if (!aConfig.logLevel && aConfig.message) {
-    throw new Error("Missing Arguments when creating a console entry");
-  }
-
-  this.config = aConfig;
-  this.id = id;
-  for (var prop in aConfig) {
-    if (!(typeof aConfig[prop] == "function")){
-      this[prop] = aConfig[prop];
-    }
-  }
-
-  if (aConfig.logLevel == "network") {
-    this.transactions = { };
-    if (aConfig.activity) {
-      this.transactions[aConfig.activity.stage] = aConfig.activity;
-    }
-  }
-
-}
-
-ConsoleEntry.prototype = {
-
-  updateTransaction: function CE_updateTransaction(aActivity) {
-    this.transactions[aActivity.stage] = aActivity;
-  }
-};
-
 //////////////////////////////////////////////////////////////////////////
-// HUDWindowObserver
+// WebConsoleObserver
 //////////////////////////////////////////////////////////////////////////
 
-HUDWindowObserver = {
+let WebConsoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
-  init: function HWO_init()
+  init: function WCO_init()
   {
     Services.obs.addObserver(this, "content-document-global-created", false);
     Services.obs.addObserver(this, "quit-application-granted", false);
   },
 
-  observe: function HWO_observe(aSubject, aTopic, aData)
+  observe: function WCO_observe(aSubject, aTopic)
   {
     if (aTopic == "content-document-global-created") {
       HUDService.windowInitializer(aSubject);
     }
     else if (aTopic == "quit-application-granted") {
       HUDService.shutdown();
     }
   },
 
-  uninit: function HWO_uninit()
+  uninit: function WCO_uninit()
   {
     Services.obs.removeObserver(this, "content-document-global-created");
     Services.obs.removeObserver(this, "quit-application-granted");
   },
-
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * A controller (an instance of nsIController) that makes editing actions
@@ -6893,16 +6338,17 @@ GcliTerm.prototype = {
 
         linkNode.addEventListener("click", function(aEv) {
           if (aEv.detail != 1 || aEv.button != 0 ||
               (this._startX != aEv.clientX && this._startY != aEv.clientY)) {
             return;
           }
 
           if (!this._panelOpen) {
+            // FIXME: different openPropertyPanel()
             let propPanel = this.openPropertyPanel(aEvent.output.typed, aEvent.output.output, this);
             propPanel.panel.setAttribute("hudId", this.hudId);
             this._panelOpen = true;
           }
         }.bind(this), false);
 
         output = linkNode;
       }
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -41,17 +41,16 @@ DEPTH		= ../../..
 topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		PropertyPanel.jsm \
-		PropertyPanelAsync.jsm \
 		NetworkHelper.jsm \
 		AutocompletePopup.jsm \
 		WebConsoleUtils.jsm \
 		gcli.jsm \
 		GcliCommands.jsm \
 		GcliTiltCommands.jsm \
 		$(NULL)
 
diff --git a/browser/devtools/webconsole/PropertyPanel.jsm b/browser/devtools/webconsole/PropertyPanel.jsm
--- a/browser/devtools/webconsole/PropertyPanel.jsm
+++ b/browser/devtools/webconsole/PropertyPanel.jsm
@@ -8,443 +8,321 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
- * The Original Code is DevTools (HeadsUpDisplay) Console Code
+ * The Original Code is DevTools Web Console Property Panel.
  *
  * The Initial Developer of the Original Code is
  * the Mozilla Foundation.
  * Portions created by the Initial Developer are Copyright (C) 2010
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Rob Campbell <rcampbell@mozilla.com>
  *   Julian Viereck <jviereck@mozilla.com>
+ *   Mihai Sucan <mihai.sucan@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+"use strict";
+
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
-var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView",
-                        "namesAndValuesOf", "isNonNativeGetter"];
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
 
-///////////////////////////////////////////////////////////////////////////
-//// Helper for PropertyTreeView
+var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView"];
 
-const TYPE_OBJECT = 0, TYPE_FUNCTION = 1, TYPE_ARRAY = 2, TYPE_OTHER = 3;
-
-/**
- * Figures out the type of aObject and the string to display in the tree.
- *
- * @param object aObject
- *        The object to operate on.
- * @returns object
- *          A object with the form:
- *            {
- *              type: TYPE_OBJECT || TYPE_FUNCTION || TYPE_ARRAY || TYPE_OTHER,
- *              display: string for displaying the object in the tree
- *            }
- */
-function presentableValueFor(aObject)
-{
-  if (aObject === null || aObject === undefined) {
-    return {
-      type: TYPE_OTHER,
-      display: aObject === undefined ? "undefined" : "null"
-    };
-  }
-
-  let presentable;
-  switch (aObject.constructor && aObject.constructor.name) {
-    case "Array":
-      return {
-        type: TYPE_ARRAY,
-        display: "Array"
-      };
-
-    case "String":
-      return {
-        type: TYPE_OTHER,
-        display: "\"" + aObject + "\""
-      };
-
-    case "Date":
-    case "RegExp":
-    case "Number":
-    case "Boolean":
-      return {
-        type: TYPE_OTHER,
-        display: aObject
-      };
-
-    case "Iterator":
-      return {
-        type: TYPE_OTHER,
-        display: "Iterator"
-      };
-
-    case "Function":
-      presentable = aObject.toString();
-      return {
-        type: TYPE_FUNCTION,
-        display: presentable.substring(0, presentable.indexOf(')') + 1)
-      };
-
-    default:
-      presentable = aObject.toString();
-      let m = /^\[object (\S+)\]/.exec(presentable);
-
-      try {
-        if (typeof aObject == "object" && typeof aObject.next == "function" &&
-            m && m[1] == "Generator") {
-          return {
-            type: TYPE_OTHER,
-            display: m[1]
-          };
-        }
-      }
-      catch (ex) {
-        // window.history.next throws in the typeof check above.
-        return {
-          type: TYPE_OBJECT,
-          display: m ? m[1] : "Object"
-        };
-      }
-
-      if (typeof aObject == "object" && typeof aObject.__iterator__ == "function") {
-        return {
-          type: TYPE_OTHER,
-          display: "Iterator"
-        };
-      }
-
-      return {
-        type: TYPE_OBJECT,
-        display: m ? m[1] : "Object"
-      };
-  }
-}
-
-/**
- * Tells if the given function is native or not.
- *
- * @param function aFunction
- *        The function you want to check if it is native or not.
- *
- * @return boolean
- *         True if the given function is native, false otherwise.
- */
-function isNativeFunction(aFunction)
-{
-  return typeof aFunction == "function" && !("prototype" in aFunction);
-}
-
-/**
- * Tells if the given property of the provided object is a non-native getter or
- * not.
- *
- * @param object aObject
- *        The object that contains the property.
- *
- * @param string aProp
- *        The property you want to check if it is a getter or not.
- *
- * @return boolean
- *         True if the given property is a getter, false otherwise.
- */
-function isNonNativeGetter(aObject, aProp) {
-  if (typeof aObject != "object") {
-    return false;
-  }
-  let desc;
-  while (aObject) {
-    try {
-      if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
-        break;
-      }
-    }
-    catch (ex) {
-      // Native getters throw here. See bug 520882.
-      if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
-          ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
-        return false;
-      }
-      throw ex;
-    }
-    aObject = Object.getPrototypeOf(aObject);
-  }
-  if (desc && desc.get && !isNativeFunction(desc.get)) {
-    return true;
-  }
-  return false;
-}
-
-/**
- * Get an array of property name value pairs for the tree.
- *
- * @param object aObject
- *        The object to get properties for.
- * @returns array of object
- *          Objects have the name, value, display, type, children properties.
- */
-function namesAndValuesOf(aObject)
-{
-  let pairs = [];
-  let value, presentable;
-
-  let isDOMDocument = aObject instanceof Ci.nsIDOMDocument;
-
-  for (var propName in aObject) {
-    // See bug 632275: skip deprecated width and height properties.
-    if (isDOMDocument && (propName == "width" || propName == "height")) {
-      continue;
-    }
-
-    // Also skip non-native getters.
-    if (isNonNativeGetter(aObject, propName)) {
-      value = ""; // Value is never displayed.
-      presentable = {type: TYPE_OTHER, display: "Getter"};
-    }
-    else {
-      try {
-        value = aObject[propName];
-        presentable = presentableValueFor(value);
-      }
-      catch (ex) {
-        continue;
-      }
-    }
-
-    let pair = {};
-    pair.name = propName;
-    pair.display = propName + ": " + presentable.display;
-    pair.type = presentable.type;
-    pair.value = value;
-
-    // Convert the pair.name to a number for later sorting.
-    pair.nameNumber = parseFloat(pair.name)
-    if (isNaN(pair.nameNumber)) {
-      pair.nameNumber = false;
-    }
-
-    pairs.push(pair);
-  }
-
-  pairs.sort(function(a, b)
-  {
-    // Sort numbers.
-    if (a.nameNumber !== false && b.nameNumber === false) {
-      return -1;
-    }
-    else if (a.nameNumber === false && b.nameNumber !== false) {
-      return 1;
-    }
-    else if (a.nameNumber !== false && b.nameNumber !== false) {
-      return a.nameNumber - b.nameNumber;
-    }
-    // Sort string.
-    else if (a.name < b.name) {
-      return -1;
-    }
-    else if (a.name > b.name) {
-      return 1;
-    }
-    else {
-      return 0;
-    }
-  });
-
-  return pairs;
-}
 
 ///////////////////////////////////////////////////////////////////////////
 //// PropertyTreeView.
 
-
 /**
  * This is an implementation of the nsITreeView interface. For comments on the
  * interface properties, see the documentation:
  * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsITreeView
  */
 var PropertyTreeView = function() {
   this._rows = [];
+  this._objectCache = {};
 };
 
 PropertyTreeView.prototype = {
-
   /**
    * Stores the visible rows of the tree.
+   * @private
    */
   _rows: null,
 
   /**
    * Stores the nsITreeBoxObject for this tree.
+   * @private
    */
   _treeBox: null,
 
   /**
+   * Stores cached information about local objects being inspected.
+   * @private
+   */
+  _objectCache: null,
+
+  /**
    * Use this setter to update the content of the tree.
    *
    * @param object aObject
-   *        The new object to be displayed in the tree.
-   * @returns void
+   *        An object that holds information about the object you want to
+   *        display in the property panel. Object properties:
+   *        - object:
+   *        This is the raw object you want to display. You can only provide
+   *        this object if you want the property panel to work in sync mode.
+   *        - remoteObject:
+   *        An array that holds information on the remote object being
+   *        inspected. Each element in this array describes each property in the
+   *        remote object. See WebConsoleUtils.namesAndValuesOf() for details.
+   *        - rootCacheId:
+   *        The cache ID where the objects referenced in remoteObject are found.
+   *        - panelCacheId:
+   *        The cache ID where any object retrieved by this property panel
+   *        instance should be stored into.
+   *        - remoteObjectProvider:
+   *        A function that is invoked when a new object is needed. This is
+   *        called when the user tries to expand an inspectable property. The
+   *        callback must take four arguments:
+   *          - fromCacheId:
+   *          Tells from where to retrieve the object the user picked (from
+   *          which cache ID).
+   *          - objectId:
+   *          The object ID the user wants.
+   *          - panelCacheId:
+   *          Tells in which cache ID to store the objects referenced by
+   *          objectId so they can be retrieved later.
+   *          - callback:
+   *          The callback function to be invoked when the remote object is
+   *          received. This function takes one argument: the raw message
+   *          received from the Web Console content script.
    */
-  set data(aObject) {
+  set data(aData) {
     let oldLen = this._rows.length;
-    this._rows = this.getChildItems(aObject, true);
+
+    this._cleanup();
+
+    if (!aData) {
+      return;
+    }
+
+    if (aData.remoteObject) {
+      this._rootCacheId = aData.rootCacheId;
+      this._panelCacheId = aData.panelCacheId;
+      this._remoteObjectProvider = aData.remoteObjectProvider;
+      this._rows = [].concat(aData.remoteObject);
+      this._updateRemoteObject(this._rows, 0);
+    }
+    else if (aData.object) {
+      this._rows = this._inspectObject(aData.object);
+    }
+    else {
+      throw new Error("First argument must have a .remoteObject or " +
+                      "an .object property!");
+    }
+
     if (this._treeBox) {
       this._treeBox.beginUpdateBatch();
       if (oldLen) {
         this._treeBox.rowCountChanged(0, -oldLen);
       }
       this._treeBox.rowCountChanged(0, this._rows.length);
       this._treeBox.endUpdateBatch();
     }
   },
 
   /**
-   * Generates the child items for the treeView of a given aItem. If there is
-   * already a children property on the aItem, this cached one is returned.
+   * Update a remote object so it can be used with the tree view. This method
+   * adds properties to each array element.
    *
-   * @param object aItem
-   *        An item of the tree's elements to generate the children for.
-   * @param boolean aRootElement
-   *        If set, aItem is handled as an JS object and not as an item
-   *        element of the tree.
-   * @returns array of objects
-   *        Child items of aItem.
+   * @private
+   * @param array aObject
+   *        The remote object you want prepared for use with the tree view.
+   * @param number aLevel
+   *        The level you want to give to each property in the remote object.
    */
-  getChildItems: function(aItem, aRootElement)
+  _updateRemoteObject: function PTV__updateRemoteObject(aObject, aLevel)
   {
-    // If item.children is an array, then the children has already been
-    // computed and can get returned directly.
-    // Skip this checking if aRootElement is true. It could happen, that aItem
-    // is passed as ({children:[1,2,3]}) which would be true, although these
-    // "kind" of children has no value/type etc. data as needed to display in
-    // the tree. As the passed ({children:[1,2,3]}) are instanceof
-    // itsWindow.Array and not this modules's global Array
-    // aItem.children instanceof Array can't be true, but for saftey the
-    // !aRootElement is kept here.
-    if (!aRootElement && aItem && aItem.children instanceof Array) {
-      return aItem.children;
-    }
+    aObject.forEach(function(aElement) {
+      aElement.level = aLevel;
+      aElement.isOpened = false;
+      aElement.children = null;
+    });
+  },
 
-    let pairs;
-    let newPairLevel;
+  /**
+   * Inspect a local object.
+   *
+   * @private
+   * @param object aObject
+   *        The object you want to inspect.
+   */
+  _inspectObject: function PTV__inspectObject(aObject)
+  {
+    this._objectCache = {};
+    this._remoteObjectProvider = this._localObjectProvider.bind(this);
+    let children = WebConsoleUtils.namesAndValuesOf(aObject, this._objectCache);
+    this._updateRemoteObject(children, 0);
+    return children;
+  },
 
-    if (!aRootElement) {
-      newPairLevel = aItem.level + 1;
-      aItem = aItem.value;
-    }
-    else {
-      newPairLevel = 0;
-    }
-
-    pairs = namesAndValuesOf(aItem);
-
-    for each (var pair in pairs) {
-      pair.level = newPairLevel;
-      pair.isOpened = false;
-      pair.children = pair.type == TYPE_OBJECT || pair.type == TYPE_FUNCTION ||
-                      pair.type == TYPE_ARRAY;
-    }
-
-    return pairs;
+  /**
+   * An object provider for when the user inspects local objects (not remote
+   * ones).
+   *
+   * @private
+   * @param string aFromCacheId
+   *        The cache ID from where to retrieve the desired object.
+   * @param string aObjectId
+   *        The ID of the object you want.
+   * @param string aDestCacheId
+   *        The ID of the cache where to store any objects referenced by the
+   *        desired object.
+   * @param function aCallback
+   *        The function you want to receive the object.
+   */
+  _localObjectProvider:
+  function PTV__localObjectProvider(aFromCacheId, aObjectId, aDestCacheId,
+                                    aCallback)
+  {
+    let object = WebConsoleUtils.namesAndValuesOf(this._objectCache[aObjectId],
+                                                  this._objectCache);
+    aCallback({cacheId: aFromCacheId,
+               objectId: aObjectId,
+               object: object,
+               childrenCacheId: aDestCacheId || aFromCacheId,
+    });
   },
 
   /** nsITreeView interface implementation **/
 
   selection: null,
 
   get rowCount()                     { return this._rows.length; },
   setTree: function(treeBox)         { this._treeBox = treeBox;  },
-  getCellText: function(idx, column) { return this._rows[idx].display; },
-  getLevel: function(idx)            { return this._rows[idx].level; },
-  isContainer: function(idx)         { return !!this._rows[idx].children; },
-  isContainerOpen: function(idx)     { return this._rows[idx].isOpened; },
+  getCellText: function(idx, column) {
+    let row = this._rows[idx];
+    return row.name + ": " + row.value;
+  },
+  getLevel: function(idx) {
+    return this._rows[idx].level;
+  },
+  isContainer: function(idx) {
+    return !!this._rows[idx].inspectable;
+  },
+  isContainerOpen: function(idx) {
+    return this._rows[idx].isOpened;
+  },
   isContainerEmpty: function(idx)    { return false; },
   isSeparator: function(idx)         { return false; },
   isSorted: function()               { return false; },
   isEditable: function(idx, column)  { return false; },
   isSelectable: function(row, col)   { return true; },
 
   getParentIndex: function(idx)
   {
     if (this.getLevel(idx) == 0) {
       return -1;
     }
-    for (var t = idx - 1; t >= 0 ; t--) {
+    for (var t = idx - 1; t >= 0; t--) {
       if (this.isContainer(t)) {
         return t;
       }
     }
     return -1;
   },
 
   hasNextSibling: function(idx, after)
   {
     var thisLevel = this.getLevel(idx);
     return this._rows.slice(after + 1).some(function (r) r.level == thisLevel);
   },
 
   toggleOpenState: function(idx)
   {
-    var item = this._rows[idx];
-    if (!item.children) {
+    let item = this._rows[idx];
+    if (!item.inspectable) {
       return;
     }
 
-    this._treeBox.beginUpdateBatch();
     if (item.isOpened) {
+      this._treeBox.beginUpdateBatch();
       item.isOpened = false;
 
       var thisLevel = item.level;
       var t = idx + 1, deleteCount = 0;
       while (t < this._rows.length && this.getLevel(t++) > thisLevel) {
         deleteCount++;
       }
 
       if (deleteCount) {
         this._rows.splice(idx + 1, deleteCount);
         this._treeBox.rowCountChanged(idx + 1, -deleteCount);
       }
+      this._treeBox.invalidateRow(idx);
+      this._treeBox.endUpdateBatch();
     }
     else {
-      item.isOpened = true;
+      let levelUpdate = true;
+      let callback = function _onRemoteResponse(aResponse) {
+        this._treeBox.beginUpdateBatch();
+        item.isOpened = true;
 
-      var toInsert = this.getChildItems(item);
-      item.children = toInsert;
-      this._rows.splice.apply(this._rows, [idx + 1, 0].concat(toInsert));
+        if (levelUpdate) {
+          this._updateRemoteObject(aResponse.object, item.level + 1);
+          item.children = aResponse.object;
+        }
 
-      this._treeBox.rowCountChanged(idx + 1, toInsert.length);
+        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item.children));
+
+        this._treeBox.rowCountChanged(idx + 1, item.children.length);
+        this._treeBox.invalidateRow(idx);
+        this._treeBox.endUpdateBatch();
+      }.bind(this);
+
+      if (!item.children) {
+        let fromCacheId = item.level > 0 ? this._panelCacheId :
+                                           this._rootCacheId;
+        this._remoteObjectProvider(fromCacheId, item.objectId,
+                                   this._panelCacheId, callback);
+      }
+      else {
+        levelUpdate = false;
+        callback({object: item.children});
+      }
     }
-    this._treeBox.invalidateRow(idx);
-    this._treeBox.endUpdateBatch();
   },
 
   getImageSrc: function(idx, column) { },
   getProgressMode : function(idx,column) { },
   getCellValue: function(idx, column) { },
   cycleHeader: function(col, elem) { },
   selectionChanged: function() { },
   cycleCell: function(idx, column) { },
@@ -453,17 +331,31 @@ PropertyTreeView.prototype = {
   performActionOnRow: function(action, row) { },
   getRowProperties: function(idx, column, prop) { },
   getCellProperties: function(idx, column, prop) { },
   getColumnProperties: function(column, element, prop) { },
 
   setCellValue: function(row, col, value)               { },
   setCellText: function(row, col, value)                { },
   drop: function(index, orientation, dataTransfer)      { },
-  canDrop: function(index, orientation, dataTransfer)   { return false; }
+  canDrop: function(index, orientation, dataTransfer)   { return false; },
+
+  _cleanup: function PTV__cleanup()
+  {
+    if (this._rows.length) {
+      // Reset the existing _rows children to the initial state.
+      this._updateRemoteObject(this._rows, 0);
+      this._rows = [];
+    }
+
+    delete this._objectCache;
+    delete this._rootCacheId;
+    delete this._panelCacheId;
+    delete this._remoteObjectProvider;
+  },
 };
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
@@ -506,74 +398,76 @@ function appendChild(aDocument, aParent,
 }
 
 ///////////////////////////////////////////////////////////////////////////
 //// PropertyPanel
 
 /**
  * Creates a new PropertyPanel.
  *
+ * @see PropertyTreeView
  * @param nsIDOMNode aParent
  *        Parent node to append the created panel to.
- * @param nsIDOMDocument aDocument
- *        Document to create the new nodes on.
  * @param string aTitle
  *        Title for the panel.
  * @param string aObject
- *        Object to display in the tree.
+ *        Object to display in the tree. For details about this object please
+ *        see the PropertyTreeView constructor in this file.
  * @param array of objects aButtons
  *        Array with buttons to display at the bottom of the panel.
  */
-function PropertyPanel(aParent, aDocument, aTitle, aObject, aButtons)
+function PropertyPanel(aParent, aTitle, aObject, aButtons)
 {
+  let document = aParent.ownerDocument;
+
   // Create the underlying panel
-  this.panel = createElement(aDocument, "panel", {
+  this.panel = createElement(document, "panel", {
     label: aTitle,
     titlebar: "normal",
     noautofocus: "true",
     noautohide: "true",
     close: "true",
   });
 
   // Create the tree.
-  let tree = this.tree = createElement(aDocument, "tree", {
+  let tree = this.tree = createElement(document, "tree", {
     flex: 1,
     hidecolumnpicker: "true"
   });
 
-  let treecols = aDocument.createElement("treecols");
-  appendChild(aDocument, treecols, "treecol", {
+  let treecols = document.createElement("treecols");
+  appendChild(document, treecols, "treecol", {
     primary: "true",
     flex: 1,
     hideheader: "true",
     ignoreincolumnpicker: "true"
   });
   tree.appendChild(treecols);
 
-  tree.appendChild(aDocument.createElement("treechildren"));
+  tree.appendChild(document.createElement("treechildren"));
   this.panel.appendChild(tree);
 
   // Create the footer.
-  let footer = createElement(aDocument, "hbox", { align: "end" });
-  appendChild(aDocument, footer, "spacer", { flex: 1 });
+  let footer = createElement(document, "hbox", { align: "end" });
+  appendChild(document, footer, "spacer", { flex: 1 });
 
   // The footer can have butttons.
   let self = this;
   if (aButtons) {
     aButtons.forEach(function(button) {
-      let buttonNode = appendChild(aDocument, footer, "button", {
+      let buttonNode = appendChild(document, footer, "button", {
         label: button.label,
         accesskey: button.accesskey || "",
         class: button.class || "",
       });
       buttonNode.addEventListener("command", button.oncommand, false);
     });
   }
 
-  appendChild(aDocument, footer, "resizer", { dir: "bottomend" });
+  appendChild(document, footer, "resizer", { dir: "bottomend" });
   this.panel.appendChild(footer);
 
   aParent.appendChild(this.panel);
 
   // Create the treeView object.
   this.treeView = new PropertyTreeView();
   this.treeView.data = aObject;
 
@@ -588,25 +482,20 @@ function PropertyPanel(aParent, aDocumen
   this.panel.addEventListener("popuphidden", function onPopupHide()
   {
     self.panel.removeEventListener("popuphidden", onPopupHide, false);
     self.destroy();
   }, false);
 }
 
 /**
- * Destroy the PropertyPanel. This closes the poped up panel and removes
- * it from the browser DOM.
- *
- * @returns void
+ * Destroy the PropertyPanel. This closes the panel and removes it from the
+ * browser DOM.
  */
 PropertyPanel.prototype.destroy = function PP_destroy()
 {
+  this.treeView.data = null;
   this.panel.parentNode.removeChild(this.panel);
   this.treeView = null;
   this.panel = null;
   this.tree = null;
+}
 
-  if (this.linkNode) {
-    this.linkNode._panelOpen = false;
-    this.linkNode = null;
-  }
-}
diff --git a/browser/devtools/webconsole/PropertyPanelAsync.jsm b/browser/devtools/webconsole/PropertyPanelAsync.jsm
deleted file mode 100644
--- a/browser/devtools/webconsole/PropertyPanelAsync.jsm
+++ /dev/null
@@ -1,501 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is DevTools Web Console Property Panel.
- *
- * The Initial Developer of the Original Code is
- * the Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2010
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Rob Campbell <rcampbell@mozilla.com>
- *   Julian Viereck <jviereck@mozilla.com>
- *   Mihai Sucan <mihai.sucan@gmail.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-"use strict";
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
-  let obj = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
-  return obj.WebConsoleUtils;
-});
-
-var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView"];
-
-
-///////////////////////////////////////////////////////////////////////////
-//// PropertyTreeView.
-
-/**
- * This is an implementation of the nsITreeView interface. For comments on the
- * interface properties, see the documentation:
- * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsITreeView
- */
-var PropertyTreeView = function() {
-  this._rows = [];
-  this._objectCache = {};
-};
-
-PropertyTreeView.prototype = {
-  /**
-   * Stores the visible rows of the tree.
-   * @private
-   */
-  _rows: null,
-
-  /**
-   * Stores the nsITreeBoxObject for this tree.
-   * @private
-   */
-  _treeBox: null,
-
-  /**
-   * Stores cached information about local objects being inspected.
-   * @private
-   */
-  _objectCache: null,
-
-  /**
-   * Use this setter to update the content of the tree.
-   *
-   * @param object aObject
-   *        An object that holds information about the object you want to
-   *        display in the property panel. Object properties:
-   *        - object:
-   *        This is the raw object you want to display. You can only provide
-   *        this object if you want the property panel to work in sync mode.
-   *        - remoteObject:
-   *        An array that holds information on the remote object being
-   *        inspected. Each element in this array describes each property in the
-   *        remote object. See WebConsoleUtils.namesAndValuesOf() for details.
-   *        - rootCacheId:
-   *        The cache ID where the objects referenced in remoteObject are found.
-   *        - panelCacheId:
-   *        The cache ID where any object retrieved by this property panel
-   *        instance should be stored into.
-   *        - remoteObjectProvider:
-   *        A function that is invoked when a new object is needed. This is
-   *        called when the user tries to expand an inspectable property. The
-   *        callback must take four arguments:
-   *          - fromCacheId:
-   *          Tells from where to retrieve the object the user picked (from
-   *          which cache ID).
-   *          - objectId:
-   *          The object ID the user wants.
-   *          - panelCacheId:
-   *          Tells in which cache ID to store the objects referenced by
-   *          objectId so they can be retrieved later.
-   *          - callback:
-   *          The callback function to be invoked when the remote object is
-   *          received. This function takes one argument: the raw message
-   *          received from the Web Console content script.
-   */
-  set data(aData) {
-    let oldLen = this._rows.length;
-
-    this._cleanup();
-
-    if (!aData) {
-      return;
-    }
-
-    if (aData.remoteObject) {
-      this._rootCacheId = aData.rootCacheId;
-      this._panelCacheId = aData.panelCacheId;
-      this._remoteObjectProvider = aData.remoteObjectProvider;
-      this._rows = [].concat(aData.remoteObject);
-      this._updateRemoteObject(this._rows, 0);
-    }
-    else if (aData.object) {
-      this._rows = this._inspectObject(aData.object);
-    }
-    else {
-      throw new Error("First argument must have a .remoteObject or " +
-                      "an .object property!");
-    }
-
-    if (this._treeBox) {
-      this._treeBox.beginUpdateBatch();
-      if (oldLen) {
-        this._treeBox.rowCountChanged(0, -oldLen);
-      }
-      this._treeBox.rowCountChanged(0, this._rows.length);
-      this._treeBox.endUpdateBatch();
-    }
-  },
-
-  /**
-   * Update a remote object so it can be used with the tree view. This method
-   * adds properties to each array element.
-   *
-   * @private
-   * @param array aObject
-   *        The remote object you want prepared for use with the tree view.
-   * @param number aLevel
-   *        The level you want to give to each property in the remote object.
-   */
-  _updateRemoteObject: function PTV__updateRemoteObject(aObject, aLevel)
-  {
-    aObject.forEach(function(aElement) {
-      aElement.level = aLevel;
-      aElement.isOpened = false;
-      aElement.children = null;
-    });
-  },
-
-  /**
-   * Inspect a local object.
-   *
-   * @private
-   * @param object aObject
-   *        The object you want to inspect.
-   */
-  _inspectObject: function PTV__inspectObject(aObject)
-  {
-    this._objectCache = {};
-    this._remoteObjectProvider = this._localObjectProvider.bind(this);
-    let children = WebConsoleUtils.namesAndValuesOf(aObject, this._objectCache);
-    this._updateRemoteObject(children, 0);
-    return children;
-  },
-
-  /**
-   * An object provider for when the user inspects local objects (not remote
-   * ones).
-   *
-   * @private
-   * @param string aFromCacheId
-   *        The cache ID from where to retrieve the desired object.
-   * @param string aObjectId
-   *        The ID of the object you want.
-   * @param string aDestCacheId
-   *        The ID of the cache where to store any objects referenced by the
-   *        desired object.
-   * @param function aCallback
-   *        The function you want to receive the object.
-   */
-  _localObjectProvider:
-  function PTV__localObjectProvider(aFromCacheId, aObjectId, aDestCacheId,
-                                    aCallback)
-  {
-    let object = WebConsoleUtils.namesAndValuesOf(this._objectCache[aObjectId],
-                                                  this._objectCache);
-    aCallback({cacheId: aFromCacheId,
-               objectId: aObjectId,
-               object: object,
-               childrenCacheId: aDestCacheId || aFromCacheId,
-    });
-  },
-
-  /** nsITreeView interface implementation **/
-
-  selection: null,
-
-  get rowCount()                     { return this._rows.length; },
-  setTree: function(treeBox)         { this._treeBox = treeBox;  },
-  getCellText: function(idx, column) {
-    let row = this._rows[idx];
-    return row.name + ": " + row.value;
-  },
-  getLevel: function(idx) {
-    return this._rows[idx].level;
-  },
-  isContainer: function(idx) {
-    return !!this._rows[idx].inspectable;
-  },
-  isContainerOpen: function(idx) {
-    return this._rows[idx].isOpened;
-  },
-  isContainerEmpty: function(idx)    { return false; },
-  isSeparator: function(idx)         { return false; },
-  isSorted: function()               { return false; },
-  isEditable: function(idx, column)  { return false; },
-  isSelectable: function(row, col)   { return true; },
-
-  getParentIndex: function(idx)
-  {
-    if (this.getLevel(idx) == 0) {
-      return -1;
-    }
-    for (var t = idx - 1; t >= 0; t--) {
-      if (this.isContainer(t)) {
-        return t;
-      }
-    }
-    return -1;
-  },
-
-  hasNextSibling: function(idx, after)
-  {
-    var thisLevel = this.getLevel(idx);
-    return this._rows.slice(after + 1).some(function (r) r.level == thisLevel);
-  },
-
-  toggleOpenState: function(idx)
-  {
-    let item = this._rows[idx];
-    if (!item.inspectable) {
-      return;
-    }
-
-    if (item.isOpened) {
-      this._treeBox.beginUpdateBatch();
-      item.isOpened = false;
-
-      var thisLevel = item.level;
-      var t = idx + 1, deleteCount = 0;
-      while (t < this._rows.length && this.getLevel(t++) > thisLevel) {
-        deleteCount++;
-      }
-
-      if (deleteCount) {
-        this._rows.splice(idx + 1, deleteCount);
-        this._treeBox.rowCountChanged(idx + 1, -deleteCount);
-      }
-      this._treeBox.invalidateRow(idx);
-      this._treeBox.endUpdateBatch();
-    }
-    else {
-      let levelUpdate = true;
-      let callback = function _onRemoteResponse(aResponse) {
-        this._treeBox.beginUpdateBatch();
-        item.isOpened = true;
-
-        if (levelUpdate) {
-          this._updateRemoteObject(aResponse.object, item.level + 1);
-          item.children = aResponse.object;
-        }
-
-        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item.children));
-
-        this._treeBox.rowCountChanged(idx + 1, item.children.length);
-        this._treeBox.invalidateRow(idx);
-        this._treeBox.endUpdateBatch();
-      }.bind(this);
-
-      if (!item.children) {
-        let fromCacheId = item.level > 0 ? this._panelCacheId :
-                                           this._rootCacheId;
-        this._remoteObjectProvider(fromCacheId, item.objectId,
-                                   this._panelCacheId, callback);
-      }
-      else {
-        levelUpdate = false;
-        callback({object: item.children});
-      }
-    }
-  },
-
-  getImageSrc: function(idx, column) { },
-  getProgressMode : function(idx,column) { },
-  getCellValue: function(idx, column) { },
-  cycleHeader: function(col, elem) { },
-  selectionChanged: function() { },
-  cycleCell: function(idx, column) { },
-  performAction: function(action) { },
-  performActionOnCell: function(action, index, column) { },
-  performActionOnRow: function(action, row) { },
-  getRowProperties: function(idx, column, prop) { },
-  getCellProperties: function(idx, column, prop) { },
-  getColumnProperties: function(column, element, prop) { },
-
-  setCellValue: function(row, col, value)               { },
-  setCellText: function(row, col, value)                { },
-  drop: function(index, orientation, dataTransfer)      { },
-  canDrop: function(index, orientation, dataTransfer)   { return false; },
-
-  _cleanup: function PTV__cleanup()
-  {
-    if (this._rows.length) {
-      // Reset the existing _rows children to the initial state.
-      this._updateRemoteObject(this._rows, 0);
-      this._rows = [];
-    }
-
-    delete this._objectCache;
-    delete this._rootCacheId;
-    delete this._panelCacheId;
-    delete this._remoteObjectProvider;
-  },
-};
-
-///////////////////////////////////////////////////////////////////////////
-//// Helper for creating the panel.
-
-/**
- * Creates a DOMNode and sets all the attributes of aAttributes on the created
- * element.
- *
- * @param nsIDOMDocument aDocument
- *        Document to create the new DOMNode.
- * @param string aTag
- *        Name of the tag for the DOMNode.
- * @param object aAttributes
- *        Attributes set on the created DOMNode.
- * @returns nsIDOMNode
- */
-function createElement(aDocument, aTag, aAttributes)
-{
-  let node = aDocument.createElement(aTag);
-  for (var attr in aAttributes) {
-    node.setAttribute(attr, aAttributes[attr]);
-  }
-  return node;
-}
-
-/**
- * Creates a new DOMNode and appends it to aParent.
- *
- * @param nsIDOMDocument aDocument
- *        Document to create the new DOMNode.
- * @param nsIDOMNode aParent
- *        A parent node to append the created element.
- * @param string aTag
- *        Name of the tag for the DOMNode.
- * @param object aAttributes
- *        Attributes set on the created DOMNode.
- * @returns nsIDOMNode
- */
-function appendChild(aDocument, aParent, aTag, aAttributes)
-{
-  let node = createElement(aDocument, aTag, aAttributes);
-  aParent.appendChild(node);
-  return node;
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// PropertyPanel
-
-/**
- * Creates a new PropertyPanel.
- *
- * @see PropertyTreeView
- * @param nsIDOMNode aParent
- *        Parent node to append the created panel to.
- * @param string aTitle
- *        Title for the panel.
- * @param string aObject
- *        Object to display in the tree. For details about this object please
- *        see the PropertyTreeView.data property in this file.
- * @param array of objects aButtons
- *        Array with buttons to display at the bottom of the panel.
- */
-function PropertyPanel(aParent, aTitle, aObject, aButtons)
-{
-  let document = aParent.ownerDocument;
-
-  // Create the underlying panel
-  this.panel = createElement(document, "panel", {
-    label: aTitle,
-    titlebar: "normal",
-    noautofocus: "true",
-    noautohide: "true",
-    close: "true",
-  });
-
-  // Create the tree.
-  let tree = this.tree = createElement(document, "tree", {
-    flex: 1,
-    hidecolumnpicker: "true"
-  });
-
-  let treecols = document.createElement("treecols");
-  appendChild(document, treecols, "treecol", {
-    primary: "true",
-    flex: 1,
-    hideheader: "true",
-    ignoreincolumnpicker: "true"
-  });
-  tree.appendChild(treecols);
-
-  tree.appendChild(document.createElement("treechildren"));
-  this.panel.appendChild(tree);
-
-  // Create the footer.
-  let footer = createElement(document, "hbox", { align: "end" });
-  appendChild(document, footer, "spacer", { flex: 1 });
-
-  // The footer can have butttons.
-  let self = this;
-  if (aButtons) {
-    aButtons.forEach(function(button) {
-      let buttonNode = appendChild(document, footer, "button", {
-        label: button.label,
-        accesskey: button.accesskey || "",
-        class: button.class || "",
-      });
-      buttonNode.addEventListener("command", button.oncommand, false);
-    });
-  }
-
-  appendChild(document, footer, "resizer", { dir: "bottomend" });
-  this.panel.appendChild(footer);
-
-  aParent.appendChild(this.panel);
-
-  // Create the treeView object.
-  this.treeView = new PropertyTreeView();
-  this.treeView.data = aObject;
-
-  // Set the treeView object on the tree view. This has to be done *after* the
-  // panel is shown. This is because the tree binding must be attached first.
-  this.panel.addEventListener("popupshown", function onPopupShow()
-  {
-    self.panel.removeEventListener("popupshown", onPopupShow, false);
-    self.tree.view = self.treeView;
-  }, false);
-
-  this.panel.addEventListener("popuphidden", function onPopupHide()
-  {
-    self.panel.removeEventListener("popuphidden", onPopupHide, false);
-    self.destroy();
-  }, false);
-}
-
-/**
- * Destroy the PropertyPanel. This closes the panel and removes it from the
- * browser DOM.
- */
-PropertyPanel.prototype.destroy = function PP_destroy()
-{
-  this.treeView.data = null;
-  this.panel.parentNode.removeChild(this.panel);
-  this.treeView = null;
-  this.panel = null;
-  this.tree = null;
-}
-
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -39,24 +39,24 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 "use strict";
 
-let Cc = Components.classes;
-let Ci = Components.interfaces;
-let Cu = Components.utils;
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
-var EXPORTED_SYMBOLS = ["WebConsoleUtils"];
+var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider"];
 
 const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 
 const TYPES = { OBJECT: 0,
                 FUNCTION: 1,
                 ARRAY: 2,
                 OTHER: 3,
                 ITERATOR: 4,
@@ -436,33 +436,34 @@ var WebConsoleUtils = {
           display: presentable.substring(0, presentable.indexOf(')') + 1)
         };
 
       default:
         presentable = String(aObject);
         let m = /^\[object (\S+)\]/.exec(presentable);
 
         try {
-          if (type == "object" && typeof aObject.next == "function" &&
+          if (typeof aObject == "object" && typeof aObject.next == "function" &&
               m && m[1] == "Generator") {
             return {
               type: TYPES.GENERATOR,
               display: m[1]
             };
           }
         }
         catch (ex) {
           // window.history.next throws in the typeof check above.
           return {
             type: TYPES.OBJECT,
             display: m ? m[1] : "Object"
           };
         }
 
-        if (type == "object" && typeof aObject.__iterator__ == "function") {
+        if (typeof aObject == "object" &&
+            typeof aObject.__iterator__ == "function") {
           return {
             type: TYPES.ITERATOR,
             display: "Iterator"
           };
         }
 
         return {
           type: TYPES.OBJECT,
@@ -737,8 +738,234 @@ WebConsoleUtils.l10n = {
     }
     return result;
   },
 };
 
 XPCOMUtils.defineLazyGetter(WebConsoleUtils.l10n, "stringBundle", function() {
   return Services.strings.createBundle(STRINGS_URI);
 });
+
+
+//////////////////////////////////////////////////////////////////////////
+// JS Completer
+//////////////////////////////////////////////////////////////////////////
+
+var JSPropertyProvider = (function _JSPP(WCU) {
+const STATE_NORMAL = 0;
+const STATE_QUOTE = 2;
+const STATE_DQUOTE = 3;
+
+const OPEN_BODY = "{[(".split("");
+const CLOSE_BODY = "}])".split("");
+const OPEN_CLOSE_BODY = {
+  "{": "}",
+  "[": "]",
+  "(": ")",
+};
+
+/**
+ * Analyses a given string to find the last statement that is interesting for
+ * later completion.
+ *
+ * @param   string aStr
+ *          A string to analyse.
+ *
+ * @returns object
+ *          If there was an error in the string detected, then a object like
+ *
+ *            { err: "ErrorMesssage" }
+ *
+ *          is returned, otherwise a object like
+ *
+ *            {
+ *              state: STATE_NORMAL|STATE_QUOTE|STATE_DQUOTE,
+ *              startPos: index of where the last statement begins
+ *            }
+ */
+function findCompletionBeginning(aStr)
+{
+  let bodyStack = [];
+
+  let state = STATE_NORMAL;
+  let start = 0;
+  let c;
+  for (let i = 0; i < aStr.length; i++) {
+    c = aStr[i];
+
+    switch (state) {
+      // Normal JS state.
+      case STATE_NORMAL:
+        if (c == '"') {
+          state = STATE_DQUOTE;
+        }
+        else if (c == "'") {
+          state = STATE_QUOTE;
+        }
+        else if (c == ";") {
+          start = i + 1;
+        }
+        else if (c == " ") {
+          start = i + 1;
+        }
+        else if (OPEN_BODY.indexOf(c) != -1) {
+          bodyStack.push({
+            token: c,
+            start: start
+          });
+          start = i + 1;
+        }
+        else if (CLOSE_BODY.indexOf(c) != -1) {
+          var last = bodyStack.pop();
+          if (!last || OPEN_CLOSE_BODY[last.token] != c) {
+            return {
+              err: "syntax error"
+            };
+          }
+          if (c == "}") {
+            start = i + 1;
+          }
+          else {
+            start = last.start;
+          }
+        }
+        break;
+
+      // Double quote state > " <
+      case STATE_DQUOTE:
+        if (c == "\\") {
+          i++;
+        }
+        else if (c == "\n") {
+          return {
+            err: "unterminated string literal"
+          };
+        }
+        else if (c == '"') {
+          state = STATE_NORMAL;
+        }
+        break;
+
+      // Single quoate state > ' <
+      case STATE_QUOTE:
+        if (c == "\\") {
+          i++;
+        }
+        else if (c == "\n") {
+          return {
+            err: "unterminated string literal"
+          };
+          return;
+        }
+        else if (c == "'") {
+          state = STATE_NORMAL;
+        }
+        break;
+    }
+  }
+
+  return {
+    state: state,
+    startPos: start
+  };
+}
+
+/**
+ * Provides a list of properties, that are possible matches based on the passed
+ * scope and inputValue.
+ *
+ * @param object aScope
+ *        Scope to use for the completion.
+ *
+ * @param string aInputValue
+ *        Value that should be completed.
+ *
+ * @returns null or object
+ *          If no completion valued could be computed, null is returned,
+ *          otherwise a object with the following form is returned:
+ *            {
+ *              matches: [ string, string, string ],
+ *              matchProp: Last part of the inputValue that was used to find
+ *                         the matches-strings.
+ *            }
+ */
+function JSPropertyProvider(aScope, aInputValue)
+{
+  let obj = WCU.unwrap(aScope);
+
+  // Analyse the aInputValue and find the beginning of the last part that
+  // should be completed.
+  let beginning = findCompletionBeginning(aInputValue);
+
+  // There was an error analysing the string.
+  if (beginning.err) {
+    return null;
+  }
+
+  // If the current state is not STATE_NORMAL, then we are inside of an string
+  // which means that no completion is possible.
+  if (beginning.state != STATE_NORMAL) {
+    return null;
+  }
+
+  let completionPart = aInputValue.substring(beginning.startPos);
+
+  // Don't complete on just an empty string.
+  if (completionPart.trim() == "") {
+    return null;
+  }
+
+  let properties = completionPart.split(".");
+  let matchProp;
+  if (properties.length > 1) {
+    matchProp = properties.pop().trimLeft();
+    for (let i = 0; i < properties.length; i++) {
+      let prop = properties[i].trim();
+
+      // If obj is undefined or null, then there is no chance to run completion
+      // on it. Exit here.
+      if (typeof obj === "undefined" || obj === null) {
+        return null;
+      }
+
+      // Check if prop is a getter function on obj. Functions can change other
+      // stuff so we can't execute them to get the next object. Stop here.
+      if (WCU.isNonNativeGetter(obj, prop)) {
+        return null;
+      }
+      try {
+        obj = obj[prop];
+      }
+      catch (ex) {
+        return null;
+      }
+    }
+  }
+  else {
+    matchProp = properties[0].trimLeft();
+  }
+
+  // If obj is undefined or null, then there is no chance to run
+  // completion on it. Exit here.
+  if (typeof obj === "undefined" || obj === null) {
+    return null;
+  }
+
+  // Skip Iterators and Generators.
+  if (WCU.isIteratorOrGenerator(obj)) {
+    return null;
+  }
+
+  let matches = [];
+  for (let prop in obj) {
+    if (prop.indexOf(matchProp) == 0) {
+      matches.push(prop);
+    }
+  }
+
+  return {
+    matchProp: matchProp,
+    matches: matches.sort(),
+  };
+}
+
+return JSPropertyProvider;
+})(WebConsoleUtils);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -36,40 +36,40 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup keyboard usage test";
 let HUD;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
+function consoleOpened(aHud) {
+  HUD = aHud;
 
   content.wrappedJSObject.foobarBug585991 = {
     "item0": "value0",
     "item1": "value1",
     "item2": "value2",
     "item3": "value3",
   };
 
-  let hudId = HUDService.getHudIdByWindow(content);
-  HUD = HUDService.hudReferences[hudId];
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
   ok(!popup.isOpen, "popup is not open");
 
-  popup._panel.addEventListener("popupshown", function() {
-    popup._panel.removeEventListener("popupshown", arguments.callee, false);
+  popup._panel.addEventListener("popupshown", function onShown() {
+    popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 4, "popup.itemCount is correct");
 
     let sameItems = popup.getItems();
     is(sameItems.every(function(aItem, aIndex) {
       return aItem.label == "item" + aIndex;
@@ -107,43 +107,43 @@ function tabLoaded() {
 
 function autocompletePopupHidden()
 {
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
   let inputNode = jsterm.inputNode;
 
-  popup._panel.removeEventListener("popuphidden", arguments.callee, false);
+  popup._panel.removeEventListener("popuphidden", autocompletePopupHidden, false);
 
   ok(!popup.isOpen, "popup is not open");
 
   is(inputNode.value, "window.foobarBug585991.item0",
      "completion was successful after VK_TAB");
 
   ok(!completeNode.value, "completeNode is empty");
 
-  popup._panel.addEventListener("popupshown", function() {
-    popup._panel.removeEventListener("popupshown", arguments.callee, false);
+  popup._panel.addEventListener("popupshown", function onShown() {
+    popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 4, "popup.itemCount is correct");
 
     is(popup.selectedIndex, -1, "no index is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
     
     let prefix = jsterm.inputNode.value.replace(/[\S]/g, " ");
 
     is(popup.selectedIndex, 0, "index 0 is selected");
     is(popup.selectedItem.label, "item0", "item0 is selected");
     is(completeNode.value, prefix + "item0", "completeNode.value holds item0");
 
-    popup._panel.addEventListener("popuphidden", function() {
-      popup._panel.removeEventListener("popuphidden", arguments.callee, false);
+    popup._panel.addEventListener("popuphidden", function onHidden() {
+      popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_ESCAPE");
 
       is(inputNode.value, "window.foobarBug585991.",
          "completion was cancelled");
 
       ok(!completeNode.value, "completeNode is empty");
 
@@ -163,18 +163,18 @@ function autocompletePopupHidden()
 
 function testReturnKey()
 {
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
   let inputNode = jsterm.inputNode;
 
-  popup._panel.addEventListener("popupshown", function() {
-    popup._panel.removeEventListener("popupshown", arguments.callee, false);
+  popup._panel.addEventListener("popupshown", function onShown() {
+    popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 4, "popup.itemCount is correct");
     
     is(popup.selectedIndex, -1, "no index is selected");
     EventUtils.synthesizeKey("VK_DOWN", {});
 
@@ -185,18 +185,18 @@ function testReturnKey()
     is(completeNode.value, prefix + "item0", "completeNode.value holds item0");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
 
     is(popup.selectedIndex, 1, "index 1 is selected");
     is(popup.selectedItem.label, "item1", "item1 is selected");
     is(completeNode.value, prefix + "item1", "completeNode.value holds item1");
 
-    popup._panel.addEventListener("popuphidden", function() {
-      popup._panel.removeEventListener("popuphidden", arguments.callee, false);
+    popup._panel.addEventListener("popuphidden", function onHidden() {
+      popup._panel.removeEventListener("popuphidden", onHidden, false);
 
       ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
       is(inputNode.value, "window.foobarBug585991.item1",
          "completion was successful after VK_RETURN");
 
       ok(!completeNode.value, "completeNode is empty");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
@@ -8,67 +8,62 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 let HUD;
 
 let outputItem;
 
-function tabLoad1(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  openConsole();
-
-  HUD = HUDService.getHudByWindow(content);
+function consoleOpened(aHud) {
+  HUD = aHud;
 
   outputNode = HUD.outputNode;
 
   browser.addEventListener("load", tabLoad2, true);
 
   // Reload so we get some output in the console.
   browser.contentWindow.location.reload();
-  log(document);
 }
 
 function tabLoad2(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tabLoad2, true);
 
   outputItem = outputNode.querySelector(".hud-networkinfo .hud-clickable");
   ok(outputItem, "found a network message");
   document.addEventListener("popupshown", networkPanelShown, false);
 
   // Send the mousedown and click events such that the network panel opens.
   EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
   EventUtils.sendMouseEvent({type: "click"}, outputItem);
 }
 
 function networkPanelShown(aEvent) {
-  document.removeEventListener(aEvent.type, arguments.callee, false);
+  document.removeEventListener(aEvent.type, networkPanelShown, false);
 
   document.addEventListener("popupshown", networkPanelShowFailure, false);
 
   // The network panel should not open for the second time.
   EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
   EventUtils.sendMouseEvent({type: "click"}, outputItem);
 
   executeSoon(function() {
     aEvent.target.addEventListener("popuphidden", networkPanelHidden, false);
     aEvent.target.hidePopup();
   });
 }
 
 function networkPanelShowFailure(aEvent) {
-  document.removeEventListener(aEvent.type, arguments.callee, false);
+  document.removeEventListener(aEvent.type, networkPanelShowFailure, false);
 
   ok(false, "the network panel should not show");
 }
 
 function networkPanelHidden(aEvent) {
-  this.removeEventListener(aEvent.type, arguments.callee, false);
+  this.removeEventListener(aEvent.type, networkPanelHidden, false);
 
   // The network panel should not show because this is a mouse event that starts
   // in a position and ends in another.
   EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
     outputItem);
   EventUtils.sendMouseEvent({type: "click", clientX: 5, clientY: 6},
     outputItem);
 
@@ -87,51 +82,58 @@ function networkPanelHidden(aEvent) {
   executeSoon(function() {
     document.removeEventListener("popupshown", networkPanelShowFailure, false);
 
     // Done with the network output. Now test the jsterm output and the property
     // panel.
     HUD.jsterm.setInputValue("document");
     HUD.jsterm.execute();
 
-    outputItem = outputNode.querySelector(".webconsole-msg-output " +
-                                          ".hud-clickable");
-    ok(outputItem, "found a jsterm output message");
+    waitForSuccess({
+      name: "jsterm output message",
+      validatorFn: function()
+      {
+        return outputNode.querySelector(".webconsole-msg-output .hud-clickable");
+      },
+      successFn: function()
+      {
+        document.addEventListener("popupshown", propertyPanelShown, false);
 
-    document.addEventListener("popupshown", properyPanelShown, false);
-
-    // Send the mousedown and click events such that the property panel opens.
-    EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
-    EventUtils.sendMouseEvent({type: "click"}, outputItem);
+        // Send the mousedown and click events such that the property panel opens.
+        EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
+        EventUtils.sendMouseEvent({type: "click"}, outputItem);
+      },
+      failureFn: finishTest,
+    });
   });
 }
 
-function properyPanelShown(aEvent) {
-  document.removeEventListener(aEvent.type, arguments.callee, false);
+function propertyPanelShown(aEvent) {
+  document.removeEventListener(aEvent.type, propertyPanelShown, false);
 
   document.addEventListener("popupshown", propertyPanelShowFailure, false);
 
   // The property panel should not open for the second time.
   EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
   EventUtils.sendMouseEvent({type: "click"}, outputItem);
 
   executeSoon(function() {
     aEvent.target.addEventListener("popuphidden", propertyPanelHidden, false);
     aEvent.target.hidePopup();
   });
 }
 
 function propertyPanelShowFailure(aEvent) {
-  document.removeEventListener(aEvent.type, arguments.callee, false);
+  document.removeEventListener(aEvent.type, propertyPanelShowFailure, false);
 
   ok(false, "the property panel should not show");
 }
 
 function propertyPanelHidden(aEvent) {
-  this.removeEventListener(aEvent.type, arguments.callee, false);
+  this.removeEventListener(aEvent.type, propertyPanelHidden, false);
 
   // The property panel should not show because this is a mouse event that
   // starts in a position and ends in another.
   EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
     outputItem);
   EventUtils.sendMouseEvent({type: "click", clientX: 5, clientY: 6},
     outputItem);
 
@@ -144,18 +146,21 @@ function propertyPanelHidden(aEvent) {
   // The property panel should not show because this is a right-click.
   EventUtils.sendMouseEvent({type: "mousedown", button: 2},
     outputItem);
   EventUtils.sendMouseEvent({type: "click", button: 2},
     outputItem);
 
   executeSoon(function() {
     document.removeEventListener("popupshown", propertyPanelShowFailure, false);
-    outputItem = null;
-    finishTest();
+    HUD = outputItem = null;
+    executeSoon(finishTest);
   });
 }
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad1, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
@@ -164,25 +164,63 @@ function testGen() {
 
   HUD.jsterm.clearOutput();
 
   // Test jsterm print() output.
 
   HUD.jsterm.setInputValue("print(" + inputValue + ")");
   HUD.jsterm.execute();
 
+  waitForSuccess({
+    name: "jsterm print() output for test #" + cpos,
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output:last-child");
+    },
+    successFn: subtestNext,
+    failureFn: testNext,
+  });
+
+  yield;
+
   outputItem = HUD.outputNode.querySelector(".webconsole-msg-output:" +
                                             "last-child");
   ok(outputItem,
     "found the jsterm print() output line for inputValues[" + cpos + "]");
   ok(outputItem.textContent.indexOf(printOutput) > -1,
     "jsterm print() output is correct for inputValues[" + cpos + "]");
 
   // Test jsterm execution output.
 
+  HUD.jsterm.clearOutput();
+  HUD.jsterm.setInputValue(inputValue);
+  HUD.jsterm.execute();
+
+  waitForSuccess({
+    name: "jsterm output for test #" + cpos,
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output:last-child");
+    },
+    successFn: subtestNext,
+    failureFn: testNext,
+  });
+
+  yield;
+
+  outputItem = HUD.outputNode.querySelector(".webconsole-msg-output:" +
+                                            "last-child");
+  ok(outputItem, "found the jsterm output line for inputValues[" + cpos + "]");
+  ok(outputItem.textContent.indexOf(expectedOutput) > -1,
+    "jsterm output is correct for inputValues[" + cpos + "]");
+
+  let messageBody = outputItem.querySelector(".webconsole-msg-body");
+  ok(messageBody, "we have the message body for inputValues[" + cpos + "]");
+
+  // Test click on output.
   let eventHandlerID = eventHandlers.length + 1;
 
   let propertyPanelShown = function(aEvent) {
     let label = aEvent.target.getAttribute("label");
     if (!label || label.indexOf(inputValue) == -1) {
       return;
     }
 
@@ -200,29 +238,16 @@ function testGen() {
       subtestNext();
     }
   };
 
   document.addEventListener("popupshown", propertyPanelShown, false);
 
   eventHandlers.push(propertyPanelShown);
 
-  HUD.jsterm.clearOutput();
-  HUD.jsterm.setInputValue(inputValue);
-  HUD.jsterm.execute();
-
-  outputItem = HUD.outputNode.querySelector(".webconsole-msg-output:" +
-                                            "last-child");
-  ok(outputItem, "found the jsterm output line for inputValues[" + cpos + "]");
-  ok(outputItem.textContent.indexOf(expectedOutput) > -1,
-    "jsterm output is correct for inputValues[" + cpos + "]");
-
-  let messageBody = outputItem.querySelector(".webconsole-msg-body");
-  ok(messageBody, "we have the message body for inputValues[" + cpos + "]");
-
   // Send the mousedown, mouseup and click events to check if the property
   // panel opens.
   EventUtils.sendMouseEvent({ type: "mousedown" }, messageBody, window);
   EventUtils.sendMouseEvent({ type: "click" }, messageBody, window);
 
   if (showsPropertyPanel) {
     yield; // wait for the panel to open if we need to.
   }
@@ -246,17 +271,17 @@ function testEnd() {
   }
 
   for (let i = 0; i < inputValues.length; i++) {
     if (inputValues[i][0] && !popupShown[i]) {
       ok(false, "the property panel failed to show for inputValues[" + i + "]");
     }
   }
 
-  testDriver = null;
+  HUD = inputValues = testDriver = null;
   executeSoon(finishTest);
 }
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoad, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
@@ -35,22 +35,23 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", function() {
-    browser.removeEventListener("load", arguments.callee, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
-    openConsole();
-    content.location.reload();
-    browser.addEventListener("load", tabLoaded, true);
+    openConsole(null, function() {
+      content.location.reload();
+      browser.addEventListener("load", tabLoaded, true);
+    });
   }, true);
 }
 
 function tabLoaded() {
   browser.removeEventListener("load", tabLoaded, true);
 
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
@@ -58,19 +59,16 @@ function tabLoaded() {
   HUD.jsterm.execute("document");
 
   let networkMessage = HUD.outputNode.querySelector(".webconsole-msg-network");
   ok(networkMessage, "found network message");
 
   let networkLink = networkMessage.querySelector(".webconsole-msg-link");
   ok(networkLink, "found network message link");
 
-  let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
-  ok(jstermMessage, "found output message");
-
   let popupset = document.getElementById("mainPopupSet");
   ok(popupset, "found #mainPopupSet");
 
   let popupsShown = 0;
   let hiddenPopups = 0;
 
   let onpopupshown = function() {
     popupsShown++;
@@ -113,11 +111,23 @@ function tabLoaded() {
 
   registerCleanupFunction(function() {
     is(popupsShown, 2, "correct number of popups shown");
     if (popupsShown != 2) {
       document.removeEventListener("popupshown", onpopupshown, false);
     }
   });
 
-  EventUtils.synthesizeMouse(networkLink, 2, 2, {});
-  EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
+  waitForSuccess({
+    name: "jsterm output message",
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
+      EventUtils.synthesizeMouse(networkLink, 2, 2, {});
+      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
+    },
+    failureFn: finishTest,
+  });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
@@ -74,19 +74,16 @@ function tabLoaded() {
   HUD.jsterm.execute("document");
 
   let networkMessage = HUD.outputNode.querySelector(".webconsole-msg-network");
   ok(networkMessage, "found network message");
 
   let networkLink = networkMessage.querySelector(".webconsole-msg-link");
   ok(networkLink, "found network message link");
 
-  let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
-  ok(jstermMessage, "found output message");
-
   let popupset = document.getElementById("mainPopupSet");
   ok(popupset, "found #mainPopupSet");
 
   let popupsShown = 0;
   let hiddenPopups = 0;
 
   let onpopupshown = function() {
     popupsShown++;
@@ -140,18 +137,30 @@ function tabLoaded() {
   registerCleanupFunction(function() {
     is(popupsShown, 2, "correct number of popups shown");
     if (popupsShown != 2) {
       document.removeEventListener("popupshown", onpopupshown, false);
     }
   });
 
   // Show the network and object inspector panels.
-  EventUtils.synthesizeMouse(networkLink, 2, 2, {});
-  EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
+  waitForSuccess({
+    name: "jsterm output message",
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let jstermMessage = HUD.outputNode.querySelector(".webconsole-msg-output");
+      EventUtils.synthesizeMouse(networkLink, 2, 2, {});
+      EventUtils.synthesizeMouse(jstermMessage, 2, 2, {});
+    },
+    failureFn: finishTest,
+  });
 }
 
 function togglePBAndThen(callback) {
   function pbObserver(aSubject, aTopic, aData) {
     if (aTopic != "private-browsing-transition-complete") {
       return;
     }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
@@ -4,40 +4,65 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai Sucan <mihai.sucan@gmail.com>
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-621644-jsterm-dollar.html";
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad, true);
+function test$(HUD) {
+  HUD.jsterm.clearOutput();
 
-  openConsole(null, function(HUD) {
-    HUD.jsterm.clearOutput();
+  HUD.jsterm.setInputValue("$(document.body)");
+  HUD.jsterm.execute();
 
-    HUD.jsterm.setInputValue("$(document.body)");
-    HUD.jsterm.execute();
+  waitForSuccess({
+    name: "jsterm output for $()",
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output:last-child");
+    },
+    successFn: function()
+    {
+      let outputItem = HUD.outputNode.
+                       querySelector(".webconsole-msg-output:last-child");
+      ok(outputItem.textContent.indexOf("<p>") > -1,
+         "jsterm output is correct for $()");
 
-    let outputItem = HUD.outputNode.
-                     querySelector(".webconsole-msg-output:last-child");
-    ok(outputItem.textContent.indexOf("<p>") > -1,
-       "jsterm output is correct for $()");
+      test$$(HUD);
+    },
+    failureFn: test$$.bind(null, HUD),
+  });
+}
 
-    HUD.jsterm.clearOutput();
+function test$$(HUD) {
+  HUD.jsterm.clearOutput();
 
-    HUD.jsterm.setInputValue("$$(document)");
-    HUD.jsterm.execute();
+  HUD.jsterm.setInputValue("$$(document)");
+  HUD.jsterm.execute();
 
-    outputItem = HUD.outputNode.
-                     querySelector(".webconsole-msg-output:last-child");
-    ok(outputItem.textContent.indexOf("621644") > -1,
-       "jsterm output is correct for $$()");
+  waitForSuccess({
+    name: "jsterm output for $$()",
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output:last-child");
+    },
+    successFn: function()
+    {
+      let outputItem = HUD.outputNode.
+                       querySelector(".webconsole-msg-output:last-child");
+      ok(outputItem.textContent.indexOf("621644") > -1,
+         "jsterm output is correct for $$()");
 
-    executeSoon(finishTest);
+      executeSoon(finishTest);
+    },
+    failureFn: finishTest,
   });
 }
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, test$);
+  }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632275_getters_document_width.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632275_getters_document_width.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632275_getters_document_width.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632275_getters_document_width.js
@@ -1,45 +1,46 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-632275-getters.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
+function consoleOpened(HUD) {
   let jsterm = HUD.jsterm;
 
   let doc = content.wrappedJSObject.document;
 
-  let panel = jsterm.openPropertyPanel("Test1", doc);
+  let panel = jsterm.openPropertyPanel({ data: { object: doc }});
 
-  let rows = panel.treeView._rows;
+  let view = panel.treeView;
   let find = function(regex) {
-    return rows.some(function(row) {
-      return regex.test(row.display);
-    });
+    for (let i = 0; i < view.rowCount; i++) {
+      if (regex.test(view.getCellText(i))) {
+        return true;
+      }
+    }
+    return false;
   };
 
   ok(!find(/^(width|height):/), "no document.width/height");
 
   panel.destroy();
 
   let getterValue = doc.foobar._val;
 
-  panel = jsterm.openPropertyPanel("Test2", doc.foobar);
-  rows = panel.treeView._rows;
+  panel = jsterm.openPropertyPanel({ data: { object: doc.foobar }});
+  view = panel.treeView;
 
   is(getterValue, doc.foobar._val, "getter did not execute");
   is(getterValue+1, doc.foobar.val, "getter executed");
   is(getterValue+1, doc.foobar._val, "getter executed (recheck)");
 
   ok(find(/^val: Getter$/),
      "getter is properly displayed");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_632347_iterators_generators.js
@@ -35,103 +35,123 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-632347-iterators-generators.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function tabLoaded() {
-  browser.removeEventListener("load", tabLoaded, true);
-
+function consoleOpened(HUD) {
   let tmp = {};
   Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
   let WCU = tmp.WebConsoleUtils;
+  let JSPropertyProvider = tmp.JSPropertyProvider;
+  tmp = null;
 
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
   let jsterm = HUD.jsterm;
-
   let win = content.wrappedJSObject;
 
   // Make sure autocomplete does not walk through iterators and generators.
   let result = win.gen1.next();
-  let completion = jsterm.propertyProvider(win, "gen1.");
+  let completion = JSPropertyProvider(win, "gen1.");
   is(completion, null, "no matchees for gen1");
   ok(!WCU.isObjectInspectable(win.gen1),
      "gen1 is not inspectable");
 
   is(result+1, win.gen1.next(), "gen1.next() did not execute");
 
   result = win.gen2.next();
 
-  completion = jsterm.propertyProvider(win, "gen2.");
+  completion = JSPropertyProvider(win, "gen2.");
   is(completion, null, "no matchees for gen2");
   ok(!WCU.isObjectInspectable(win.gen2),
      "gen2 is not inspectable");
 
   is((result/2+1)*2, win.gen2.next(),
      "gen2.next() did not execute");
 
   result = win.iter1.next();
   is(result[0], "foo", "iter1.next() [0] is correct");
   is(result[1], "bar", "iter1.next() [1] is correct");
 
-  completion = jsterm.propertyProvider(win, "iter1.");
+  completion = JSPropertyProvider(win, "iter1.");
   is(completion, null, "no matchees for iter1");
   ok(!WCU.isObjectInspectable(win.iter1),
      "iter1 is not inspectable");
 
   result = win.iter1.next();
   is(result[0], "baz", "iter1.next() [0] is correct");
   is(result[1], "baaz", "iter1.next() [1] is correct");
 
-  completion = jsterm.propertyProvider(content, "iter2.");
+  completion = JSPropertyProvider(content, "iter2.");
   is(completion, null, "no matchees for iter2");
   ok(!WCU.isObjectInspectable(win.iter2),
      "iter2 is not inspectable");
 
-  completion = jsterm.propertyProvider(win, "window.");
+  completion = JSPropertyProvider(win, "window.");
   ok(completion, "matches available for window");
   ok(completion.matches.length, "matches available for window (length)");
   ok(WCU.isObjectInspectable(win),
      "window is inspectable");
 
-  let panel = jsterm.openPropertyPanel("Test", win);
-  ok(panel, "opened the Property Panel");
-  let rows = panel.treeView._rows;
-  ok(rows.length, "Property Panel rows are available");
+  jsterm.clearOutput();
+
+  jsterm.setInputValue("window");
+  jsterm.execute();
+
+  waitForSuccess({
+    name: "jsterm window object output",
+    validatorFn: function()
+    {
+      return HUD.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      document.addEventListener("popupshown", function onShown(aEvent) {
+        document.removeEventListener("popupshown", onShown, false);
+        executeSoon(testPropertyPanel.bind(null, aEvent.target));
+      }, false);
+
+      let node = HUD.outputNode.querySelector(".webconsole-msg-output");
+      EventUtils.synthesizeMouse(node, 2, 2, {});
+    },
+    failureFn: finishTest,
+  });
+}
+
+function testPropertyPanel(aPanel) {
+  let tree = aPanel.querySelector("tree");
+  let view = tree.view;
+  let col = tree.columns[0];
+  ok(view.rowCount, "Property Panel rowCount");
 
   let find = function(display, children) {
-    return rows.some(function(row) {
-      return row.display == display &&
-             row.children == children;
-    });
+    for (let i = 0; i < view.rowCount; i++) {
+      if (view.isContainer(i) == children &&
+          view.getCellText(i, col) == display) {
+        return true;
+      }
+    }
+
+    return false;
   };
 
   ok(find("gen1: Generator", false),
      "gen1 is correctly displayed in the Property Panel");
 
   ok(find("gen2: Generator", false),
      "gen2 is correctly displayed in the Property Panel");
 
   ok(find("iter1: Iterator", false),
      "iter1 is correctly displayed in the Property Panel");
 
   ok(find("iter2: Iterator", false),
      "iter2 is correctly displayed in the Property Panel");
 
-  /*
-   * - disabled, see bug 632347, c#9
-   * ok(find("parent: Window", true),
-   *   "window.parent is correctly displayed in the Property Panel");
-   */
-
-  panel.destroy();
-
-  finishTest();
+  executeSoon(finishTest);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_642615_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_642615_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_642615_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_642615_autocomplete.js
@@ -3,80 +3,100 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>test for bug 642615";
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let HUD = HUDService.hudReferences[hudId];
+function consoleOpened(HUD) {
   let jsterm = HUD.jsterm;
   let stringToCopy = "foobazbarBug642615";
 
   jsterm.clearOutput();
 
   ok(!jsterm.completeNode.value, "no completeNode.value");
 
   jsterm.setInputValue("doc");
 
+  let completionValue;
+
   // wait for key "u"
-  jsterm.inputNode.addEventListener("keyup", function() {
-    jsterm.inputNode.removeEventListener("keyup", arguments.callee, false);
-
-    let completionValue = jsterm.completeNode.value;
-    ok(completionValue, "we have a completeNode.value");
-
-    // wait for paste
-    jsterm.inputNode.addEventListener("input", function() {
-      jsterm.inputNode.removeEventListener("input", arguments.callee, false);
-
-      ok(!jsterm.completeNode.value, "no completeNode.value after clipboard paste");
-
-      // wait for undo
-      jsterm.inputNode.addEventListener("input", function() {
-        jsterm.inputNode.removeEventListener("input", arguments.callee, false);
-
-        is(jsterm.completeNode.value, completionValue,
-           "same completeNode.value after undo");
-
-        // wait for paste (via keyboard event)
-        jsterm.inputNode.addEventListener("keyup", function() {
-          jsterm.inputNode.removeEventListener("keyup", arguments.callee, false);
-
-          ok(!jsterm.completeNode.value,
-             "no completeNode.value after clipboard paste (via keyboard event)");
-
-          executeSoon(finishTest);
-        }, false);
-
-        EventUtils.synthesizeKey("v", {accelKey: true});
-      }, false);
-
-      goDoCommand("cmd_undo");
-    }, false);
+  function onCompletionValue() {
+    completionValue = jsterm.completeNode.value;
 
     // Arguments: expected, setup, success, failure.
     waitForClipboard(
       stringToCopy,
       function() {
         clipboardHelper.copyString(stringToCopy);
       },
-      function() {
-        updateEditUIVisibility();
-        goDoCommand("cmd_paste");
+      onClipboardCopy,
+      finishTest);
+  }
+
+  function onClipboardCopy() {
+    updateEditUIVisibility();
+    goDoCommand("cmd_paste");
+
+    waitForSuccess(waitForPaste);
+  }
+
+  let waitForPaste = {
+    name: "no completion value after paste",
+    validatorFn: function()
+    {
+      return !jsterm.completeNode.value;
+    },
+    successFn: onClipboardPaste,
+    failureFn: finishTest,
+  };
+
+  function onClipboardPaste() {
+    goDoCommand("cmd_undo");
+    waitForSuccess({
+      name: "completion value for 'docu' after undo",
+      validatorFn: function()
+      {
+        return !!jsterm.completeNode.value;
       },
-      finish);
-  }, false);
+      successFn: onCompletionValueAfterUndo,
+      failureFn: finishTest,
+    });
+  }
+
+  function onCompletionValueAfterUndo() {
+    is(jsterm.completeNode.value, completionValue,
+       "same completeNode.value after undo");
+
+    EventUtils.synthesizeKey("v", {accelKey: true});
+    waitForSuccess({
+      name: "no completion after ctrl-v (paste)",
+      validatorFn: function()
+      {
+        return !jsterm.completeNode.value;
+      },
+      successFn: finishTest,
+      failureFn: finishTest,
+    });
+  }
 
   EventUtils.synthesizeKey("u", {});
+
+  waitForSuccess({
+    name: "completion value for 'docu'",
+    validatorFn: function()
+    {
+      return !!jsterm.completeNode.value;
+    },
+    successFn: onCompletionValue,
+    failureFn: finishTest,
+  });
 }
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
@@ -1,48 +1,46 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that document.body autocompletes in the web console.
 
-let tempScope = {};
-Cu.import("resource:///modules/PropertyPanel.jsm", tempScope);
-let PropertyPanel = tempScope.PropertyPanel;
-let PropertyTreeView = tempScope.PropertyTreeView;
-let namesAndValuesOf = tempScope.namesAndValuesOf;
-let isNonNativeGetter = tempScope.isNonNativeGetter;
-
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console autocompletion bug in document.body");
-  browser.addEventListener("load", onLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
 var gHUD;
 
-function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-  openConsole();
-  let hudId = HUDService.getHudIdByWindow(content);
-  gHUD = HUDService.hudReferences[hudId];
+function consoleOpened(aHud) {
+  gHUD = aHud;
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
+  let tmp = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
+  let WCU = tmp.WebConsoleUtils;
+  tmp = null;
+
   ok(!popup.isOpen, "popup is not open");
 
-  popup._panel.addEventListener("popupshown", function() {
-    popup._panel.removeEventListener("popupshown", arguments.callee, false);
+  popup._panel.addEventListener("popupshown", function onShown() {
+    popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
-    let props = namesAndValuesOf(content.wrappedJSObject.document.body).length;
-    is(popup.itemCount, props, "popup.itemCount is correct");
+    let props = WCU.namesAndValuesOf(content.wrappedJSObject.document.body);
+    is(popup.itemCount, props.length, "popup.itemCount is correct");
 
     popup._panel.addEventListener("popuphidden", autocompletePopupHidden, false);
 
     EventUtils.synthesizeKey("VK_ESCAPE", {});
   }, false);
 
   jsterm.setInputValue("document.body");
   EventUtils.synthesizeKey(".", {});
@@ -50,37 +48,81 @@ function onLoad(aEvent) {
 
 function autocompletePopupHidden()
 {
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
   let inputNode = jsterm.inputNode;
 
-  popup._panel.removeEventListener("popuphidden", arguments.callee, false);
+  popup._panel.removeEventListener("popuphidden", autocompletePopupHidden, false);
 
   ok(!popup.isOpen, "popup is not open");
   let inputStr = "document.b";
   jsterm.setInputValue(inputStr);
   EventUtils.synthesizeKey("o", {});
   let testStr = inputStr.replace(/./g, " ") + " ";
-  is(completeNode.value, testStr + "dy", "completeNode is empty");
-  jsterm.setInputValue("");
 
-  // Check the property panel as well. It's a bit gross to parse the properties
-  // out of the treeView cell text, but nsITreeView doesn't give us a good
-  // structured way to get at the data. :-(
-  let propPanel = jsterm.openPropertyPanel("Test", content.document);
+  waitForSuccess({
+    name: "autocomplete shows document.body",
+    validatorFn: function()
+    {
+      return completeNode.value == testStr + "dy";
+    },
+    successFn: testPropertyPanel,
+    failureFn: finishTest,
+  });
+}
+
+function testPropertyPanel()
+{
+  let jsterm = gHUD.jsterm;
+  jsterm.clearOutput();
+  jsterm.setInputValue("document");
+  jsterm.execute();
+
+  waitForSuccess({
+    name: "jsterm document object output",
+    validatorFn: function()
+    {
+      return gHUD.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      document.addEventListener("popupshown", function onShown(aEvent) {
+        document.removeEventListener("popupshown", onShown, false);
+        executeSoon(propertyPanelShown.bind(null, aEvent.target));
+      }, false);
+
+      let node = gHUD.outputNode.querySelector(".webconsole-msg-output");
+      EventUtils.synthesizeMouse(node, 2, 2, {});
+    },
+    failureFn: finishTest,
+  });
+}
+
+function propertyPanelShown(aPanel)
+{
+  let tree = aPanel.querySelector("tree");
+  let view = tree.view;
+  let col = tree.columns[0];
+  ok(view.rowCount, "Property Panel rowCount");
+
+  let foundBody = false;
   let propPanelProps = [];
-  for (let idx = 0; idx < propPanel.treeView.rowCount; ++idx)
-    propPanelProps.push(propPanel.treeView.getCellText(idx, null).split(':')[0]);
+  for (let idx = 0; idx < view.rowCount; ++idx) {
+    let text = view.getCellText(idx, col);
+    if (text == "body: HTMLBodyElement" || text == "body: Object")
+      foundBody = true;
+    propPanelProps.push(text.split(":")[0]);
+  }
+
   // NB: We pull the properties off the prototype, rather than off object itself,
   // so that expandos like |constructor|, which the propPanel can't see, are not
   // included.
   for (let prop in Object.getPrototypeOf(content.document))
     ok(propPanelProps.indexOf(prop) != -1, "Property |" + prop + "| should be reflected in propertyPanel");
 
-  let treeRows = propPanel.treeView._rows;
-  is (treeRows[30].display, "body: Object",  "found document.body");
-  propPanel.destroy();
+  ok(foundBody, "found document.body");
+
   executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
@@ -35,21 +35,19 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that the $0 console helper works as intended.
 
-let doc;
-let h1;
-
 function createDocument()
 {
+  let doc = content.document;
   let div = doc.createElement("div");
   let h1 = doc.createElement("h1");
   let p1 = doc.createElement("p");
   let p2 = doc.createElement("p");
   let div2 = doc.createElement("div");
   let p3 = doc.createElement("p");
   doc.title = "Inspector Tree Selection Test";
   h1.textContent = "Inspector Tree Selection Test";
@@ -74,74 +72,104 @@ function createDocument()
   div2.appendChild(p3);
   doc.body.appendChild(div);
   doc.body.appendChild(div2);
   setupHighlighterTests();
 }
 
 function setupHighlighterTests()
 {
-  h1 = doc.querySelectorAll("h1")[0];
+  let h1 = content.document.querySelector("h1");
   ok(h1, "we have the header node");
   Services.obs.addObserver(runSelectionTests,
     InspectorUI.INSPECTOR_NOTIFICATIONS.OPENED, false);
   InspectorUI.toggleInspectorUI();
 }
 
 function runSelectionTests()
 {
   Services.obs.removeObserver(runSelectionTests,
     InspectorUI.INSPECTOR_NOTIFICATIONS.OPENED, false);
 
   executeSoon(function() {
     InspectorUI.highlighter.addListener("nodeselected", performTestComparisons);
+    let h1 = content.document.querySelector("h1");
     EventUtils.synthesizeMouse(h1, 2, 2, {type: "mousemove"}, content);
   });
 }
 
 function performTestComparisons()
 {
   InspectorUI.highlighter.removeListener("nodeselected", performTestComparisons);
 
   InspectorUI.stopInspecting();
+
+  let h1 = content.document.querySelector("h1");
   is(InspectorUI.highlighter.node, h1, "node selected");
   is(InspectorUI.selection, h1, "selection matches node");
 
   openConsole(gBrowser.selectedTab, performWebConsoleTests);
 }
 
 function performWebConsoleTests(hud)
 {
   let jsterm = hud.jsterm;
   outputNode = hud.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("$0");
-  findLogEntry("[object HTMLHeadingElement");
 
-  jsterm.clearOutput();
-  let msg = "foo";
-  jsterm.execute("$0.textContent = '" + msg + "'");
-  findLogEntry(msg);
-  is(InspectorUI.selection.textContent, msg, "node successfully updated");
+  waitForSuccess({
+    name: "$0 output",
+    validatorFn: function()
+    {
+      return outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let node = outputNode.querySelector(".webconsole-msg-output");
+      isnot(node.textContent.indexOf("[object HTMLHeadingElement"), -1,
+            "correct output for $0");
 
-  doc = h1 = null;
-  executeSoon(finishUp);
+      jsterm.clearOutput();
+      jsterm.execute("$0.textContent = 'bug653531'");
+      waitForSuccess(waitForNodeUpdate);
+    },
+    failureFn: finishUp,
+  });
+
+  let waitForNodeUpdate = {
+    name: "$0.textContent update",
+    validatorFn: function()
+    {
+      return outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let node = outputNode.querySelector(".webconsole-msg-output");
+      isnot(node.textContent.indexOf("bug653531"), -1,
+            "correct output for $0.textContent");
+      is(InspectorUI.selection.textContent, "bug653531",
+         "node successfully updated");
+
+      executeSoon(finishUp);
+    },
+    failureFn: finishUp,
+  };
 }
 
 function finishUp() {
   InspectorUI.closeInspectorUI();
   finishTest();
 }
 
 function test()
 {
   waitForExplicitFinish();
   gBrowser.selectedTab = gBrowser.addTab();
   gBrowser.selectedBrowser.addEventListener("load", function() {
     gBrowser.selectedBrowser.removeEventListener("load", arguments.callee, true);
-    doc = content.document;
     waitForFocus(createDocument, content);
   }, true);
 
   content.location = "data:text/html;charset=utf-8,test for highlighter helper in web console";
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -36,16 +36,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that code completion works properly.
 
 function test() {
+  expectUncaughtException();
   addTab(getBrowserURL());
   browser.addEventListener("DOMContentLoaded", function onLoad() {
     browser.removeEventListener("DOMContentLoaded", onLoad, true);
     openConsole();
     testChrome(HUDService.getHudByWindow(content));
   }, true);
 }
 
@@ -58,15 +59,17 @@ function testChrome(hud) {
   ok(jsterm, "we have a jsterm");
 
   let input = jsterm.inputNode;
   ok(hud.outputNode, "we have an output node");
 
   // Test typing 'docu'.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
-  is(jsterm.completeNode.value, "    ment", "'docu' completion");
-
-  gBrowser.removeCurrentTab();
-  executeSoon(finishTest);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, function() {
+    is(jsterm.completeNode.value, "    ment", "'docu' completion");
+    executeSoon(function() {
+      gBrowser.removeCurrentTab();
+      executeSoon(finishTest);
+    });
+  });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_completion.js b/browser/devtools/webconsole/test/browser_webconsole_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_completion.js
@@ -35,74 +35,98 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that code completion works properly.
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
+const TEST_URI = "data:text/html;charset=utf8,<p>test code completion";
+
+let testDriver;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testCompletion, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, function(hud) {
+      testDriver = testCompletion(hud);
+      testDriver.next();
+    });
+  }, true);
 }
 
-function testCompletion() {
-  browser.removeEventListener("DOMContentLoaded", testCompletion, false);
+function testNext() {
+  executeSoon(function() {
+    testDriver.next();
+  });
+}
 
-  openConsole();
-
-  var jsterm = HUDService.getHudByWindow(content).jsterm;
-  var input = jsterm.inputNode;
+function testCompletion(hud) {
+  let jsterm = hud.jsterm;
+  let input = jsterm.inputNode;
 
   // Test typing 'docu'.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
-  is(input.value, "docu", "'docu' completion");
-  is(jsterm.completeNode.value, "    ment", "'docu' completion");
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield;
+
+  is(input.value, "docu", "'docu' completion (input.value)");
+  is(jsterm.completeNode.value, "    ment", "'docu' completion (completeNode)");
 
   // Test typing 'docu' and press tab.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_FORWARD);
+  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
+  yield;
+
   is(input.value, "document", "'docu' tab completion");
   is(input.selectionStart, 8, "start selection is alright");
   is(input.selectionEnd, 8, "end selection is alright");
   is(jsterm.completeNode.value.replace(/ /g, ""), "", "'docu' completed");
 
   // Test typing 'document.getElem'.
   input.value = "document.getElem";
   input.setSelectionRange(16, 16);
-  jsterm.complete(jsterm.COMPLETE_FORWARD);
+  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
+  yield;
+
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entById", "'document.getElem' completion");
 
   // Test pressing tab another time.
-  jsterm.complete(jsterm.COMPLETE_FORWARD);
+  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
+  yield;
+
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entsByClassName", "'document.getElem' another tab completion");
 
   // Test pressing shift_tab.
-  jsterm.complete(jsterm.COMPLETE_BACKWARD);
+  jsterm.complete(jsterm.COMPLETE_BACKWARD, testNext);
+  yield;
+
   is(input.value, "document.getElem", "'document.getElem' untab completion");
   is(jsterm.completeNode.value, "                entById", "'document.getElem' completion");
 
   jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
 
   input.value = "docu";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield;
+
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
   jsterm.execute();
   is(jsterm.completeNode.value, "", "clear completion on execute()");
 
   // Test multi-line completion works
   input.value =                 "console.log('one');\nconsol";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
+  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
+  yield;
+
   is(jsterm.completeNode.value, "                   \n      e", "multi-line completion");
 
-  jsterm = input = null;
-  finishTest();
+  testDriver = jsterm = input = null;
+  executeSoon(finishTest);
+  yield;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
--- a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
@@ -49,22 +49,32 @@ function test() {
     openConsole(null, testExecutionScope);
   }, true);
 }
 
 function testExecutionScope(hud) {
   let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
-  jsterm.execute("location;");
+  jsterm.execute("window.location;");
 
-  let nodes = jsterm.outputNode.querySelectorAll(".hud-msg-node");
-  is(nodes.length, 2, "Two children in output");
+  waitForSuccess({
+    name: "jsterm execution output (two nodes)",
+    validatorFn: function()
+    {
+      return jsterm.outputNode.querySelectorAll(".hud-msg-node").length == 2;
+    },
+    successFn: function()
+    {
+      let nodes = jsterm.outputNode.querySelectorAll(".hud-msg-node");
 
-  is(/location;/.test(nodes[0].textContent), true,
-     "'location;' written to output");
+      is(/window.location;/.test(nodes[0].textContent), true,
+        "'window.location;' written to output");
 
-  ok(nodes[0].textContent.indexOf(TEST_URI),
-    "command was executed in the window scope");
+      isnot(nodes[1].textContent.indexOf(TEST_URI), -1,
+        "command was executed in the window scope");
 
-  executeSoon(finishTest);
+      executeSoon(finishTest);
+    },
+    failureFn: finishTest,
+  });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_for_of.js b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
--- a/browser/devtools/webconsole/test/browser_webconsole_for_of.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
@@ -2,27 +2,34 @@
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // A for-of loop in Web Console code can loop over a content NodeList.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-for-of.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testForOf, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testForOf);
+  }, true);
 }
 
-function testForOf() {
-  browser.removeEventListener("DOMContentLoaded", testForOf, false);
-
-  openConsole();
-  var hud = HUDService.getHudByWindow(content);
+function testForOf(hud) {
   var jsterm = hud.jsterm;
   jsterm.execute("{ [x.tagName for (x of document.body.childNodes) if (x.nodeType === 1)].join(' '); }");
 
-  let node = hud.outputNode.querySelector(".webconsole-msg-output");
-  ok(/H1 DIV H2 P/.test(node.textContent),
-    "for-of loop should find all top-level nodes");
-
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-  finishTest();
+  waitForSuccess({
+    name: "jsterm output displayed",
+    validatorFn: function()
+    {
+      return hud.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let node = hud.outputNode.querySelector(".webconsole-msg-output");
+      ok(/H1 DIV H2 P/.test(node.textContent),
+        "for-of loop should find all top-level nodes");
+      finishTest();
+    },
+    failureFn: finishTest,
+  });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js b/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
--- a/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_js_input_and_output_styling.js
@@ -40,43 +40,43 @@
 
 // Tests that the correct CSS styles are applied to the lines of console
 // output.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testJSInputAndOutputStyling,
-                           false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testJSInputAndOutputStyling);
+  }, true);
 }
 
-function testJSInputAndOutputStyling() {
-  browser.removeEventListener("DOMContentLoaded",
-                              testJSInputAndOutputStyling, false);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testJSInputAndOutputStyling(hud) {
+  let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("2 + 2");
 
-  let nodes = jsterm.outputNode.querySelectorAll(".hud-msg-node");
-  let jsInputNode = nodes[0];
+  let jsInputNode = jsterm.outputNode.querySelector(".hud-msg-node");
   isnot(jsInputNode.textContent.indexOf("2 + 2"), -1,
         "JS input node contains '2 + 2'");
   ok(jsInputNode.classList.contains("webconsole-msg-input"),
      "JS input node is of the CSS class 'webconsole-msg-input'");
 
-  let jsOutputNodes = jsterm.outputNode.
-                      querySelectorAll(".webconsole-msg-output");
-  isnot(jsOutputNodes[0].textContent.indexOf("4"), -1,
-        "JS output node contains '4'");
-  ok(jsOutputNodes[0].classList.contains("webconsole-msg-output"),
-     "JS output node is of the CSS class 'webconsole-msg-output'");
-
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-
-  finishTest();
+  waitForSuccess({
+    name: "jsterm output is displayed",
+    validatorFn: function()
+    {
+      return jsterm.outputNode.querySelector(".webconsole-msg-output");
+    },
+    successFn: function()
+    {
+      let node = jsterm.outputNode.querySelector(".webconsole-msg-output");
+      isnot(node.textContent.indexOf("4"), -1,
+            "JS output node contains '4'");
+      finishTest();
+    },
+    failureFn: finishTest,
+  });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
--- a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
@@ -36,123 +36,203 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let jsterm;
+let jsterm, testDriver;
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testJSTerm);
+    openConsole(null, function(hud) {
+      testDriver = testJSTerm(hud);
+      testDriver.next();
+    });
   }, true);
 }
 
+function nextTest() {
+  testDriver.next();
+}
+
 function checkResult(msg, desc, lines) {
-  let labels = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
-  is(labels.length, lines, "correct number of results shown for " + desc);
-  is(labels[lines-1].textContent.trim(), msg, "correct message shown for " +
-    desc);
+  waitForSuccess({
+    name: "correct number of results shown for " + desc,
+    validatorFn: function()
+    {
+      let nodes = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
+      return nodes.length == lines;
+    },
+    successFn: function()
+    {
+      let labels = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
+      if (typeof msg == "string") {
+        is(labels[lines-1].textContent.trim(), msg,
+           "correct message shown for " + desc);
+      }
+      else if (typeof msg == "function") {
+        ok(msg(labels), "correct message shown for " + desc);
+      }
+
+      nextTest();
+    },
+    failureFn: nextTest,
+  });
 }
 
 function testJSTerm(hud)
 {
   jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("'id=' + $('header').getAttribute('id')");
   checkResult('"id=header"', "$() worked", 1);
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("headerQuery = $$('h1')");
   jsterm.execute("'length=' + headerQuery.length");
   checkResult('"length=1"', "$$() worked", 2);
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("xpathQuery = $x('.//*', document.body);");
   jsterm.execute("'headerFound='  + (xpathQuery[0] == headerQuery[0])");
   checkResult('"headerFound=true"', "$x() worked", 2);
+  yield;
 
   // no jsterm.clearOutput() here as we clear the output using the clear() fn.
   jsterm.execute("clear()");
-  let group = jsterm.outputNode.querySelector(".hud-group");
-  ok(!group, "clear() worked");
+
+  waitForSuccess({
+    name: "clear() worked",
+    validatorFn: function()
+    {
+      return jsterm.outputNode.childNodes.length == 0;
+    },
+    successFn: nextTest,
+    failureFn: nextTest,
+  });
+
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("'keysResult=' + (keys({b:1})[0] == 'b')");
   checkResult('"keysResult=true"', "keys() worked", 1);
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("'valuesResult=' + (values({b:1})[0] == 1)");
   checkResult('"valuesResult=true"', "values() worked", 1);
+  yield;
 
   jsterm.clearOutput();
+
+  let tabs = gBrowser.tabs.length;
+
   jsterm.execute("help()");
   let output = jsterm.outputNode.querySelector(".webconsole-msg-output");
-  ok(!group, "help() worked");
+  ok(!output, "help() worked");
 
   jsterm.execute("help");
   output = jsterm.outputNode.querySelector(".webconsole-msg-output");
   ok(!output, "help worked");
 
   jsterm.execute("?");
   output = jsterm.outputNode.querySelector(".webconsole-msg-output");
   ok(!output, "? worked");
 
+  let foundTab = null;
+  waitForSuccess({
+    name: "help tab opened",
+    timeout: 10000,
+    validatorFn: function()
+    {
+      let newTabOpen = gBrowser.tabs.length == tabs + 1;
+      if (!newTabOpen) {
+        return false;
+      }
+
+      foundTab = null;
+      Array.some(gBrowser.tabs, function(tab) {
+        let win = tab.linkedBrowser.contentWindow;
+        let match = win.location.href.indexOf("developer.mozilla.org") > -1;
+        if (match) {
+          foundTab = tab;
+        }
+        return match;
+      });
+
+      return foundTab;
+    },
+    successFn: function()
+    {
+      gBrowser.removeTab(foundTab);
+      nextTest();
+    },
+    failureFn: nextTest,
+  });
+  yield;
+
   jsterm.clearOutput();
   jsterm.execute("pprint({b:2, a:1})");
-  // Doesn't conform to checkResult format
-  let label = jsterm.outputNode.querySelector(".webconsole-msg-output");
-  is(label.textContent.trim(), "a: 1\n  b: 2", "pprint() worked");
+  checkResult("a: 1\n  b: 2", "pprint()", 1);
+  yield;
 
   // check instanceof correctness, bug 599940
   jsterm.clearOutput();
   jsterm.execute("[] instanceof Array");
   checkResult("true", "[] instanceof Array == true", 1);
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("({}) instanceof Object");
   checkResult("true", "({}) instanceof Object == true", 1);
+  yield;
 
   // check for occurrences of Object XRayWrapper, bug 604430
   jsterm.clearOutput();
   jsterm.execute("document");
-  let label = jsterm.outputNode.querySelector(".webconsole-msg-output");
-  is(label.textContent.trim().search(/\[object XrayWrapper/), -1,
-    "check for non-existence of [object XrayWrapper ");
+  checkResult(function(nodes) {
+    return nodes[0].textContent.search(/\[object xraywrapper/i) == -1;
+  }, "document - no XrayWrapper", 1);
+  yield;
 
   // check that pprint(window) and keys(window) don't throw, bug 608358
   jsterm.clearOutput();
   jsterm.execute("pprint(window)");
-  let labels = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
-  is(labels.length, 1, "one line of output for pprint(window)");
+  checkResult(null, "pprint(window)", 1);
+  yield;
 
   jsterm.clearOutput();
   jsterm.execute("keys(window)");
-  labels = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
-  is(labels.length, 1, "one line of output for keys(window)");
+  checkResult(null, "keys(window)", 1);
+  yield;
 
+  // bug 614561
   jsterm.clearOutput();
   jsterm.execute("pprint('hi')");
-  // Doesn't conform to checkResult format, bug 614561
-  let label = jsterm.outputNode.querySelector(".webconsole-msg-output");
-  is(label.textContent.trim(), '0: "h"\n  1: "i"', 'pprint("hi") worked');
+  checkResult('0: "h"\n  1: "i"', "pprint('hi')", 1);
+  yield;
 
   // check that pprint(function) shows function source, bug 618344
   jsterm.clearOutput();
   jsterm.execute("pprint(print)");
-  label = jsterm.outputNode.querySelector(".webconsole-msg-output");
-  isnot(label.textContent.indexOf("SEVERITY_LOG"), -1,
-        "pprint(function) shows function source");
+  checkResult(function(nodes) {
+    return nodes[0].textContent.indexOf("aJSTerm.") > -1;
+  }, "pprint(function) shows source", 1);
+  yield;
 
   // check that an evaluated null produces "null", bug 650780
   jsterm.clearOutput();
   jsterm.execute("null");
   checkResult("null", "null is null", 1);
+  yield;
 
-  jsterm = null;
+  jsterm = testDriver = null;
   executeSoon(finishTest);
+  yield;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js b/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
@@ -53,22 +53,45 @@ function test() {
 
 function testNullAndUndefinedOutput(hud) {
   let jsterm = hud.jsterm;
   let outputNode = jsterm.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("null;");
 
-  let nodes = outputNode.querySelectorAll(".hud-msg-node");
-  is(nodes.length, 2, "2 nodes in output");
-  ok(nodes[1].textContent.indexOf("null") > -1, "'null' printed to output");
+  waitForSuccess({
+    name: "null displayed",
+    validatorFn: function()
+    {
+      return outputNode.querySelectorAll(".hud-msg-node").length == 2;
+    },
+    successFn: function()
+    {
+      let nodes = outputNode.querySelectorAll(".hud-msg-node");
+      isnot(nodes[1].textContent.indexOf("null"), -1,
+            "'null' printed to output");
 
-  jsterm.clearOutput();
-  jsterm.execute("undefined;");
+      jsterm.clearOutput();
+      jsterm.execute("undefined;");
+      waitForSuccess(waitForUndefined);
+    },
+    failureFn: finishTest,
+  });
 
-  nodes = outputNode.querySelectorAll(".hud-msg-node");
-  is(nodes.length, 2, "2 nodes in output");
-  ok(nodes[1].textContent.indexOf("undefined") > -1, "'undefined' printed to output");
+  let waitForUndefined = {
+    name: "undefined displayed",
+    validatorFn: function()
+    {
+      return outputNode.querySelectorAll(".hud-msg-node").length == 2;
+    },
+    successFn: function()
+    {
+      let nodes = outputNode.querySelectorAll(".hud-msg-node");
+      isnot(nodes[1].textContent.indexOf("undefined"), -1,
+            "'undefined' printed to output");
 
-  executeSoon(finishTest);
+      finishTest();
+    },
+    failureFn: finishTest,
+  };
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_order.js b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
@@ -66,15 +66,14 @@ function testOutputOrder(hud) {
     },
     successFn: function()
     {
       let nodes = outputNode.querySelectorAll(".hud-msg-node");
       let executedStringFirst =
         /console\.log\('foo', 'bar'\);/.test(nodes[0].textContent);
       let outputSecond = /foo bar/.test(nodes[2].textContent);
       ok(executedStringFirst && outputSecond, "executed string comes first");
-      jsterm.clearOutput();
-      jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
+
       finishTest();
     },
     failureFn: finishTest,
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_property_panel.js b/browser/devtools/webconsole/test/browser_webconsole_property_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_property_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_property_panel.js
@@ -36,61 +36,68 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests the functionality of the "property panel", which allows JavaScript
 // objects and DOM nodes to be inspected.
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
+const TEST_URI = "data:text/html;charset=utf8,<p>property panel test";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testPropertyPanel, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testPropertyPanel);
+  }, true);
 }
 
-function testPropertyPanel() {
-  browser.removeEventListener("DOMContentLoaded", testPropertyPanel, false);
+function testPropertyPanel(hud) {
+  let jsterm = hud.jsterm;
 
-  openConsole();
-
-  var jsterm = HUDService.getHudByWindow(content).jsterm;
-
-  let propPanel = jsterm.openPropertyPanel("Test", [
-    1,
-    /abc/,
-    null,
-    undefined,
-    function test() {},
-    {}
-  ]);
+  let propPanel = jsterm.openPropertyPanel({
+    data: {
+      object: [
+        1,
+        /abc/,
+        null,
+        undefined,
+        function test() {},
+        {}
+      ]
+    }
+  });
   is (propPanel.treeView.rowCount, 6, "six elements shown in propertyPanel");
   propPanel.destroy();
 
-  propPanel = jsterm.openPropertyPanel("Test2", {
-    "0.02": 0,
-    "0.01": 1,
-    "02":   2,
-    "1":    3,
-    "11":   4,
-    "1.2":  5,
-    "1.1":  6,
-    "foo":  7,
-    "bar":  8
+  propPanel = jsterm.openPropertyPanel({
+    data: {
+      object: {
+        "0.02": 0,
+        "0.01": 1,
+        "02":   2,
+        "1":    3,
+        "11":   4,
+        "1.2":  5,
+        "1.1":  6,
+        "foo":  7,
+        "bar":  8
+      }
+    }
   });
   is (propPanel.treeView.rowCount, 9, "nine elements shown in propertyPanel");
 
-  let treeRows = propPanel.treeView._rows;
-  is (treeRows[0].display, "0.01: 1", "1. element is okay");
-  is (treeRows[1].display, "0.02: 0", "2. element is okay");
-  is (treeRows[2].display, "1: 3",    "3. element is okay");
-  is (treeRows[3].display, "1.1: 6",  "4. element is okay");
-  is (treeRows[4].display, "1.2: 5",  "5. element is okay");
-  is (treeRows[5].display, "02: 2",   "6. element is okay");
-  is (treeRows[6].display, "11: 4",   "7. element is okay");
-  is (treeRows[7].display, "bar: 8",  "8. element is okay");
-  is (treeRows[8].display, "foo: 7",  "9. element is okay");
+  let view = propPanel.treeView;
+  is (view.getCellText(0), "0.01: 1", "1. element is okay");
+  is (view.getCellText(1), "0.02: 0", "2. element is okay");
+  is (view.getCellText(2), "1: 3",    "3. element is okay");
+  is (view.getCellText(3), "1.1: 6",  "4. element is okay");
+  is (view.getCellText(4), "1.2: 5",  "5. element is okay");
+  is (view.getCellText(5), "02: 2",   "6. element is okay");
+  is (view.getCellText(6), "11: 4",   "7. element is okay");
+  is (view.getCellText(7), "bar: 8",  "8. element is okay");
+  is (view.getCellText(8), "foo: 7",  "9. element is okay");
   propPanel.destroy();
 
-  finishTest();
+  executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
--- a/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_property_provider.js
@@ -36,48 +36,42 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests the property provider, which is part of the code completion
 // infrastructure.
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
+const TEST_URI = "data:text/html;charset=utf8,<p>test the JS property provider";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testPropertyProvider, false);
+  browser.addEventListener("load", testPropertyProvider, true);
 }
 
 function testPropertyProvider() {
-  browser.removeEventListener("DOMContentLoaded", testPropertyProvider,
-                              false);
+  browser.removeEventListener("load", testPropertyProvider, true);
 
-  openConsole();
+  let tmp = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", tmp);
+  let JSPropertyProvider = tmp.JSPropertyProvider;
+  tmp = null;
 
-  var HUD = HUDService.getHudByWindow(content);
-  var jsterm = HUD.jsterm;
-  var context = jsterm.sandbox.window;
-  var completion;
-
-  // Test if the propertyProvider can be accessed from the jsterm object.
-  ok (jsterm.propertyProvider !== undefined, "JSPropertyProvider is defined");
-
-  completion = jsterm.propertyProvider(context, "thisIsNotDefined");
+  let completion = JSPropertyProvider(content, "thisIsNotDefined");
   is (completion.matches.length, 0, "no match for 'thisIsNotDefined");
 
   // This is a case the PropertyProvider can't handle. Should return null.
-  completion = jsterm.propertyProvider(context, "window[1].acb");
+  completion = JSPropertyProvider(content, "window[1].acb");
   is (completion, null, "no match for 'window[1].acb");
 
   // A very advanced completion case.
   var strComplete =
     'function a() { }document;document.getElementById(window.locatio';
-  completion = jsterm.propertyProvider(context, strComplete);
+  completion = JSPropertyProvider(content, strComplete);
   ok(completion.matches.length == 2, "two matches found");
   ok(completion.matchProp == "locatio", "matching part is 'test'");
   ok(completion.matches[0] == "location", "the first match is 'location'");
   ok(completion.matches[1] == "locationbar", "the second match is 'locationbar'");
-  context = completion = null;
+
   finishTest();
 }
 
