# HG changeset patch
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1331837970 -7200
# Node ID f156adf53752257b14ec7db012733a74c3d4fd55
# Parent 0bcbe43a02459819a7976966db253ef7cd7fffbd
Bug 673148 - (async-webconsole) Make the Web Console async

diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -10,9 +10,10 @@ browser.jar:
     content/browser/devtools/cssruleview.xul      (styleinspector/cssruleview.xul)
     content/browser/devtools/styleinspector.css   (styleinspector/styleinspector.css)
     content/browser/orion.js                      (sourceeditor/orion/orion.js)
 *   content/browser/source-editor-overlay.xul     (sourceeditor/source-editor-overlay.xul)
 *   content/browser/debugger.xul                  (debugger/debugger.xul)
     content/browser/debugger.css                  (debugger/debugger.css)
     content/browser/debugger.js                   (debugger/debugger.js)
     content/browser/debugger-view.js              (debugger/debugger-view.js)
+    content/browser/devtools/HUDService-content.js (webconsole/HUDService-content.js)
 
diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -0,0 +1,1706 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Web Console.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com> (original author)
+ *   David Dahl <ddahl@mozilla.com>
+ *   Rob Campbell <rcampbell@mozilla.com>
+ *   Johnathan Nightingale <jnightingale@mozilla.com>
+ *   Patrick Walton <pcwalton@mozilla.com>
+ *   Julian Viereck <jviereck@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// TODO: add use strict
+
+(function() {
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function () {
+  return WebConsoleUtils.l10n;
+});
+
+XPCOMUtils.defineLazyGetter(this, "JSPropertyProvider", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.JSPropertyProvider;
+});
+
+XPCOMUtils.defineLazyServiceGetter(this, "activityDistributor",
+  "@mozilla.org/network/http-activity-distributor;1",
+  "nsIHttpActivityDistributor");
+
+XPCOMUtils.defineLazyGetter(this, "NetworkHelper", function () {
+  let obj = {};
+  Cu.import("resource:///modules/NetworkHelper.jsm", obj);
+  return obj.NetworkHelper;
+});
+
+XPCOMUtils.defineLazyGetter(this, "NetUtil", function () {
+  let obj = {};
+  Cu.import("resource://gre/modules/NetUtil.jsm", obj);
+  return obj.NetUtil;
+});
+
+
+/**
+ * Evaluation result objects are cached in this object. The chrome process can
+ * request any object pased on its ID.
+ */
+let gObjectCache = {};
+
+
+/**
+ * JSTermHelper
+ *
+ * Defines a set of functions ("helper functions") that are available from the
+ * WebConsole but not from the webpage.
+ * A list of helper functions used by Firebug can be found here:
+ *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ */
+function JSTermHelper(aJSTerm)
+{
+  /**
+   * Returns the result of document.getElementById(aId).
+   *
+   * @param string aId
+   *        A string that is passed to window.document.getElementById.
+   * @returns nsIDOMNode or null
+   */
+  aJSTerm.sandbox.$ = function JSTH_$(aId)
+  {
+    return aJSTerm.window.document.getElementById(aId);
+  };
+
+  /**
+   * Returns the result of document.querySelectorAll(aSelector).
+   *
+   * @param string aSelector
+   *        A string that is passed to window.document.querySelectorAll.
+   * @returns array of nsIDOMNode
+   */
+  aJSTerm.sandbox.$$ = function JSTH_$$(aSelector)
+  {
+    return aJSTerm.window.document.querySelectorAll(aSelector);
+  };
+
+  /**
+   * Runs a xPath query and returns all matched nodes.
+   *
+   * @param string aXPath
+   *        xPath search query to execute.
+   * @param [optional] nsIDOMNode aContext
+   *        Context to run the xPath query on. Uses window.document if not set.
+   * @returns array of nsIDOMNode
+   */
+  aJSTerm.sandbox.$x = function JSTH_$x(aXPath, aContext)
+  {
+    let nodes = [];
+    let doc = aJSTerm.window.document;
+    let aContext = aContext || doc;
+
+    try {
+      let results = doc.evaluate(aXPath, aContext, null,
+                                 Ci.nsIDOMXPathResult.ANY_TYPE, null);
+      let node;
+      while (node = results.iterateNext()) {
+        nodes.push(node);
+      }
+    }
+    catch (ex) {
+      aJSTerm.console.error(ex.message);
+    }
+
+    return nodes;
+  };
+
+  /**
+   * Returns the currently selected object in the highlighter.
+   *
+   * @returns nsIDOMNode or null
+   */
+  Object.defineProperty(aJSTerm.sandbox, "$0", {
+    get: function() {
+      // TODO: this needs e10s support in the Inspector.
+      return "UNIMPLEMENTED!!!";
+      let mw = HUDService.currentContext();
+      try {
+        return mw.InspectorUI.selection;
+      }
+      catch (ex) {
+        aJSTerm.console.error(ex.message);
+      }
+    },
+    enumerable: true,
+    configurable: false
+  });
+
+  /**
+   * Clears the output of the JSTerm.
+   */
+  aJSTerm.sandbox.clear = function JSTH_clear()
+  {
+    aJSTerm.helperEvaluated = true;
+    sendAsyncMessage("JSTerm:ClearOutput", {hudId: aJSTerm.hudId});
+  };
+
+  /**
+   * Returns the result of Object.keys(aObject).
+   *
+   * @param object aObject
+   *        Object to return the property names from.
+   * @returns array of string
+   */
+  aJSTerm.sandbox.keys = function JSTH_keys(aObject)
+  {
+    return Object.keys(WebConsoleUtils.unwrap(aObject));
+  };
+
+  /**
+   * Returns the values of all properties on aObject.
+   *
+   * @param object aObject
+   *        Object to display the values from.
+   * @returns array of string
+   */
+  aJSTerm.sandbox.values = function JSTH_values(aObject)
+  {
+    let arrValues = [];
+    let obj = WebConsoleUtils.unwrap(aObject);
+
+    // FIXME: isn't this a security issue? we can execute non-native getters
+    // here.
+    try {
+      for (let prop in obj) {
+        arrValues.push(obj[prop]);
+      }
+    }
+    catch (ex) {
+      aJSTerm.console.error(ex.message);
+    }
+    return arrValues;
+  };
+
+  /**
+   * Opens a help window in MDC
+   */
+  aJSTerm.sandbox.help = function JSTH_help()
+  {
+    aJSTerm.helperEvaluated = true;
+    aJSTerm.window.open(
+        "https://developer.mozilla.org/AppLinks/WebConsoleHelp?locale=" +
+        aJSTerm.window.navigator.language, "help", "");
+  };
+
+  /**
+   * Inspects the passed aObject. This is done by opening the PropertyPanel.
+   *
+   * @param object aObject
+   *        Object to inspect.
+   * @returns void
+   */
+  aJSTerm.sandbox.inspect = function JSTH_inspect(aObject)
+  {
+    if (!WebConsoleUtils.isResultInspectable(aObject)) {
+      return aObject;
+    }
+
+    aJSTerm.helperEvaluated = true;
+
+    let message = {
+      hudId: aJSTerm.hudId,
+      id: aJSTerm.sequenceId,
+      input: aJSTerm._evalInput,
+      objectCacheId: aJSTerm.sequenceId,
+    };
+
+    message.resultObject =
+      aJSTerm.prepareEvalResultObject(message.objectCacheId,
+                                      WebConsoleUtils.unwrap(aObject));
+
+    sendAsyncMessage("JSTerm:InspectObject", message);
+  };
+
+  aJSTerm.sandbox.inspectrules = function JSTH_inspectrules(aNode)
+  {
+    return "UNIMPLEMENTED";
+
+    // TODO: this needs e10s support in the CssRuleView code.
+
+    aJSTerm.helperEvaluated = true;
+    let doc = aJSTerm.parentNode.ownerDocument;
+    let win = doc.defaultView;
+    let panel = createElement(doc, "panel", {
+      label: "CSS Rules",
+      titlebar: "normal",
+      noautofocus: "true",
+      noautohide: "true",
+      close: "true",
+      width: 350,
+      height: (win.screen.height / 2)
+    });
+
+    let iframe = createAndAppendElement(panel, "iframe", {
+      src: "chrome://browser/content/devtools/cssruleview.xhtml",
+      flex: "1",
+    });
+
+    panel.addEventListener("load", function onLoad() {
+      panel.removeEventListener("load", onLoad, true);
+      let doc = iframe.contentDocument;
+      let view = new CssRuleView(doc);
+      let body = doc.getElementById("ruleview-body");
+      body.appendChild(view.element);
+      view.highlight(aNode);
+    }, true);
+
+    let parent = doc.getElementById("mainPopupSet");
+    parent.appendChild(panel);
+
+    panel.addEventListener("popuphidden", function onHide() {
+      panel.removeEventListener("popuphidden", onHide);
+      parent.removeChild(panel);
+    });
+
+    let footer = createElement(doc, "hbox", { align: "end" });
+    createAndAppendElement(footer, "spacer", { flex: 1});
+    createAndAppendElement(footer, "resizer", { dir: "bottomend" });
+    panel.appendChild(footer);
+
+    let anchor = win.gBrowser.selectedBrowser;
+    panel.openPopup(anchor, "end_before", 0, 0, false, false);
+  };
+
+  /**
+   * Prints aObject to the output.
+   *
+   * @param object aObject
+   *        Object to print to the output.
+   * @returns void
+   */
+  aJSTerm.sandbox.pprint = function JSTH_pprint(aObject)
+  {
+    aJSTerm.helperEvaluated = true;
+    if (aObject === null || aObject === undefined || aObject === true ||
+        aObject === false) {
+      aJSTerm.console.error(l10n.getStr("helperFuncUnsupportedTypeError"));
+      return;
+    }
+    else if (typeof aObject == "function") {
+      aJSTerm.helperRawOutput = true;
+      return aObject + "\n";
+    }
+
+    aJSTerm.helperRawOutput = true;
+
+    let output = [];
+    let pairs = WebConsoleUtils.namesAndValuesOf(WebConsoleUtils.unwrap(aObject));
+    pairs.forEach(function(aPair) {
+      output.push(aPair.name + ": " + aPair.value);
+    });
+
+    return "  " + output.join("\n  ");
+  };
+
+  /**
+   * Print a string to the output, as-is.
+   *
+   * @param string aString
+   *        A string you want to output.
+   * @returns void
+   */
+  aJSTerm.sandbox.print = function JSTH_print(aString)
+  {
+    aJSTerm.helperEvaluated = true;
+    aJSTerm.helperRawOutput = true;
+    return aString + "";
+  };
+}
+
+let JSTerm = {
+  get "window"() content,
+  get console() this.window.console,
+  sandbox: null,
+  hudId: null,
+  _sequence: 0,
+
+  get sequenceId() "HUDContent-" + (++this._sequence),
+
+  init: function JST_init()
+  {
+    this.createSandbox();
+
+    this._messageListeners = ["JSTerm:Init", "JSTerm:Destroy",
+      "JSTerm:EvalRequest", "JSTerm:GetEvalObject", "JSTerm:ClearObjectCache",
+      "JSTerm:Autocomplete"];
+    this._messageListeners.forEach(function(aName) {
+      addMessageListener(aName, this);
+    }, this);
+
+    // TODO: start observers/listeners only on demand.
+    ConsoleAPIObserver.init();
+    ConsoleListener.init();
+    NetworkMonitor.init();
+  },
+
+  receiveMessage: function JST_receiveMessage(aMessage)
+  {
+    if (!aMessage.json || (aMessage.name != "JSTerm:Init" &&
+                           aMessage.json.hudId != this.hudId)) {
+      dump("JST_receiveMessage content this.hudId " + this.hudId + " != that.hudId " + aMessage.json.hudId + "\n");
+      Cu.reportError("JSTerm content: received message " + aMessage.name +
+                     " from wrong hudId.");
+      return;
+    }
+
+    dump("JST_receiveMessage content " + aMessage.name + "\n");
+    switch (aMessage.name) {
+      case "JSTerm:Init":
+        if (this.hudId) {
+          dump("JSTerm:Init hudId " + this.hudId + " already defined\n");
+        }
+        this.hudId = aMessage.json.hudId;
+        dump("JSTerm:Init content " + this.hudId + "\n");
+        break;
+      case "JSTerm:Destroy":
+        this.destroy();
+        break;
+      case "JSTerm:EvalRequest":
+        this.handleEvalRequest(aMessage.json);
+        break;
+      case "JSTerm:GetEvalObject":
+        this.handleGetEvalObject(aMessage.json);
+        break;
+      case "JSTerm:ClearObjectCache":
+        this.handleClearObjectCache(aMessage.json);
+        break;
+      case "JSTerm:Autocomplete":
+        this.handleAutocomplete(aMessage.json);
+        break;
+    }
+  },
+
+  handleEvalRequest: function JST_handleEvalRequest(aRequest)
+  {
+    dump("JST_handleEvalRequest content evalId " + aRequest.id + " resultCacheId " + aRequest.resultCacheId + "\n");
+    let id = aRequest.id;
+    let input = aRequest.str;
+    let result, error = null;
+
+    this.helperEvaluated = false;
+    this.helperRawOutput = false;
+    this._evalInput = input;
+    try {
+      result = this.evalInSandbox(input);
+    }
+    catch (ex) {
+      error = ex;
+    }
+    delete this._evalInput;
+
+    let inspectable = !error && WebConsoleUtils.isResultInspectable(result);
+    let resultString = undefined;
+    if (!error) {
+      resultString = this.helperRawOutput ? result :
+                     WebConsoleUtils.formatResult(result);
+    }
+
+    let message = {
+      hudId: this.hudId,
+      id: id,
+      input: input,
+      resultString: resultString,
+      error: error,
+      errorMessage: error ? error.toString() : null,
+      inspectable: inspectable,
+      helperResult: this.helperEvaluated,
+    };
+
+    if (inspectable) {
+      message.childrenCacheId = aRequest.resultCacheId;
+      message.resultObject =
+        this.prepareEvalResultObject(message.childrenCacheId, result);
+    }
+
+    sendAsyncMessage("JSTerm:EvalResult", message);
+  },
+
+  handleGetEvalObject: function JST_handleGetEvalObject(aRequest)
+  {
+    dump("JST_handleGetEvalObject id " + aRequest.id + " inCache " + (aRequest.cacheId in gObjectCache) + " cacheId " + aRequest.cacheId + " objectId " + aRequest.objectId + " resultCacheId " + aRequest.resultCacheId + "\n");
+    if (aRequest.cacheId in gObjectCache &&
+        aRequest.objectId in gObjectCache[aRequest.cacheId]) {
+      let object = gObjectCache[aRequest.cacheId][aRequest.objectId];
+      let resultCacheId = aRequest.resultCacheId || aRequest.cacheId;
+      let message = {
+        hudId: this.hudId,
+        id: aRequest.id,
+        cacheId: aRequest.cacheId,
+        objectId: aRequest.objectId,
+        object: this.prepareEvalResultObject(resultCacheId, object),
+        childrenCacheId: resultCacheId,
+      };
+      sendAsyncMessage("JSTerm:EvalObject", message);
+    }
+    else {
+      Cu.reportError("JSTerm:GetEvalObject request " + aRequest.id +
+                     ": stale object.");
+    }
+  },
+
+  handleClearObjectCache: function JST_handleClearObjectCache(aRequest)
+  {
+    if (aRequest.cacheId in gObjectCache) {
+      dump("JST_handleClearObjectCache " + aRequest.cacheId + "\n");
+      delete gObjectCache[aRequest.cacheId];
+    }
+    else {
+      dump("JST_handleClearObjectCache " + aRequest.cacheId + " not found\n");
+    }
+  },
+
+  prepareEvalResultObject:
+  function JST_prepareEvalResultObject(aCacheId, aObject)
+  {
+    // Cache the properties that have inspectable values.
+    let propCache = gObjectCache[aCacheId] || {};
+    let result = WebConsoleUtils.namesAndValuesOf(aObject, propCache);
+    if (!(aCacheId in gObjectCache) && Object.keys(propCache).length > 0) {
+      gObjectCache[aCacheId] = propCache;
+    }
+
+    dump("prepareEvalResultObject inCache " + (aCacheId in gObjectCache) + " propCache for " + aCacheId + ": " + Object.keys(propCache) + "\n");
+
+    return result;
+  },
+
+  handleAutocomplete: function JST_handleAutocomplete(aRequest)
+  {
+    let result = JSPropertyProvider(this.window, aRequest.input) || {};
+    let message = {
+      hudId: this.hudId,
+      id: aRequest.id,
+      input: aRequest.input,
+      matches: result.matches || [],
+      matchProp: result.matchProp,
+    };
+    sendAsyncMessage("JSTerm:AutocompleteProperties", message);
+  },
+
+  createSandbox: function JST_createSandbox()
+  {
+    dump("JST_createSandbox\n");
+    this.sandbox = new Cu.Sandbox(this.window,
+      { sandboxPrototype: this.window, wantXrays: false });
+    this.sandbox.console = this.console;
+
+    JSTermHelper(this);
+  },
+
+  /**
+   * Evaluates a string in the sandbox.
+   *
+   * @param string aString
+   *        String to evaluate in the sandbox.
+   * @returns something
+   *          The result of the evaluation.
+   */
+  evalInSandbox: function JST_evalInSandbox(aString)
+  {
+    // The help function needs to be easy to guess, so we make the () optional
+    if (aString.trim() == "help" || aString.trim() == "?") {
+      aString = "help()";
+    }
+
+    let window = WebConsoleUtils.unwrap(this.sandbox.window);
+    let $ = null, $$ = null;
+
+    // We prefer to execute the page-provided implementations for the $() and
+    // $$() functions.
+    if (typeof window.$ == "function") {
+      $ = this.sandbox.$;
+      delete this.sandbox.$;
+    }
+    if (typeof window.$$ == "function") {
+      $$ = this.sandbox.$$;
+      delete this.sandbox.$$;
+    }
+
+    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8",
+                                  "Web Console", 1);
+
+    if ($) {
+      this.sandbox.$ = $;
+    }
+    if ($$) {
+      this.sandbox.$$ = $$;
+    }
+
+    return result;
+  },
+
+  destroy: function JST_destroy()
+  {
+    ConsoleAPIObserver.destroy();
+    ConsoleListener.destroy();
+    NetworkMonitor.destroy();
+
+    this.hudId = null;
+    delete this.sandbox;
+    delete this.window;
+    delete this.console;
+
+    this._messageListeners.forEach(function(aName) {
+      removeMessageListener(aName, this);
+    }, this);
+
+    dump("JST_destroy gObjectCache " + Object.keys(gObjectCache) + "\n");
+
+    gObjectCache = {};
+    JSTerm = null;
+  },
+};
+
+let ConsoleAPIObserver = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+  init: function CAO_init()
+  {
+    dump("CAO_init()\n");
+
+    // TODO: address the problem of having this observer registered multiple
+    // times in the same process.
+    Services.obs.addObserver(this, "console-api-log-event", false);
+  },
+
+  observe: function CAO_observe(aMessage, aTopic, aData)
+  {
+    if (!aMessage || aTopic != "console-api-log-event") {
+      return;
+    }
+
+    dump("CAO_observe content " + JSTerm.hudId + " " + aTopic + " outer " + aMessage.wrappedJSObject.ID + " inner " + aMessage.wrappedJSObject.innerID + "\n");
+
+    let apiMessage = aMessage.wrappedJSObject;
+
+    let msgWindow =
+      WebConsoleUtils.getWindowByOuterId(apiMessage.ID, JSTerm.window);
+    if (!msgWindow || msgWindow.top != JSTerm.window) {
+      dump("CAO_observe content " + JSTerm.hudId + " wrong window " + apiMessage.ID + "\n");
+      return;
+    }
+
+    let messageToChrome = {
+      hudId: JSTerm.hudId,
+      id: JSTerm.sequenceId,
+      apiMessage: {},
+    };
+
+    messageToChrome.apiMessage =
+      WebConsoleUtils.cloneObject(apiMessage, true,
+        function(aKey, aValue, aObject) {
+          // We need to skip the arguments property from apiMessage for all
+          // messages, except for trace.
+          if (aKey == "wrappedJSObject" ||
+              aObject === apiMessage && aKey == "arguments" &&
+              apiMessage.level != "trace") {
+            return false;
+          }
+          return true;
+        });
+
+    dump("apiMessage " + apiMessage.level + " " + Object.keys(messageToChrome.apiMessage) + "\n");
+
+    // TODO: deal with passing result objects to other window.console API
+    // messages, beyond console.dir(). This is sufficient for parity with the
+    // current non-e10s Web Console code.
+
+    // FIXME for console.time and console.group
+    let mapFunction;
+    if (apiMessage.level == "dir" && apiMessage.arguments) {
+      messageToChrome.objectsCacheId = JSTerm.sequenceId;
+      messageToChrome.argumentsToString = [];
+      mapFunction = function(aItem) {
+        messageToChrome.argumentsToString.push(aItem.toString());
+        return JSTerm.prepareEvalResultObject(messageToChrome.objectsCacheId,
+                                              aItem);
+      };
+    }
+    else if (apiMessage.level != "dir" && apiMessage.level != "trace") {
+      mapFunction = function(aItem) {
+        return typeof aItem == "string" ? aItem :
+               WebConsoleUtils.formatResult(aItem);
+      };
+    }
+
+    if (apiMessage.arguments && mapFunction) {
+      messageToChrome.apiMessage.arguments =
+        Array.map(apiMessage.arguments, mapFunction);
+    }
+
+    sendAsyncMessage("WebConsole:ConsoleAPI", messageToChrome);
+  },
+
+  destroy: function CAO_destroy()
+  {
+    dump("CAO_destroy()\n");
+    Services.obs.removeObserver(this, "console-api-log-event");
+    ConsoleAPIObserver = null;
+  },
+};
+
+let ConsoleListener = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIConsoleListener]),
+
+  // Same as in HUDService.jsm.
+  CATEGORY_CSS: 1,
+  CATEGORY_JS: 2,
+
+  init: function CL_init()
+  {
+    dump("CL_init()\n");
+
+    // TODO: address the problem of having this listener registered multiple
+    // times in the same process.
+    Services.console.registerListener(this);
+  },
+
+  observe: function CL_observe(aScriptError)
+  {
+    if (!(aScriptError instanceof Ci.nsIScriptError) ||
+        !aScriptError.outerWindowID) {
+      dump("CL_observe content !!! category " + aScriptError.category + " outer " + aScriptError.outerWindowID + " inner " + aScriptError.innerWindowID + "\n");
+      return;
+    }
+    dump("CL_observe content " + JSTerm.hudId + " category " + aScriptError.category + " outer " + aScriptError.outerWindowID + " inner " + aScriptError.innerWindowID + "\n");
+
+    switch (aScriptError.category) {
+      // We ignore chrome-originating errors as we only care about content.
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return;
+    }
+
+    let errorWindow = WebConsoleUtils.
+                      getWindowByOuterId(aScriptError.outerWindowID,
+                                         JSTerm.window);
+    if (!errorWindow || errorWindow.top != JSTerm.window) {
+      dump("CL_observe content " + JSTerm.hudId + " wrong window " + aScriptError.outerWindowID + "\n");
+      return;
+    }
+
+    let message = {
+      hudId: JSTerm.hudId,
+      id: JSTerm.sequenceId,
+      error: aScriptError,
+      category: aScriptError.category == "CSS Parser" ||
+                aScriptError.category == "CSS Loader" ?
+                this.CATEGORY_CSS : this.CATEGORY_JS,
+    };
+
+    sendAsyncMessage("WebConsole:PageError", message);
+  },
+
+  destroy: function CL_destroy()
+  {
+    dump("CL_destroy()\n");
+    Services.console.unregisterListener(this);
+    ConsoleListener = null;
+  },
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// Network logging
+///////////////////////////////////////////////////////////////////////////////
+
+// The maximum uint32 value.
+const PR_UINT32_MAX = 4294967295;
+
+// HTTP status codes.
+const HTTP_MOVED_PERMANENTLY = 301;
+const HTTP_FOUND = 302;
+const HTTP_SEE_OTHER = 303;
+const HTTP_TEMPORARY_REDIRECT = 307;
+
+// The maximum number of bytes a NetworkResponseListener can hold.
+const RESPONSE_BODY_LIMIT = 1048576; // 1 MB
+
+/**
+ * Implements the nsIStreamListener and nsIRequestObserver interface. Used
+ * within the HS_httpObserverFactory function to get the response body of
+ * requests.
+ *
+ * The code is mostly based on code listings from:
+ *
+ *   http://www.softwareishard.com/blog/firebug/
+ *      nsitraceablechannel-intercept-http-traffic/
+ *
+ * @param object aHttpActivity
+ *        HttpActivity object associated with this request (see
+ *        HS_httpObserverFactory). As the response is done, the response header,
+ *        body and status is stored on aHttpActivity.
+ */
+// TODO update comment
+function NetworkResponseListener(aHttpActivity) {
+  this.receivedData = "";
+  this.httpActivity = aHttpActivity;
+}
+
+NetworkResponseListener.prototype = {
+  QueryInterface:
+    XPCOMUtils.generateQI([Ci.nsIStreamListener, Ci.nsIInputStreamCallback,
+                           Ci.nsIRequestObserver, Ci.nsISupports]),
+
+  /**
+   * This NetworkResponseListener tracks the NetworkMonitor.openResponses object
+   * to find the associated uncached headers.
+   * @private
+   */
+  _foundOpenResponse: false,
+
+  /**
+   * The response will be written into the outputStream of this nsIPipe.
+   * Both ends of the pipe must be blocking.
+   */
+  sink: null,
+
+  /**
+   * The HttpActivity object associated with this response.
+   */
+  httpActivity: null,
+
+  /**
+   * Stores the received data as a string.
+   */
+  receivedData: null,
+
+  /**
+   * The nsIRequest we are started for.
+   */
+  request: null,
+
+  /**
+   * Set the async listener for the given nsIAsyncInputStream. This allows us to
+   * wait asynchronously for any data coming from the stream.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The input stream from where we are waiting for data to come in.
+   *
+   * @param nsIInputStreamCallback aListener
+   *        The input stream callback you want. This is an object that must have
+   *        the onInputStreamReady() method. If the argument is null, then the
+   *        current callback is removed.
+   *
+   * @returns void
+   */
+  setAsyncListener: function NRL_setAsyncListener(aStream, aListener)
+  {
+    //dump("NRL_setAsyncListener\n");
+    // Asynchronously wait for the stream to be readable or closed.
+    aStream.asyncWait(aListener, 0, 0, Services.tm.mainThread);
+  },
+
+  /**
+   * Stores the received data, if request/response body logging is enabled. It
+   * also does limit the number of stored bytes, based on the
+   * RESPONSE_BODY_LIMIT constant.
+   *
+   * Learn more about nsIStreamListener at:
+   * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIStreamListener
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   * @param nsIInputStream aInputStream
+   * @param unsigned long aOffset
+   * @param unsigned long aCount
+   */
+  onDataAvailable:
+  function NRL_onDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount)
+  {
+    this._findOpenResponse();
+    let data = NetUtil.readInputStreamToString(aInputStream, aCount);
+
+    if (!this.httpActivity.discardResponseBody &&
+        this.receivedData.length < RESPONSE_BODY_LIMIT) {
+      this.receivedData += NetworkHelper.
+                           convertToUnicode(data, aRequest.contentCharset);
+    }
+  },
+
+  /**
+   * See documentation at
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   *
+   * @param nsIRequest aRequest
+   * @param nsISupports aContext
+   */
+  onStartRequest: function NRL_onStartRequest(aRequest, aContext)
+  {
+    dump("NRL_onStartRequest\n");
+    this.request = aRequest;
+
+    this._findOpenResponse();
+
+    // Asynchronously wait for the data coming from the request.
+    this.setAsyncListener(this.sink.inputStream, this);
+  },
+
+  /**
+   * Handle the onStopRequest by storing the response header is stored on the
+   * httpActivity object. The sink output stream is also closed.
+   *
+   * For more documentation about nsIRequestObserver go to:
+   * https://developer.mozilla.org/En/NsIRequestObserver
+   *
+   * @param nsIRequest aRequest
+   *        The request we are observing.
+   * @param nsISupports aContext
+   * @param nsresult aStatusCode
+   */
+  onStopRequest: function NRL_onStopRequest(aRequest, aContext, aStatusCode)
+  {
+    dump("NRL_onStopRequest\n");
+
+    this._findOpenResponse();
+
+    this.httpActivity.stage = "REQUEST_STOP";
+
+    if (!this.httpActivity.discardResponseBody &&
+        this.saveRequestAndResponseBodies) {
+      logResponse.content.size = this.receivedData.length;
+      logResponse.content.text = this.receivedData;
+    }
+
+    this.receivedData = "";
+
+    NetworkMonitor._sendMessageToChrome(this.httpActivity);
+
+    this.sink.outputStream.close();
+  },
+
+  _findOpenResponse: function NRL__findOpenResponse()
+  {
+    if (this._foundOpenResponse) {
+      //dump("NRL__findOpenResponse already did\n");
+      return;
+    }
+
+    let logResponse = this.httpActivity.log.entries[0].response;
+    let openResponse = null;
+
+    for each (let item in NetworkMonitor.openResponses) {
+      if (item.channel !== this.httpActivity.channel) {
+        continue;
+      }
+
+      logResponse.headers = item.headers;
+      logResponse.cookies = item.cookies;
+      logResponse.httpVersion = item.httpVersion;
+      logResponse.status = item.status;
+      logResponse.statusText = item.statusText;
+      logResponse.content.mimeType = item.contentType;
+
+      openResponse = item.id;
+      break;
+    }
+
+    dump("NRL__findOpenResponse openResponse " + openResponse + "\n");
+
+    if (openResponse) {
+      delete NetworkMonitor.openResponses[openResponse];
+      this._foundOpenResponse = true;
+
+      this.httpActivity.stage = "http-on-examine-response";
+      NetworkMonitor._sendMessageToChrome(this.httpActivity);
+    }
+  },
+
+  /**
+   * Clean up the response listener once the response input stream is closed.
+   * This is called from onStopRequest() or from onInputStreamReady() when the
+   * stream is closed.
+   *
+   * @returns void
+   */
+  onStreamClose: function NRL_onStreamClose()
+  {
+    if (!this.httpActivity) {
+      return;
+    }
+    dump("NRL_onStreamClose\n");
+
+    // Remove our listener from the request input stream.
+    this.setAsyncListener(this.sink.inputStream, null);
+
+    this._findOpenResponse();
+
+    /* FIXME: need to see what we do with the network tests
+    if (HUDService.lastFinishedRequestCallback) {
+      HUDService.lastFinishedRequestCallback(this.httpActivity);
+    }
+    */
+
+    this.httpActivity.channel = null;
+    this.httpActivity = null;
+    this.sink = null;
+    this.inputStream = null;
+  },
+
+  /**
+   * The nsIInputStreamCallback for when the request input stream is ready -
+   * either it has more data or it is closed.
+   *
+   * @param nsIAsyncInputStream aStream
+   *        The sink input stream from which data is coming.
+   *
+   * @returns void
+   */
+  onInputStreamReady: function NRL_onInputStreamReady(aStream)
+  {
+    if (!(aStream instanceof Ci.nsIAsyncInputStream) || !this.httpActivity) {
+      return;
+    }
+
+    let available = -1;
+    try {
+      // This may throw if the stream is closed normally or due to an error.
+      available = aStream.available();
+    }
+    catch (ex) { }
+
+    if (available != -1) {
+      if (available != 0) {
+        // Note that passing 0 as the offset here is wrong, but the
+        // onDataAvailable() method does not use the offset, so it does not
+        // matter.
+        this.onDataAvailable(this.request, null, aStream, 0, available);
+      }
+      this.setAsyncListener(aStream, this);
+    }
+    else {
+      this.onStreamClose();
+    }
+  },
+};
+
+let NetworkMonitor = {
+  httpTransactionCodes: {
+    0x5001: "REQUEST_HEADER",
+    0x5002: "REQUEST_BODY_SENT",
+    0x5003: "RESPONSE_START",
+    0x5004: "RESPONSE_HEADER",
+    0x5005: "RESPONSE_COMPLETE",
+    0x5006: "TRANSACTION_CLOSE",
+
+    0x804b0003: "STATUS_RESOLVING",
+    0x804b000b: "STATUS_RESOLVED",
+    0x804b0007: "STATUS_CONNECTING_TO",
+    0x804b0004: "STATUS_CONNECTED_TO",
+    0x804b0005: "STATUS_SENDING_TO",
+    0x804b000a: "STATUS_WAITING_FOR",
+    0x804b0006: "STATUS_RECEIVING_FROM"
+  },
+
+  harCreator: {
+    name: "Firefox Web Console",
+    version: Services.appinfo.version,
+  },
+
+  // Network response bodies are piped through a buffer of the given size (in
+  // bytes).
+  responsePipeSegmentSize: null,
+
+  /**
+   * FIXME: Whether to save the bodies of network requests and responses.  
+   * Disabled by
+   * default to save memory.
+   */
+  saveRequestAndResponseBodies: false,
+
+  openRequests: null,
+  openResponses: null,
+
+  init: function NM_init()
+  {
+    this.responsePipeSegmentSize =
+      Services.prefs.getIntPref("network.buffer.cache.size");
+
+    this.openRequests = {};
+    this.openResponses = {};
+
+    activityDistributor.addObserver(this);
+
+    Services.obs.addObserver(this.httpResponseExaminer,
+                             "http-on-examine-response", false);
+
+    /* FIXME
+    let browser = this.tab.linkedBrowser;
+    this.progressListener = new ConsoleProgressListener(this.hudId);
+    browser.webProgress.addProgressListener(this.progressListener,
+      Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+    */
+  },
+
+  /**
+   * Observe notifications for the http-on-examine-response topic, coming from
+   * the nsIObserver service.
+   *
+   * @param string aTopic
+   * @param nsIHttpChannel aSubject
+   * @returns void
+   */
+  httpResponseExaminer: function NM_httpResponseExaminer(aSubject, aTopic)
+  {
+    // The httpResponseExaminer is used to retrieve the uncached response
+    // headers. The data retrieved is stored in openResponses. When
+    // NetworkResponseListener is responsible with updating the httpActivity
+    // object with the data from the new object in openResponses.
+
+    if (aTopic != "http-on-examine-response" ||
+        !(aSubject instanceof Ci.nsIHttpChannel)) {
+      return;
+    }
+
+    let channel = aSubject.QueryInterface(Ci.nsIHttpChannel);
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(channel);
+    if (!win || win.top !== JSTerm.window) {
+      dump("httpResponseExaminer wrong window\n");
+      return;
+    }
+
+    dump("httpResponseExaminer\n");
+
+    let response = {
+      id: JSTerm.sequenceId,
+      channel: channel,
+      headers: [],
+      cookies: [],
+      httpVersion: "",
+    };
+
+    let setCookieHeader = null;
+    let contentType = null;
+
+    channel.visitResponseHeaders({
+      visitHeader: function _visitHeader(aName, aValue) {
+        let lowerName = aName.toLowerCase();
+        if (lowerName == "set-cookie") {
+          setCookieHeader = aValue;
+        } else if (lowerName == "content-type") {
+          contentType = aValue;
+        }
+        response.headers.push({name: aName, value: aValue});
+      }
+    });
+
+    if (!response.headers.length) {
+      return; // No need to continue.
+    }
+
+    if (setCookieHeader) {
+      response.cookies = NetworkMonitor._parseSetCookieHeader(setCookieHeader);
+    }
+    if (contentType) {
+      response.contentType = contentType;
+    }
+
+    // Determine the HTTP version.
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+
+    channel.QueryInterface(Ci.nsIHttpChannelInternal);
+    channel.getResponseVersion(httpVersionMaj, httpVersionMin);
+
+    response.status = channel.responseStatus;
+    response.statusText = channel.responseStatusText;
+    response.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                     httpVersionMin.value;
+
+    dump("httpResponseExaminer response.httpVersion '" + response.httpVersion + "' '" + response.status + "' '" + response.statusText + "'\n");
+
+    NetworkMonitor.openResponses[response.id] = response;
+  },
+
+  /**
+   * Begin observing HTTP traffic that we care about,
+   * namely traffic that originates inside any context that a Heads Up Display
+   * is active for.
+   */
+  // TODO: update comment
+  observeActivity:
+  function NM_observeActivity(aChannel, aActivityType, aActivitySubtype,
+                              aTimestamp, aExtraSizeData, aExtraStringData)
+  {
+    if (aActivityType != activityDistributor.ACTIVITY_TYPE_HTTP_TRANSACTION &&
+        aActivityType != activityDistributor.ACTIVITY_TYPE_SOCKET_TRANSPORT) {
+      dump("observeActivity type unknown\n");
+      return;
+    }
+
+    //dump("observeActivity ACTIVITY_TYPE_HTTP_TRANSACTION || ACTIVITY_TYPE_SOCKET_TRANSPORT\n");
+
+    if (!(aChannel instanceof Ci.nsIHttpChannel)) {
+      dump("observeActivity aChannel not instanceof nsIHttpChannel\n");
+      return;
+    }
+
+    aChannel = aChannel.QueryInterface(Ci.nsIHttpChannel);
+
+    if (aActivitySubtype ==
+        activityDistributor.ACTIVITY_SUBTYPE_REQUEST_HEADER) {
+      this._onRequestHeader(aChannel, aTimestamp, aExtraStringData);
+      return;
+    }
+
+    // Iterate over all currently ongoing requests. If aChannel can't
+    // be found within them, then exit this function.
+    let httpActivity = null;
+    for each (let item in this.openRequests) {
+      if (item.channel === aChannel) {
+        httpActivity = item;
+        break;
+      }
+    }
+
+    if (!httpActivity) {
+      dump("found no httpActivity\n");
+      return;
+    }
+
+    let transCodes = this.httpTransactionCodes;
+
+    // Store the time information for this activity subtype.
+    if (aActivitySubtype in transCodes) {
+      httpActivity.stage = transCodes[aActivitySubtype];
+      dump("timings " + httpActivity.stage + " " + aTimestamp + "\n");
+      if (httpActivity.stage in httpActivity.timings) {
+        httpActivity.timings[httpActivity.stage].last = aTimestamp;
+      }
+      else {
+        httpActivity.timings[httpActivity.stage] = {
+          first: aTimestamp,
+          last: aTimestamp,
+        };
+      }
+    }
+
+    switch (aActivitySubtype) {
+      case activityDistributor.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT:
+        this._onRequestBodySent(httpActivity);
+        break;
+      case activityDistributor.ACTIVITY_SUBTYPE_RESPONSE_HEADER:
+        this._onResponseHeader(httpActivity, aExtraStringData);
+        break;
+      case activityDistributor.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE:
+        this._onTransactionClose(httpActivity);
+        break;
+      default:
+        //dump("aActivitySubtype " + transCodes[aActivitySubtype] + " " + aActivitySubtype + "\n");
+        break;
+    }
+  },
+
+  // TODO: add comments
+  _onRequestHeader:
+  function NM__onRequestHeader(aChannel, aTimestamp, aExtraStringData)
+  {
+    dump("NM__onRequestHeader\n");
+    // Try to get the source window of the request.
+    let win = NetworkHelper.getWindowForRequest(aChannel);
+    if (!win || win.top !== JSTerm.window) {
+      return;
+    }
+
+    let httpActivity = this._createActivityObject(aChannel);
+    httpActivity.charset = win.document.characterSet; // see NM__onRequestBodySent()
+    httpActivity.stage = "REQUEST_HEADER"; // activity stage (aActivitySubtype)
+    httpActivity.discardRequestBody = !this.saveRequestAndResponseBodies;
+    httpActivity.discardResponseBody = !this.saveRequestAndResponseBodies;
+    httpActivity.timings.REQUEST_HEADER = {first: aTimestamp, last: aTimestamp};
+
+    let entry = httpActivity.log.entries[0];
+    // TODO: check date parsing works
+    entry.startedDateTime = new Date(Math.round(aTimestamp / 1000)).toISOString();
+
+    dump("_onRequestHeader start date " + entry.startedDateTime + "\n");
+
+    let request = httpActivity.log.entries[0].request;
+
+    let cookieHeader = null;
+
+    // Copy the request header data.
+    aChannel.visitRequestHeaders({
+      visitHeader: function _visitHeader(aName, aValue)
+      {
+        if (aName == "Cookie") {
+          cookieHeader = aValue;
+        }
+        request.headers.push({name: aName, value: aValue});
+      }
+    });
+
+    if (cookieHeader) {
+      request.cookies = this._parseCookieHeader(cookieHeader);
+    }
+
+    // Determine the HTTP version.
+    let httpVersionMaj = {};
+    let httpVersionMin = {};
+
+    aChannel.QueryInterface(Ci.nsIHttpChannelInternal);
+    aChannel.getRequestVersion(httpVersionMaj, httpVersionMin);
+
+    request.httpVersion = "HTTP/" + httpVersionMaj.value + "." +
+                                    httpVersionMin.value;
+
+    dump("request.httpVersion " + request.httpVersion + "\n");
+
+    request.headersSize = aExtraStringData.length;
+
+    this._setupResponseListener(httpActivity);
+
+    this.openRequests[httpActivity.id] = httpActivity;
+
+    this._sendMessageToChrome(httpActivity);
+  },
+
+  _createActivityObject: function NM__createActivityObject(aChannel)
+  {
+    // The httpActivity object will hold all information concerning this request
+    // and later response.
+    // This is a HAR-like object. Conformance to the spec is not guaranteed at
+    // this point.
+    // TODO: Bug 708717 - Add support for network log export to HAR
+    // Also see: http://www.softwareishard.com/blog/har-12-spec
+    // TODO: update these comments.
+    return httpActivity = {
+      hudId: JSTerm.hudId,
+      id: JSTerm.sequenceId,
+      channel: aChannel,
+      charset: null, // see NM__onRequestHeader()
+      stage: null, // activity stage (aActivitySubtype)
+      timings: {}, // internal timing information
+      log: { // HAR object
+        version: "1.2",
+        creator: this.harCreator,
+        // could add browser and pages.
+        entries: [{
+          connection: JSTerm.sequenceId,
+          startedDateTime: 0, // see NM__onRequestHeader()
+          time: 0, // see NM__onTransactionClose()
+          // could add serverIPAddress, cache
+          request: {
+            method: aChannel.requestMethod,
+            url: aChannel.URI.spec,
+            httpVersion: "", // see NM__onRequestHeader()
+            headers: [], // see NM__onRequestHeader()
+            cookies: [], // see NM__onRequestHeader()
+            queryString: [], // never set
+            headersSize: -1, // see NM__onRequestHeader()
+            bodySize: -1, // see NM__onRequestBodySent()
+            postData: {}, // see NM__onRequestBodySent()
+          },
+          response: {
+            status: 0, // see NM__onResponseHeader()
+            statusText: "", // see NM__onResponseHeader()
+            httpVersion: "", // see NM__onResponseHeader()
+            headers: [], // see NM__onResponseHeader()
+            cookies: [], // see NM__onResponseHeader()
+            content: {}, // see NRL_onStopRequest()
+            redirectURL: "",
+            headersSize: -1, // see NM__onResponseHeader()
+            bodySize: -1,
+          },
+          timings: {}, // see NM__onTransactionClose()
+        }],
+      },
+    };
+  },
+
+  _setupResponseListener: function NM__setupResponseListener(aHttpActivity)
+  {
+    let channel = aHttpActivity.channel;
+    channel.QueryInterface(Ci.nsITraceableChannel);
+
+    // The response will be written into the outputStream of this pipe.
+    // This allows us to buffer the data we are receiving and read it
+    // asynchronously.
+    // Both ends of the pipe must be blocking.
+    let sink = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
+
+    // The streams need to be blocking because this is required by the
+    // stream tee.
+    sink.init(false, false, this.responsePipeSegmentSize, PR_UINT32_MAX, null);
+
+    // Add listener for the response body.
+    let newListener = new NetworkResponseListener(aHttpActivity);
+
+    // Remember the input stream, so it isn't released by GC.
+    newListener.inputStream = sink.inputStream;
+    newListener.sink = sink;
+
+    let tee = Cc["@mozilla.org/network/stream-listener-tee;1"].
+              createInstance(Ci.nsIStreamListenerTee);
+
+    let originalListener = channel.setNewListener(tee);
+
+    tee.init(originalListener, sink.outputStream, newListener);
+  },
+
+  _sendMessageToChrome: function NM__sendMessageToChrome(aHttpActivity)
+  {
+    dump("_sendMessageToChrome " + aHttpActivity.stage + "\n");
+    sendAsyncMessage("WebConsole:NetworkActivity", {
+      hudId: aHttpActivity.hudId,
+      id: JSTerm.sequenceId,
+      stage: aHttpActivity.stage,
+      log: aHttpActivity.log,
+    });
+  },
+
+  _onRequestBodySent: function NM__onRequestBodySent(aHttpActivity)
+  {
+    dump("NM__onRequestBodySent\n");
+
+    if (aHttpActivity.discardRequestBody) {
+      dump("NM__onRequestBodySent body discarded\n");
+      return;
+    }
+
+    let request = aHttpActivity.log.entries[0].request;
+
+    let sentBody = NetworkHelper.
+                   readPostTextFromRequest(aHttpActivity.channel,
+                                           aHttpActivity.charset);
+
+    if (!sentBody && request.url == JSTerm.window.location.href) {
+      // If the request URL is the same as the current page url, then
+      // we can try to get the posted text from the page directly.
+      // This check is necessary as otherwise the
+      //   NetworkHelper.readPostTextFromPage
+      // function is called for image requests as well but these
+      // are not web pages and as such don't store the posted text
+      // in the cache of the webpage.
+      sentBody = NetworkHelper.readPostTextFromPage(docShell,
+                                                    aHttpActivity.charset);
+    }
+    if (!sentBody) {
+      return;
+    }
+
+    request.postData = {
+      mimeType: "",
+      params: [],
+      text: sentBody,
+      // could add mimeType and params
+    };
+
+    // TODO: this might not be accurate! this should be the size before
+    // decompression, according to the HAR spec.
+    request.bodySize = sentBody.length;
+
+    // TODO: decide how we handle request and response bodies
+    this._sendMessageToChrome(aHttpActivity);
+  },
+
+  _onResponseHeader:
+  function NM__onResponseHeader(aHttpActivity, aExtraStringData)
+  {
+    // aExtraStringData contains the uncached response headers. The first line
+    // contains the response status (e.g. HTTP/1.1 200 OK).
+    //
+    // Note: The response header is not saved here. Calling the
+    // aChannel.visitResponseHeaders() at this point sometimes causes an
+    // NS_ERROR_NOT_AVAILABLE exception.
+    //
+    // We could parse aExtraStringData to get the headers and their values, but
+    // that is not trivial to do in an accurate manner. Hence, we save the
+    // response headers in this.httpResponseExaminer().
+    dump("NM__onResponseHeader\n");
+
+    let response = aHttpActivity.log.entries[0].response;
+
+    let headers = aExtraStringData.split(/\r\n|\n|\r/);
+    let statusLine = headers.shift();
+
+    let statusLineArray = statusLine.split(" ");
+    response.httpVersion = statusLineArray.shift();
+    response.status = statusLineArray.shift();
+    response.statusText = statusLineArray.join(" ");
+    response.headersSize = aExtraStringData.length;
+
+    // Discard the response body for known response statuses.
+    switch (response.status) {
+      case HTTP_MOVED_PERMANENTLY:
+      case HTTP_FOUND:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMPORARY_REDIRECT:
+        aHttpActivity.discardResponseBody = true;
+        break;
+    }
+
+    dump("NM__onResponseHeader statusLine '" + statusLine + "' response.httpVersion '" + response.httpVersion + "' '" + response.status + "' '" + response.statusText + "'\n");
+
+    this._sendMessageToChrome(aHttpActivity);
+  },
+
+  _parseCookieHeader: function NM__parseCookieHeader(aHeader)
+  {
+    let cookies = aHeader.split(";");
+    let result = [];
+
+    cookies.forEach(function(aCookie) {
+      let [name, value] = aCookie.split("=");
+      result.push({name: unescape(name.trim()),
+                   value: unescape(value.trim())});
+
+      let last = result[result.length - 1];
+    });
+
+    return result;
+  },
+
+  _parseSetCookieHeader: function NM__parseCookieHeader(aHeader)
+  {
+    let rawCookies = aHeader.split(/\r\n|\n|\r/);
+    let cookies = [];
+
+    rawCookies.forEach(function(aCookie) {
+      let name = unescape(aCookie.substr(0, aCookie.indexOf("=")).trim());
+      let parts = aCookie.substr(aCookie.indexOf("=") + 1).split(";");
+      let value = unescape(parts.shift().trim());
+
+      let cookie = {name: name, value: value};
+
+      parts.forEach(function(aPart) {
+        let part = aPart.trim();
+        if (part.toLowerCase() == "secure") {
+          cookie.secure = true;
+        }
+        else if (part.toLowerCase() == "httponly") {
+          cookie.httpOnly = true;
+        }
+        else if (part.indexOf("=") > -1) {
+          let pair = part.split("=");
+          pair[0] = pair[0].toLowerCase();
+          if (pair[0] == "path" || pair[0] == "domain") {
+            cookie[pair[0]] = pair[1];
+          }
+          else if (pair[0] == "expires") {
+            try {
+              pair[1] = pair[1].replace(/-/g, ' ');
+              cookie.expires = new Date(pair[1]).toISOString();
+            }
+            catch (ex) { }
+          }
+        }
+      });
+
+      cookies.push(cookie);
+    });
+
+    return cookies;
+  },
+
+  _onTransactionClose: function NM__onTransactionClose(aHttpActivity)
+  {
+    this._setupHarTimings(aHttpActivity);
+
+    let entry = aHttpActivity.log.entries[0];
+
+    dump("_onTransactionClose total " + entry.time + "ms\n");
+
+    this._sendMessageToChrome(aHttpActivity);
+
+    delete this.openRequests[aHttpActivity.id];
+  },
+
+  _setupHarTimings: function NM__setupHarTimings(aHttpActivity)
+  {
+    let timings = aHttpActivity.timings;
+    let entry = aHttpActivity.log.entries[0];
+    // TODO: compare this logic to Firebug
+    let harTimings = entry.timings;
+    harTimings.blocked = -1;
+    harTimings.dns = timings.STATUS_RESOLVING ?
+                     timings.STATUS_RESOLVED.last -
+                     timings.STATUS_RESOLVING.first : -1;
+    harTimings.connect = timings.STATUS_CONNECTED_TO.last -
+                         timings.STATUS_CONNECTING_TO.first;
+    harTimings.send = (timings.STATUS_WAITING_FOR || timings.STATUS_RECEIVING_FROM).first -
+                      timings.STATUS_CONNECTED_TO.last;
+    harTimings.wait = timings.RESPONSE_START.first -
+                      (timings.REQUEST_BODY_SENT || timings.STATUS_SENDING_TO).last;
+    harTimings.receive = timings.RESPONSE_COMPLETE.last -
+                         timings.RESPONSE_START.first;
+
+    //dump("harTimings1 dns " + harTimings.dns + " connect " + harTimings.connect + " send " + harTimings.send + " wait " + harTimings.wait + " receive " + harTimings.receive + "\n");
+
+    entry.time = 0;
+    for (let timing in harTimings) {
+      let time = Math.max(Math.round(harTimings[timing] / 1000), -1);
+      harTimings[timing] = time;
+      if (time > -1) {
+        entry.time += time;
+      }
+    }
+
+    dump("harTimings2 dns " + harTimings.dns + " connect " + harTimings.connect + " send " + harTimings.send + " wait " + harTimings.wait + " receive " + harTimings.receive + "\n");
+    dump("expected total " + Math.round((timings.TRANSACTION_CLOSE.last - timings.REQUEST_HEADER.first)/1000) + " ms\n");
+  },
+
+  /**
+   * Suspend Web Console activity. This is called when all Web Consoles are
+   * closed.
+   *
+   * @returns void
+   */
+  destroy: function NM_destroy()
+  {
+    dump("NM_destroy\n");
+
+    Services.obs.removeObserver(this.httpResponseExaminer,
+                                "http-on-examine-response");
+
+    activityDistributor.removeObserver(this);
+
+    this.openRequests = {};
+
+    //FIXME
+    //browser.webProgress.removeProgressListener(hud.progressListener);
+  },
+};
+
+/**
+ * A WebProgressListener that listens for location changes, to update HUDService
+ * state information on page navigation.
+ *
+ * @constructor
+ * @param string aHudId
+ *        The HeadsUpDisplay ID.
+ */
+function ConsoleProgressListener(aHudId)
+{
+  this.hudId = aHudId;
+}
+
+// TODO: update for e10s
+ConsoleProgressListener.prototype = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
+                                         Ci.nsISupportsWeakReference]),
+
+  onStateChange: function CPL_onStateChange(aProgress, aRequest, aState,
+                                            aStatus)
+  {
+    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
+      return;
+    }
+
+    let uri = null;
+    if (aRequest instanceof Ci.imgIRequest) {
+      let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
+      uri = imgIRequest.URI;
+    }
+    else if (aRequest instanceof Ci.nsIChannel) {
+      let nsIChannel = aRequest.QueryInterface(Ci.nsIChannel);
+      uri = nsIChannel.URI;
+    }
+
+    if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
+      return;
+    }
+
+    let outputNode = HUDService.hudReferences[this.hudId].outputNode;
+
+    let chromeDocument = outputNode.ownerDocument;
+    let msgNode = chromeDocument.createElementNS(HTML_NS, "html:span");
+
+    // Create the clickable URL part of the message.
+    let linkNode = chromeDocument.createElementNS(HTML_NS, "html:span");
+    linkNode.appendChild(chromeDocument.createTextNode(uri.spec));
+    linkNode.classList.add("hud-clickable");
+    linkNode.classList.add("webconsole-msg-url");
+
+    linkNode.addEventListener("mousedown", function(aEvent) {
+      this._startX = aEvent.clientX;
+      this._startY = aEvent.clientY;
+    }, false);
+
+    linkNode.addEventListener("click", function(aEvent) {
+      if (aEvent.detail == 1 && aEvent.button == 0 &&
+          this._startX == aEvent.clientX && this._startY == aEvent.clientY) {
+        let viewSourceUtils = chromeDocument.defaultView.gViewSourceUtils;
+        viewSourceUtils.viewSource(uri.spec, null, chromeDocument);
+      }
+    }, false);
+
+    msgNode.appendChild(linkNode);
+
+    let messageNode = ConsoleUtils.createMessageNode(chromeDocument,
+                                                     CATEGORY_NETWORK,
+                                                     SEVERITY_LOG,
+                                                     msgNode,
+                                                     null,
+                                                     null,
+                                                     uri.spec);
+
+    ConsoleUtils.outputMessageNode(messageNode, this.hudId);
+  },
+
+  onLocationChange: function() {},
+  onStatusChange: function() {},
+  onProgressChange: function() {},
+  onSecurityChange: function() {},
+};
+
+JSTerm.init();
+})();
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -40,113 +40,105 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+dump("HUDService init 0\n");
+
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 const CONSOLEAPI_CLASS_ID = "{b49c18f8-3379-4fc0-8c90-d7772c1a9ff3}";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource:///modules/NetworkHelper.jsm");
-Cu.import("resource:///modules/PropertyPanel.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
 
-XPCOMUtils.defineLazyServiceGetter(this, "scriptError",
-                                   "@mozilla.org/scripterror;1",
-                                   "nsIScriptError");
-
-XPCOMUtils.defineLazyServiceGetter(this, "activityDistributor",
-                                   "@mozilla.org/network/http-activity-distributor;1",
-                                   "nsIHttpActivityDistributor");
-
-XPCOMUtils.defineLazyServiceGetter(this, "mimeService",
-                                   "@mozilla.org/mime;1",
-                                   "nsIMIMEService");
-
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
 XPCOMUtils.defineLazyGetter(this, "gcli", function () {
   var obj = {};
   Cu.import("resource:///modules/gcli.jsm", obj);
   return obj.gcli;
 });
 
 XPCOMUtils.defineLazyGetter(this, "CssRuleView", function() {
   let tmp = {};
   Cu.import("resource:///modules/devtools/CssRuleView.jsm", tmp);
   return tmp.CssRuleView;
 });
 
-XPCOMUtils.defineLazyGetter(this, "NetUtil", function () {
-  var obj = {};
-  Cu.import("resource://gre/modules/NetUtil.jsm", obj);
-  return obj.NetUtil;
-});
-
 XPCOMUtils.defineLazyGetter(this, "template", function () {
   var obj = {};
   Cu.import("resource:///modules/devtools/Templater.jsm", obj);
   return obj.template;
 });
 
 XPCOMUtils.defineLazyGetter(this, "PropertyPanel", function () {
   var obj = {};
   try {
     Cu.import("resource:///modules/PropertyPanel.jsm", obj);
   } catch (err) {
     Cu.reportError(err);
   }
   return obj.PropertyPanel;
 });
 
+XPCOMUtils.defineLazyGetter(this, "PropertyTreeView", function () {
+  let obj = {};
+  Cu.import("resource:///modules/PropertyPanel.jsm", obj);
+  return obj.PropertyTreeView;
+});
+
 XPCOMUtils.defineLazyGetter(this, "AutocompletePopup", function () {
   var obj = {};
   try {
     Cu.import("resource:///modules/AutocompletePopup.jsm", obj);
   }
   catch (err) {
     Cu.reportError(err);
   }
   return obj.AutocompletePopup;
 });
 
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function() {
+  return WebConsoleUtils.l10n;
+});
+
+XPCOMUtils.defineLazyGetter(this, "NetworkPanel", function () {
+  let obj = {};
+  Cu.import("resource:///modules/NetworkPanel.jsm", obj);
+  return obj.NetworkPanel;
+});
+
 XPCOMUtils.defineLazyGetter(this, "ScratchpadManager", function () {
   var obj = {};
   try {
     Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", obj);
   }
   catch (err) {
     Cu.reportError(err);
   }
   return obj.ScratchpadManager;
 });
 
-XPCOMUtils.defineLazyGetter(this, "namesAndValuesOf", function () {
-  var obj = {};
-  Cu.import("resource:///modules/PropertyPanel.jsm", obj);
-  return obj.namesAndValuesOf;
-});
-
-XPCOMUtils.defineLazyGetter(this, "gConsoleStorage", function () {
-  let obj = {};
-  Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", obj);
-  return obj.ConsoleAPIStorage;
-});
-
 function LogFactory(aMessagePrefix)
 {
   function log(aMessage) {
     var _msg = aMessagePrefix + " " + aMessage + "\n";
     dump(_msg);
   }
   return log;
 }
@@ -166,22 +158,16 @@ function loadCommands() {
   Cu.import("resource:///modules/GcliCommands.jsm", commandExports);
   Cu.import("resource:///modules/GcliTiltCommands.jsm", commandExports);
 
   return commandExports;
 }
 
 let log = LogFactory("*** HUDService:");
 
-const HUD_STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
-
-XPCOMUtils.defineLazyGetter(this, "stringBundle", function () {
-  return Services.strings.createBundle(HUD_STRINGS_URI);
-});
-
 // The amount of time in milliseconds that must pass between messages to
 // trigger the display of a new group.
 const NEW_GROUP_DELAY = 5000;
 
 // The amount of time in milliseconds that we wait before performing a live
 // search.
 const SEARCH_DELAY = 200;
 
@@ -210,33 +196,28 @@ const SEVERITY_LOG = 3;
 // severities.
 const LEVELS = {
   error: SEVERITY_ERROR,
   warn: SEVERITY_WARNING,
   info: SEVERITY_INFO,
   log: SEVERITY_LOG,
   trace: SEVERITY_LOG,
   dir: SEVERITY_LOG,
+  debug: SEVERITY_LOG,
   group: SEVERITY_LOG,
   groupCollapsed: SEVERITY_LOG,
   groupEnd: SEVERITY_LOG,
   time: SEVERITY_LOG,
   timeEnd: SEVERITY_LOG
 };
 
 // The lowest HTTP response code (inclusive) that is considered an error.
 const MIN_HTTP_ERROR_CODE = 400;
-// The highest HTTP response code (exclusive) that is considered an error.
-const MAX_HTTP_ERROR_CODE = 600;
-
-// HTTP status codes.
-const HTTP_MOVED_PERMANENTLY = 301;
-const HTTP_FOUND = 302;
-const HTTP_SEE_OTHER = 303;
-const HTTP_TEMPORARY_REDIRECT = 307;
+// The highest HTTP response code (inclusive) that is considered an error.
+const MAX_HTTP_ERROR_CODE = 599;
 
 // The HTML namespace.
 const HTML_NS = "http://www.w3.org/1999/xhtml";
 
 // The XUL namespace.
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 // The fragment of a CSS class name that identifies each category.
@@ -275,324 +256,43 @@ const MESSAGE_PREFERENCE_KEYS = [
 // Possible directions that can be passed to HUDService.animate().
 const ANIMATE_OUT = 0;
 const ANIMATE_IN = 1;
 
 // Constants used for defining the direction of JSTerm input history navigation.
 const HISTORY_BACK = -1;
 const HISTORY_FORWARD = 1;
 
-// The maximum number of bytes a Network ResponseListener can hold.
-const RESPONSE_BODY_LIMIT = 1024*1024; // 1 MB
-
-// The maximum uint32 value.
-const PR_UINT32_MAX = 4294967295;
-
 // Minimum console height, in pixels.
 const MINIMUM_CONSOLE_HEIGHT = 150;
 
 // Minimum page height, in pixels. This prevents the Web Console from
 // remembering a height that covers the whole page.
 const MINIMUM_PAGE_HEIGHT = 50;
 
 // The default console height, as a ratio from the content window inner height.
 const DEFAULT_CONSOLE_HEIGHT = 0.33;
 
-// Constant used when checking the typeof objects.
-const TYPEOF_FUNCTION = "function";
+// This script is inserted into the content process.
+const CONTENT_SCRIPT_URL = "chrome://browser/content/devtools/HUDService-content.js";
 
 const ERRORS = { LOG_MESSAGE_MISSING_ARGS:
                  "Missing arguments: aMessage, aConsoleNode and aMessageNode are required.",
                  CANNOT_GET_HUD: "Cannot getHeads Up Display with provided ID",
                  MISSING_ARGS: "Missing arguments",
                  LOG_OUTPUT_FAILED: "Log Failure: Could not append messageNode to outputNode",
 };
 
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 // The pref prefix for webconsole filters
 const PREFS_PREFIX = "devtools.webconsole.filter.";
 
 /**
- * Implements the nsIStreamListener and nsIRequestObserver interface. Used
- * within the HS_httpObserverFactory function to get the response body of
- * requests.
- *
- * The code is mostly based on code listings from:
- *
- *   http://www.softwareishard.com/blog/firebug/
- *      nsitraceablechannel-intercept-http-traffic/
- *
- * @param object aHttpActivity
- *        HttpActivity object associated with this request (see
- *        HS_httpObserverFactory). As the response is done, the response header,
- *        body and status is stored on aHttpActivity.
- */
-function ResponseListener(aHttpActivity) {
-  this.receivedData = "";
-  this.httpActivity = aHttpActivity;
-}
-
-ResponseListener.prototype =
-{
-  /**
-   * The response will be written into the outputStream of this nsIPipe.
-   * Both ends of the pipe must be blocking.
-   */
-  sink: null,
-
-  /**
-   * The HttpActivity object associated with this response.
-   */
-  httpActivity: null,
-
-  /**
-   * Stores the received data as a string.
-   */
-  receivedData: null,
-
-  /**
-   * The nsIRequest we are started for.
-   */
-  request: null,
-
-  /**
-   * Sets the httpActivity object's response header if it isn't set already.
-   *
-   * @param nsIRequest aRequest
-   */
-  setResponseHeader: function RL_setResponseHeader(aRequest)
-  {
-    let httpActivity = this.httpActivity;
-    // Check if the header isn't set yet.
-    if (!httpActivity.response.header) {
-      if (aRequest instanceof Ci.nsIHttpChannel) {
-      httpActivity.response.header = {};
-        try {
-        aRequest.visitResponseHeaders({
-          visitHeader: function(aName, aValue) {
-            httpActivity.response.header[aName] = aValue;
-          }
-        });
-      }
-        // Accessing the response header can throw an NS_ERROR_NOT_AVAILABLE
-        // exception. Catch it and stop it to make it not show up in the.
-        // This can happen if the response is not finished yet and the user
-        // reloades the page.
-        catch (ex) {
-          delete httpActivity.response.header;
-        }
-      }
-    }
-  },
-
-  /**
-   * Set the async listener for the given nsIAsyncInputStream. This allows us to
-   * wait asynchronously for any data coming from the stream.
-   *
-   * @param nsIAsyncInputStream aStream
-   *        The input stream from where we are waiting for data to come in.
-   *
-   * @param nsIInputStreamCallback aListener
-   *        The input stream callback you want. This is an object that must have
-   *        the onInputStreamReady() method. If the argument is null, then the
-   *        current callback is removed.
-   *
-   * @returns void
-   */
-  setAsyncListener: function RL_setAsyncListener(aStream, aListener)
-  {
-    // Asynchronously wait for the stream to be readable or closed.
-    aStream.asyncWait(aListener, 0, 0, Services.tm.mainThread);
-  },
-
-  /**
-   * Stores the received data, if request/response body logging is enabled. It
-   * also does limit the number of stored bytes, based on the
-   * RESPONSE_BODY_LIMIT constant.
-   *
-   * Learn more about nsIStreamListener at:
-   * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIStreamListener
-   *
-   * @param nsIRequest aRequest
-   * @param nsISupports aContext
-   * @param nsIInputStream aInputStream
-   * @param unsigned long aOffset
-   * @param unsigned long aCount
-   */
-  onDataAvailable: function RL_onDataAvailable(aRequest, aContext, aInputStream,
-                                               aOffset, aCount)
-  {
-    this.setResponseHeader(aRequest);
-
-    let data = NetUtil.readInputStreamToString(aInputStream, aCount);
-
-    if (!this.httpActivity.response.bodyDiscarded &&
-        this.receivedData.length < RESPONSE_BODY_LIMIT) {
-      this.receivedData += NetworkHelper.
-                           convertToUnicode(data, aRequest.contentCharset);
-    }
-  },
-
-  /**
-   * See documentation at
-   * https://developer.mozilla.org/En/NsIRequestObserver
-   *
-   * @param nsIRequest aRequest
-   * @param nsISupports aContext
-   */
-  onStartRequest: function RL_onStartRequest(aRequest, aContext)
-  {
-    this.request = aRequest;
-
-    // Always discard the response body if logging is not enabled in the Web
-    // Console.
-    this.httpActivity.response.bodyDiscarded =
-      !HUDService.saveRequestAndResponseBodies;
-
-    // Check response status and discard the body for redirects.
-    if (!this.httpActivity.response.bodyDiscarded &&
-        this.httpActivity.channel instanceof Ci.nsIHttpChannel) {
-      switch (this.httpActivity.channel.responseStatus) {
-        case HTTP_MOVED_PERMANENTLY:
-        case HTTP_FOUND:
-        case HTTP_SEE_OTHER:
-        case HTTP_TEMPORARY_REDIRECT:
-          this.httpActivity.response.bodyDiscarded = true;
-          break;
-      }
-    }
-
-    // Asynchronously wait for the data coming from the request.
-    this.setAsyncListener(this.sink.inputStream, this);
-  },
-
-  /**
-   * Handle the onStopRequest by storing the response header is stored on the
-   * httpActivity object. The sink output stream is also closed.
-   *
-   * For more documentation about nsIRequestObserver go to:
-   * https://developer.mozilla.org/En/NsIRequestObserver
-   *
-   * @param nsIRequest aRequest
-   *        The request we are observing.
-   * @param nsISupports aContext
-   * @param nsresult aStatusCode
-   */
-  onStopRequest: function RL_onStopRequest(aRequest, aContext, aStatusCode)
-  {
-    // Retrieve the response headers, as they are, from the server.
-    let response = null;
-    for each (let item in HUDService.openResponseHeaders) {
-      if (item.channel === this.httpActivity.channel) {
-        response = item;
-        break;
-      }
-    }
-
-    if (response) {
-      this.httpActivity.response.header = response.headers;
-      delete HUDService.openResponseHeaders[response.id];
-    }
-    else {
-      this.setResponseHeader(aRequest);
-    }
-
-    this.sink.outputStream.close();
-  },
-
-  /**
-   * Clean up the response listener once the response input stream is closed.
-   * This is called from onStopRequest() or from onInputStreamReady() when the
-   * stream is closed.
-   *
-   * @returns void
-   */
-  onStreamClose: function RL_onStreamClose()
-  {
-    if (!this.httpActivity) {
-      return;
-    }
-
-    // Remove our listener from the request input stream.
-    this.setAsyncListener(this.sink.inputStream, null);
-
-    if (!this.httpActivity.response.bodyDiscarded &&
-        HUDService.saveRequestAndResponseBodies) {
-      this.httpActivity.response.body = this.receivedData;
-    }
-
-    if (HUDService.lastFinishedRequestCallback) {
-      HUDService.lastFinishedRequestCallback(this.httpActivity);
-    }
-
-    // Call update on all panels.
-    this.httpActivity.panels.forEach(function(weakRef) {
-      let panel = weakRef.get();
-      if (panel) {
-        panel.update();
-      }
-    });
-    this.httpActivity.response.isDone = true;
-    this.httpActivity = null;
-    this.receivedData = "";
-    this.request = null;
-    this.sink = null;
-    this.inputStream = null;
-  },
-
-  /**
-   * The nsIInputStreamCallback for when the request input stream is ready -
-   * either it has more data or it is closed.
-   *
-   * @param nsIAsyncInputStream aStream
-   *        The sink input stream from which data is coming.
-   *
-   * @returns void
-   */
-  onInputStreamReady: function RL_onInputStreamReady(aStream)
-  {
-    if (!(aStream instanceof Ci.nsIAsyncInputStream) || !this.httpActivity) {
-      return;
-    }
-
-    let available = -1;
-    try {
-      // This may throw if the stream is closed normally or due to an error.
-      available = aStream.available();
-    }
-    catch (ex) { }
-
-    if (available != -1) {
-      if (available != 0) {
-        // Note that passing 0 as the offset here is wrong, but the
-        // onDataAvailable() method does not use the offset, so it does not
-        // matter.
-        this.onDataAvailable(this.request, null, aStream, 0, available);
-      }
-      this.setAsyncListener(aStream, this);
-    }
-    else {
-      this.onStreamClose();
-    }
-  },
-
-  QueryInterface: XPCOMUtils.generateQI([
-    Ci.nsIStreamListener,
-    Ci.nsIInputStreamCallback,
-    Ci.nsIRequestObserver,
-    Ci.nsISupports,
-  ])
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// Helper for creating the network panel.
-
-/**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
  *
  * @param nsIDOMDocument aDocument
  *        Document to create the new DOMNode.
  * @param string aTag
  *        Name of the tag for the DOMNode.
  * @param object aAttributes
@@ -606,662 +306,16 @@ function createElement(aDocument, aTag, 
   if (aAttributes) {
     for (let attr in aAttributes) {
       node.setAttribute(attr, aAttributes[attr]);
     }
   }
   return node;
 }
 
-/**
- * Creates a new DOMNode and appends it to aParent.
- *
- * @param nsIDOMNode aParent
- *        A parent node to append the created element.
- * @param string aTag
- *        Name of the tag for the DOMNode.
- * @param object aAttributes
- *        Attributes set on the created DOMNode.
- *
- * @returns nsIDOMNode
- */
-function createAndAppendElement(aParent, aTag, aAttributes)
-{
-  let node = createElement(aParent.ownerDocument, aTag, aAttributes);
-  aParent.appendChild(node);
-  return node;
-}
-
-/**
- * Convenience function to unwrap a wrapped object.
- *
- * @param aObject the object to unwrap
- */
-
-function unwrap(aObject)
-{
-  try {
-    return XPCNativeWrapper.unwrap(aObject);
-  } catch(e) {
-    return aObject;
-  }
-}
-
-///////////////////////////////////////////////////////////////////////////
-//// NetworkPanel
-
-/**
- * Creates a new NetworkPanel.
- *
- * @param nsIDOMNode aParent
- *        Parent node to append the created panel to.
- * @param object aHttpActivity
- *        HttpActivity to display in the panel.
- */
-function NetworkPanel(aParent, aHttpActivity)
-{
-  let doc = aParent.ownerDocument;
-  this.httpActivity = aHttpActivity;
-
-  // Create the underlaying panel
-  this.panel = createElement(doc, "panel", {
-    label: HUDService.getStr("NetworkPanel.label"),
-    titlebar: "normal",
-    noautofocus: "true",
-    noautohide: "true",
-    close: "true"
-  });
-
-  // Create the iframe that displays the NetworkPanel XHTML.
-  this.iframe = createAndAppendElement(this.panel, "iframe", {
-    src: "chrome://browser/content/NetworkPanel.xhtml",
-    type: "content",
-    flex: "1"
-  });
-
-  let self = this;
-
-  // Destroy the panel when it's closed.
-  this.panel.addEventListener("popuphidden", function onPopupHide() {
-    self.panel.removeEventListener("popuphidden", onPopupHide, false);
-    self.panel.parentNode.removeChild(self.panel);
-    self.panel = null;
-    self.iframe = null;
-    self.document = null;
-    self.httpActivity = null;
-
-    if (self.linkNode) {
-      self.linkNode._panelOpen = false;
-      self.linkNode = null;
-    }
-  }, false);
-
-  // Set the document object and update the content once the panel is loaded.
-  this.panel.addEventListener("load", function onLoad() {
-    self.panel.removeEventListener("load", onLoad, true);
-    self.document = self.iframe.contentWindow.document;
-    self.update();
-  }, true);
-
-  // Create the footer.
-  let footer = createElement(doc, "hbox", { align: "end" });
-  createAndAppendElement(footer, "spacer", { flex: 1 });
-
-  createAndAppendElement(footer, "resizer", { dir: "bottomend" });
-  this.panel.appendChild(footer);
-
-  aParent.appendChild(this.panel);
-}
-
-NetworkPanel.prototype =
-{
-  /**
-   * Callback is called once the NetworkPanel is processed completly. Used by
-   * unit tests.
-   */
-  isDoneCallback: null,
-
-  /**
-   * The current state of the output.
-   */
-  _state: 0,
-
-  /**
-   * State variables.
-   */
-  _INIT: 0,
-  _DISPLAYED_REQUEST_HEADER: 1,
-  _DISPLAYED_REQUEST_BODY: 2,
-  _DISPLAYED_RESPONSE_HEADER: 3,
-  _TRANSITION_CLOSED: 4,
-
-  _fromDataRegExp: /Content-Type\:\s*application\/x-www-form-urlencoded/,
-
-  /**
-   * Small helper function that is nearly equal to  HUDService.getFormatStr
-   * except that it prefixes aName with "NetworkPanel.".
-   *
-   * @param string aName
-   *        The name of an i10n string to format. This string is prefixed with
-   *        "NetworkPanel." before calling the HUDService.getFormatStr function.
-   * @param array aArray
-   *        Values used as placeholder for the i10n string.
-   * @returns string
-   *          The i10n formated string.
-   */
-  _format: function NP_format(aName, aArray)
-  {
-    return HUDService.getFormatStr("NetworkPanel." + aName, aArray);
-  },
-
-  /**
-   * Returns the content type of the response body. This is based on the
-   * response.header["Content-Type"] info. If this value is not available, then
-   * the content type is tried to be estimated by the url file ending.
-   *
-   * @returns string or null
-   *          Content type or null if no content type could be figured out.
-   */
-  get _contentType()
-  {
-    let response = this.httpActivity.response;
-    let contentTypeValue = null;
-
-    if (response.header && response.header["Content-Type"]) {
-      let types = response.header["Content-Type"].split(/,|;/);
-      for (let i = 0; i < types.length; i++) {
-        let type = NetworkHelper.mimeCategoryMap[types[i]];
-        if (type) {
-          return types[i];
-        }
-      }
-    }
-
-    // Try to get the content type from the request file extension.
-    let uri = NetUtil.newURI(this.httpActivity.url);
-    let mimeType = null;
-    if ((uri instanceof Ci.nsIURL) && uri.fileExtension) {
-      try {
-        mimeType = mimeService.getTypeFromExtension(uri.fileExtension);
-      } catch(e) {
-        // Added to prevent failures on OS X 64. No Flash?
-        Cu.reportError(e);
-        // Return empty string to pass unittests.
-        return "";
-      }
-    }
-    return mimeType;
-  },
-
-  /**
-   *
-   * @returns boolean
-   *          True if the response is an image, false otherwise.
-   */
-  get _responseIsImage()
-  {
-    return NetworkHelper.mimeCategoryMap[this._contentType] == "image";
-  },
-
-  /**
-   *
-   * @returns boolean
-   *          True if the response body contains text, false otherwise.
-   */
-  get _isResponseBodyTextData()
-  {
-    let contentType = this._contentType;
-
-    if (!contentType)
-      return false;
-
-    if (contentType.indexOf("text/") == 0) {
-      return true;
-    }
-
-    switch (NetworkHelper.mimeCategoryMap[contentType]) {
-      case "txt":
-      case "js":
-      case "json":
-      case "css":
-      case "html":
-      case "svg":
-      case "xml":
-        return true;
-
-      default:
-        return false;
-    }
-  },
-
-  /**
-   *
-   * @returns boolean
-   *          Returns true if the server responded that the request is already
-   *          in the browser's cache, false otherwise.
-   */
-  get _isResponseCached()
-  {
-    return this.httpActivity.response.status.indexOf("304") != -1;
-  },
-
-  /**
-   *
-   * @returns boolean
-   *          Returns true if the posted body contains form data.
-   */
-  get _isRequestBodyFormData()
-  {
-    let requestBody = this.httpActivity.request.body;
-    return this._fromDataRegExp.test(requestBody);
-  },
-
-  /**
-   * Appends the node with id=aId by the text aValue.
-   *
-   * @param string aId
-   * @param string aValue
-   * @returns void
-   */
-  _appendTextNode: function NP_appendTextNode(aId, aValue)
-  {
-    let textNode = this.document.createTextNode(aValue);
-    this.document.getElementById(aId).appendChild(textNode);
-  },
-
-  /**
-   * Generates some HTML to display the key-value pair of the aList data. The
-   * generated HTML is added to node with id=aParentId.
-   *
-   * @param string aParentId
-   *        Id of the parent node to append the list to.
-   * @oaram object aList
-   *        Object that holds the key-value information to display in aParentId.
-   * @param boolean aIgnoreCookie
-   *        If true, the key-value named "Cookie" is not added to the list.
-   * @returns void
-   */
-  _appendList: function NP_appendList(aParentId, aList, aIgnoreCookie)
-  {
-    let parent = this.document.getElementById(aParentId);
-    let doc = this.document;
-
-    let sortedList = {};
-    Object.keys(aList).sort().forEach(function(aKey) {
-      sortedList[aKey] = aList[aKey];
-    });
-
-    for (let key in sortedList) {
-      if (aIgnoreCookie && key == "Cookie") {
-        continue;
-      }
-
-      /**
-       * The following code creates the HTML:
-       * <tr>
-       * <th scope="row" class="property-name">${line}:</th>
-       * <td class="property-value">${aList[line]}</td>
-       * </tr>
-       * and adds it to parent.
-       */
-      let row = doc.createElement("tr");
-      let textNode = doc.createTextNode(key + ":");
-      let th = doc.createElement("th");
-      th.setAttribute("scope", "row");
-      th.setAttribute("class", "property-name");
-      th.appendChild(textNode);
-      row.appendChild(th);
-
-      textNode = doc.createTextNode(sortedList[key]);
-      let td = doc.createElement("td");
-      td.setAttribute("class", "property-value");
-      td.appendChild(textNode);
-      row.appendChild(td);
-
-      parent.appendChild(row);
-    }
-  },
-
-  /**
-   * Displays the node with id=aId.
-   *
-   * @param string aId
-   * @returns void
-   */
-  _displayNode: function NP_displayNode(aId)
-  {
-    this.document.getElementById(aId).style.display = "block";
-  },
-
-  /**
-   * Sets the request URL, request method, the timing information when the
-   * request started and the request header content on the NetworkPanel.
-   * If the request header contains cookie data, a list of sent cookies is
-   * generated and a special sent cookie section is displayed + the cookie list
-   * added to it.
-   *
-   * @returns void
-   */
-  _displayRequestHeader: function NP_displayRequestHeader()
-  {
-    let timing = this.httpActivity.timing;
-    let request = this.httpActivity.request;
-
-    this._appendTextNode("headUrl", this.httpActivity.url);
-    this._appendTextNode("headMethod", this.httpActivity.method);
-
-    this._appendTextNode("requestHeadersInfo",
-      ConsoleUtils.timestampString(timing.REQUEST_HEADER/1000));
-
-    this._appendList("requestHeadersContent", request.header, true);
-
-    if ("Cookie" in request.header) {
-      this._displayNode("requestCookie");
-
-      let cookies = request.header.Cookie.split(";");
-      let cookieList = {};
-      let cookieListSorted = {};
-      cookies.forEach(function(cookie) {
-        let name, value;
-        [name, value] = cookie.trim().split("=");
-        cookieList[name] = value;
-      });
-      this._appendList("requestCookieContent", cookieList);
-    }
-  },
-
-  /**
-   * Displays the request body section of the NetworkPanel and set the request
-   * body content on the NetworkPanel.
-   *
-   * @returns void
-   */
-  _displayRequestBody: function NP_displayRequestBody() {
-    this._displayNode("requestBody");
-    this._appendTextNode("requestBodyContent", this.httpActivity.request.body);
-  },
-
-  /*
-   * Displays the `sent form data` section. Parses the request header for the
-   * submitted form data displays it inside of the `sent form data` section.
-   *
-   * @returns void
-   */
-  _displayRequestForm: function NP_processRequestForm() {
-    let requestBodyLines = this.httpActivity.request.body.split("\n");
-    let formData = requestBodyLines[requestBodyLines.length - 1].
-                      replace(/\+/g, " ").split("&");
-
-    function unescapeText(aText)
-    {
-      try {
-        return decodeURIComponent(aText);
-      }
-      catch (ex) {
-        return decodeURIComponent(unescape(aText));
-      }
-    }
-
-    let formDataObj = {};
-    for (let i = 0; i < formData.length; i++) {
-      let data = formData[i];
-      let idx = data.indexOf("=");
-      let key = data.substring(0, idx);
-      let value = data.substring(idx + 1);
-      formDataObj[unescapeText(key)] = unescapeText(value);
-    }
-
-    this._appendList("requestFormDataContent", formDataObj);
-    this._displayNode("requestFormData");
-  },
-
-  /**
-   * Displays the response section of the NetworkPanel, sets the response status,
-   * the duration between the start of the request and the receiving of the
-   * response header as well as the response header content on the the NetworkPanel.
-   *
-   * @returns void
-   */
-  _displayResponseHeader: function NP_displayResponseHeader()
-  {
-    let timing = this.httpActivity.timing;
-    let response = this.httpActivity.response;
-
-    this._appendTextNode("headStatus", response.status);
-
-    let deltaDuration =
-      Math.round((timing.RESPONSE_HEADER - timing.REQUEST_HEADER) / 1000);
-    this._appendTextNode("responseHeadersInfo",
-      this._format("durationMS", [deltaDuration]));
-
-    this._displayNode("responseContainer");
-    this._appendList("responseHeadersContent", response.header);
-  },
-
-  /**
-   * Displays the respones image section, sets the source of the image displayed
-   * in the image response section to the request URL and the duration between
-   * the receiving of the response header and the end of the request. Once the
-   * image is loaded, the size of the requested image is set.
-   *
-   * @returns void
-   */
-  _displayResponseImage: function NP_displayResponseImage()
-  {
-    let self = this;
-    let timing = this.httpActivity.timing;
-    let response = this.httpActivity.response;
-    let cached = "";
-
-    if (this._isResponseCached) {
-      cached = "Cached";
-    }
-
-    let imageNode = this.document.getElementById("responseImage" + cached +"Node");
-    imageNode.setAttribute("src", this.httpActivity.url);
-
-    // This function is called to set the imageInfo.
-    function setImageInfo() {
-      let deltaDuration =
-        Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
-      self._appendTextNode("responseImage" + cached + "Info",
-        self._format("imageSizeDeltaDurationMS", [
-          imageNode.width, imageNode.height, deltaDuration
-        ]
-      ));
-    }
-
-    // Check if the image is already loaded.
-    if (imageNode.width != 0) {
-      setImageInfo();
-    }
-    else {
-      // Image is not loaded yet therefore add a load event.
-      imageNode.addEventListener("load", function imageNodeLoad() {
-        imageNode.removeEventListener("load", imageNodeLoad, false);
-        setImageInfo();
-      }, false);
-    }
-
-    this._displayNode("responseImage" + cached);
-  },
-
-  /**
-   * Displays the response body section, sets the the duration between
-   * the receiving of the response header and the end of the request as well as
-   * the content of the response body on the NetworkPanel.
-   *
-   * @param [optional] string aCachedContent
-   *        Cached content for this request. If this argument is set, the
-   *        responseBodyCached section is displayed.
-   * @returns void
-   */
-  _displayResponseBody: function NP_displayResponseBody(aCachedContent)
-  {
-    let timing = this.httpActivity.timing;
-    let response = this.httpActivity.response;
-    let cached =  "";
-    if (aCachedContent) {
-      cached = "Cached";
-    }
-
-    let deltaDuration =
-      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
-    this._appendTextNode("responseBody" + cached + "Info",
-      this._format("durationMS", [deltaDuration]));
-
-    this._displayNode("responseBody" + cached);
-    this._appendTextNode("responseBody" + cached + "Content",
-                            aCachedContent || response.body);
-  },
-
-  /**
-   * Displays the `Unknown Content-Type hint` and sets the duration between the
-   * receiving of the response header on the NetworkPanel.
-   *
-   * @returns void
-   */
-  _displayResponseBodyUnknownType: function NP_displayResponseBodyUnknownType()
-  {
-    let timing = this.httpActivity.timing;
-
-    this._displayNode("responseBodyUnknownType");
-    let deltaDuration =
-      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
-    this._appendTextNode("responseBodyUnknownTypeInfo",
-      this._format("durationMS", [deltaDuration]));
-
-    this._appendTextNode("responseBodyUnknownTypeContent",
-      this._format("responseBodyUnableToDisplay.content", [this._contentType]));
-  },
-
-  /**
-   * Displays the `no response body` section and sets the the duration between
-   * the receiving of the response header and the end of the request.
-   *
-   * @returns void
-   */
-  _displayNoResponseBody: function NP_displayNoResponseBody()
-  {
-    let timing = this.httpActivity.timing;
-
-    this._displayNode("responseNoBody");
-    let deltaDuration =
-      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
-    this._appendTextNode("responseNoBodyInfo",
-      this._format("durationMS", [deltaDuration]));
-  },
-
-  /*
-   * Calls the isDoneCallback function if one is specified.
-   */
-  _callIsDone: function() {
-    if (this.isDoneCallback) {
-      this.isDoneCallback();
-    }
-  },
-
-  /**
-   * Updates the content of the NetworkPanel's iframe.
-   *
-   * @returns void
-   */
-  update: function NP_update()
-  {
-    /**
-     * After the iframe's contentWindow is ready, the document object is set.
-     * If the document object isn't set yet, then the page is loaded and nothing
-     * can be updated.
-     */
-    if (!this.document) {
-      return;
-    }
-
-    let timing = this.httpActivity.timing;
-    let request = this.httpActivity.request;
-    let response = this.httpActivity.response;
-
-    switch (this._state) {
-      case this._INIT:
-        this._displayRequestHeader();
-        this._state = this._DISPLAYED_REQUEST_HEADER;
-        // FALL THROUGH
-
-      case this._DISPLAYED_REQUEST_HEADER:
-        // Process the request body if there is one.
-        if (!request.bodyDiscarded && request.body) {
-          // Check if we send some form data. If so, display the form data special.
-          if (this._isRequestBodyFormData) {
-            this._displayRequestForm();
-          }
-          else {
-            this._displayRequestBody();
-          }
-          this._state = this._DISPLAYED_REQUEST_BODY;
-        }
-        // FALL THROUGH
-
-      case this._DISPLAYED_REQUEST_BODY:
-        // There is always a response header. Therefore we can skip here if
-        // we don't have a response header yet and don't have to try updating
-        // anything else in the NetworkPanel.
-        if (!response.header) {
-          break
-        }
-        this._displayResponseHeader();
-        this._state = this._DISPLAYED_RESPONSE_HEADER;
-        // FALL THROUGH
-
-      case this._DISPLAYED_RESPONSE_HEADER:
-        // Check if the transition is done.
-        if (timing.TRANSACTION_CLOSE && response.isDone) {
-          if (response.bodyDiscarded) {
-            this._callIsDone();
-          }
-          else if (this._responseIsImage) {
-            this._displayResponseImage();
-            this._callIsDone();
-          }
-          else if (!this._isResponseBodyTextData) {
-            this._displayResponseBodyUnknownType();
-            this._callIsDone();
-          }
-          else if (response.body) {
-            this._displayResponseBody();
-            this._callIsDone();
-          }
-          else if (this._isResponseCached) {
-            let self = this;
-            NetworkHelper.loadFromCache(this.httpActivity.url,
-                                        this.httpActivity.charset,
-                                        function(aContent) {
-              // If some content could be loaded from the cache, then display
-              // the body.
-              if (aContent) {
-                self._displayResponseBody(aContent);
-                self._callIsDone();
-              }
-              // Otherwise, show the "There is no response body" hint.
-              else {
-                self._displayNoResponseBody();
-                self._callIsDone();
-              }
-            });
-          }
-          else {
-            this._displayNoResponseBody();
-            this._callIsDone();
-          }
-          this._state = this._TRANSITION_CLOSED;
-        }
-        break;
-    }
-  }
-}
-
 ///////////////////////////////////////////////////////////////////////////
 //// Private utility functions for the HUD service
 
 /**
  * Ensures that the number of message nodes of type aCategory don't exceed that
  * category's line limit by removing old messages as needed.
  *
  * @param aHUDId aHUDId
@@ -1289,29 +343,34 @@ function pruneConsoleOutputIfNecessary(a
   let oldScrollHeight = scrollBox.scrollHeight;
   let scrolledToBottom = ConsoleUtils.isOutputScrolledToBottom(outputNode);
 
   // Prune the nodes.
   let messageNodes = outputNode.querySelectorAll(".webconsole-msg-" +
       CATEGORY_CLASS_FRAGMENTS[aCategory]);
   let removeNodes = messageNodes.length - logLimit;
   for (let i = 0; i < removeNodes; i++) {
-    if (messageNodes[i].classList.contains("webconsole-msg-cssparser")) {
-      let desc = messageNodes[i].childNodes[2].textContent;
+    let node = messageNodes[i];
+    if (node._evalCacheId && !node._panelOpen) {
+      hudRef.jsterm.clearObjectCache(node._evalCacheId);
+    }
+
+    if (node.classList.contains("webconsole-msg-cssparser")) {
+      let desc = node.childNodes[2].textContent;
       let location = "";
-      if (messageNodes[i].childNodes[4]) {
-        location = messageNodes[i].childNodes[4].getAttribute("title");
+      if (node.childNodes[4]) {
+        location = node.childNodes[4].getAttribute("title");
       }
       delete hudRef.cssNodes[desc + location];
     }
-    else if (messageNodes[i].classList.contains("webconsole-msg-inspector")) {
-      hudRef.pruneConsoleDirNode(messageNodes[i]);
+    else if (node.classList.contains("webconsole-msg-inspector")) {
+      hudRef.pruneConsoleDirNode(node);
       continue;
     }
-    messageNodes[i].parentNode.removeChild(messageNodes[i]);
+    node.parentNode.removeChild(node);
   }
 
   if (!scrolledToBottom && removeNodes > 0 &&
       oldScrollHeight != scrollBox.scrollHeight) {
     scrollBox.scrollTop -= oldScrollHeight - scrollBox.scrollHeight;
   }
 
   return logLimit;
@@ -1335,278 +394,157 @@ function HUD_SERVICE()
   // These methods access the "this" object, but they're registered as
   // event listeners. So we hammer in the "this" binding.
   this.onTabClose = this.onTabClose.bind(this);
   this.onWindowUnload = this.onWindowUnload.bind(this);
 
   // Remembers the last console height, in pixels.
   this.lastConsoleHeight = Services.prefs.getIntPref("devtools.hud.height");
 
-  // Network response bodies are piped through a buffer of the given size (in
-  // bytes).
-  this.responsePipeSegmentSize =
-    Services.prefs.getIntPref("network.buffer.cache.size");
-
-  /**
-   * Collection of HUDIds that map to the tabs/windows/contexts
-   * that a HeadsUpDisplay can be activated for.
-   */
-  this.activatedContexts = [];
-
   /**
    * Collection of outer window IDs mapping to HUD IDs.
    */
+  // TODO: clean up the map of windowIds and the associated code. We no longer
+  // use windowIds to track open Web Consoles.
   this.windowIds = {};
 
   /**
    * Each HeadsUpDisplay has a set of filter preferences
    */
   this.filterPrefs = {};
 
   /**
    * Keeps a reference for each HeadsUpDisplay that is created
    */
   this.hudReferences = {};
-
-  /**
-   * Requests that haven't finished yet.
-   */
-  this.openRequests = {};
-
-  /**
-   * Response headers for requests that haven't finished yet.
-   */
-  this.openResponseHeaders = {};
 };
 
 HUD_SERVICE.prototype =
 {
   /**
    * Last value entered
    */
   lastInputValue: "",
 
   /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @returns string
-   */
-  getStr: function HS_getStr(aName)
-  {
-    return stringBundle.GetStringFromName(aName);
-  },
-
-  /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @returns (format) string
-   */
-  getFormatStr: function HS_getFormatStr(aName, aArray)
-  {
-    return stringBundle.formatStringFromName(aName, aArray, aArray.length);
-  },
-
-  /**
    * getter for UI commands to be used by the frontend
    *
    * @returns object
    */
   get consoleUI() {
     return HeadsUpDisplayUICommands;
   },
 
   /**
    * The sequencer is a generator (after initialization) that returns unique
    * integers
    */
   sequencer: null,
 
   /**
-   * Gets the ID of the outer window of this DOM window
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns integer
-   */
-  getWindowId: function HS_getWindowId(aWindow)
-  {
-    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
-  },
-
-  /**
-   * Gets the ID of the inner window of this DOM window
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns integer
-   */
-  getInnerWindowId: function HS_getInnerWindowId(aWindow)
-  {
-    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
-           getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
-  },
-
-  /**
-   * Gets the top level content window that has an outer window with
-   * the given ID or returns null if no such content window exists
-   *
-   * @param integer aId
-   * @returns nsIDOMWindow
-   */
-  getWindowByWindowId: function HS_getWindowByWindowId(aId)
-  {
-    // In the future (post-Electrolysis), getOuterWindowWithId() could
-    // return null, because the originating window could have gone away
-    // while we were in the process of receiving and/or processing a
-    // message. For future-proofing purposes, we do a null check here.
-
-    let someWindow = Services.wm.getMostRecentWindow(null);
-    let content = null;
-
-    if (someWindow) {
-      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                                  .getInterface(Ci.nsIDOMWindowUtils);
-      content = windowUtils.getOuterWindowWithId(aId);
-    }
-
-    return content;
-  },
-
-  /**
-   * Whether to save the bodies of network requests and responses. Disabled by
-   * default to save memory.
-   */
-  saveRequestAndResponseBodies: false,
-
-  /**
-   * Tell the HUDService that a HeadsUpDisplay can be activated
-   * for the window or context that has 'aContextDOMId' node id
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  registerActiveContext: function HS_registerActiveContext(aContextDOMId)
-  {
-    this.activatedContexts.push(aContextDOMId);
-  },
-
-  /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
     return this.mixins.getCurrentContext();
   },
 
   /**
-   * Tell the HUDService that a HeadsUpDisplay should be deactivated
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  unregisterActiveContext: function HS_deregisterActiveContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    var idx = this.activatedContexts.indexOf(domId);
-    if (idx > -1) {
-      this.activatedContexts.splice(idx, 1);
-    }
-  },
-
-  /**
-   * Tells callers that a HeadsUpDisplay can be activated for the context
-   *
-   * @param string aContextDOMId
-   * @return boolean
-   */
-  canActivateContext: function HS_canActivateContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    for (var idx in this.activatedContexts) {
-      if (this.activatedContexts[idx] == domId){
-        return true;
-      }
-    }
-    return false;
-  },
-
-  /**
    * Activate a HeadsUpDisplay for the given tab context.
    *
-   * @param Element aContext the tab element.
-   * @param boolean aAnimated animate opening the Web Console?
+   * @param nsIDOMElement aContext
+   *        The xul:tab element.
+   * @param boolean aAnimated
+   *        True if you want to animate the opening of the Web Console,
+   *        otherwise false.
    * @returns void
    */
   activateHUDForContext: function HS_activateHUDForContext(aContext, aAnimated)
   {
+    dump("activateHUDForContext 1\n");
     this.wakeup();
 
-    let window = aContext.linkedBrowser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    this.registerActiveContext(nBox.id);
-    this.windowInitializer(window);
-
-    let hudId = "hud_" + nBox.id;
-    let hudRef = this.hudReferences[hudId];
+    let hudId = "hud_" + aContext.linkedPanel;
+    let window = aContext.ownerDocument.defaultView;
+    let gBrowser = window.gBrowser;
+    dump("HS_activateHUDForContext " + hudId + "\n");
+
+    // TODO: check that this works as intended
+    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
+    window.addEventListener("unload", this.onWindowUnload, false);
+
+    this.registerDisplay(hudId);
+    let hud = new HeadsUpDisplay(aContext);
+    this.hudReferences[hudId] = hud;
+
+    // FIXME: Need to detect that the console component has been paved over.
+    //let consoleObject = WebConsoleUtils.unwrap(aContentWindow).console;
+    //if (!("__mozillaConsole__" in consoleObject))
+    //  this.logWarningAboutReplacedAPI(hudId);
+
+    // register the controller to handle "select all" properly
+    this.createController(window);
+
+    let hudRef = this.getHudReferenceById(hudId);
 
     if (!aAnimated || hudRef.consolePanel) {
       this.disableAnimation(hudId);
     }
 
+    // TODO: need to rebase the displaying of cached console message
+    // see HUD_displayCachedConsoleMessages() and https://bugzilla.mozilla.org/show_bug.cgi?id=673148#c28
+
     // Create a processing instruction for GCLIs CSS stylesheet, but only if
     // we don't have one for this document. Also record the context we're
     // adding this for so we know when to remove it.
     let procInstr = aContext.ownerDocument.gcliCssProcInstr;
-    if (!procInstr) {
+    if (!procInstr && hud.gcliterm) {
       procInstr = aContext.ownerDocument.createProcessingInstruction(
               "xml-stylesheet",
               "href='chrome://browser/skin/devtools/gcli.css' type='text/css'");
       procInstr.contexts = [];
 
       let root = aContext.ownerDocument.getElementsByTagName('window')[0];
       root.parentNode.insertBefore(procInstr, root);
       aContext.ownerDocument.gcliCssProcInstr = procInstr;
     }
-    if (procInstr.contexts.indexOf(hudId) == -1) {
+    if (procInstr && procInstr.contexts.indexOf(hudId) == -1) {
       procInstr.contexts.push(hudId);
     }
+
+    let id = ConsoleUtils.supString(hudId);
+    Services.obs.notifyObservers(id, "web-console-created", null);
+
+    dump("activateHUDForContext end\n");
   },
 
   /**
    * Deactivate a HeadsUpDisplay for the given tab context.
    *
    * @param nsIDOMWindow aContext
    * @param aAnimated animate closing the web console?
    * @returns void
    */
   deactivateHUDForContext: function HS_deactivateHUDForContext(aContext, aAnimated)
   {
-    let browser = aContext.linkedBrowser;
-    let window = browser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    let hudId = "hud_" + nBox.id;
-    let displayNode = chromeDocument.getElementById(hudId);
-
-    if (hudId in this.hudReferences && displayNode) {
-      if (!aAnimated) {
-        this.storeHeight(hudId);
-      }
-
-      let hud = this.hudReferences[hudId];
-      browser.webProgress.removeProgressListener(hud.progressListener);
-      delete hud.progressListener;
-
-      this.unregisterDisplay(hudId);
-
-      window.focus();
+    let hudId = "hud_" + aContext.linkedPanel;
+    dump("HS_deactivateHUDForContext " + hudId + "\n");
+    if (!(hudId in this.hudReferences)) {
+      return;
     }
 
+    if (!aAnimated) {
+      this.storeHeight(hudId);
+    }
+
+    this.unregisterDisplay(hudId);
+
+    // FIXME window.focus();
+
     // Remove this context from the list of contexts that need the GCLI CSS
     // processing instruction and then remove the processing instruction if it
     // isn't needed any more.
     let procInstr = aContext.ownerDocument.gcliCssProcInstr;
     if (procInstr) {
       procInstr.contexts = procInstr.contexts.filter(function(id) {
         return id !== hudId;
       });
@@ -1808,28 +746,16 @@ HUD_SERVICE.prototype =
         node.classList.add("hud-filtered-by-string");
       }
     }
 
     this.regroupOutput(outputNode);
   },
 
   /**
-   * Register a reference of each HeadsUpDisplay that is created
-   */
-  registerHUDReference:
-  function HS_registerHUDReference(aHUD)
-  {
-    this.hudReferences[aHUD.hudId] = aHUD;
-
-    let id = ConsoleUtils.supString(aHUD.hudId);
-    Services.obs.notifyObservers(id, "web-console-created", null);
-  },
-
-  /**
    * Register a new Heads Up Display
    *
    * @returns void
    */
   registerDisplay: function HS_registerDisplay(aHUDId)
   {
     // register a display DOM node Id with the service.
     if (!aHUDId){
@@ -1855,26 +781,16 @@ HUD_SERVICE.prototype =
    * @param string aHUDId
    *        The ID of a HUD.
    * @returns void
    */
   unregisterDisplay: function HS_unregisterDisplay(aHUDId)
   {
     let hud = this.getHudReferenceById(aHUDId);
 
-    // Remove children from the output. If the output is not cleared, there can
-    // be leaks as some nodes has node.onclick = function; set and GC can't
-    // remove the nodes then.
-    if (hud.jsterm) {
-      hud.jsterm.clearOutput();
-    }
-    if (hud.gcliterm) {
-      hud.gcliterm.clearOutput();
-    }
-
     hud.destroy();
 
     // Make sure that the console panel does not try to call
     // deactivateHUDForContext() again.
     hud.consoleWindowUnregisterOnHide = false;
 
     // Remove the HUDBox and the consolePanel if the Web Console is inside a
     // floating panel.
@@ -1885,30 +801,24 @@ HUD_SERVICE.prototype =
     }
 
     hud.HUDBox.parentNode.removeChild(hud.HUDBox);
 
     if (hud.splitter.parentNode) {
       hud.splitter.parentNode.removeChild(hud.splitter);
     }
 
-    if (hud.jsterm) {
-      hud.jsterm.autocompletePopup.destroy();
-    }
-
     delete this.hudReferences[aHUDId];
 
     for (let windowID in this.windowIds) {
       if (this.windowIds[windowID] == aHUDId) {
         delete this.windowIds[windowID];
       }
     }
 
-    this.unregisterActiveContext(aHUDId);
-
     let popupset = hud.chromeDocument.getElementById("mainPopupSet");
     let panels = popupset.querySelectorAll("panel[hudId=" + aHUDId + "]");
     for (let i = 0; i < panels.length; i++) {
       panels[i].hidePopup();
     }
 
     let id = ConsoleUtils.supString(aHUDId);
     Services.obs.notifyObservers(id, "web-console-destroyed", null);
@@ -1931,59 +841,41 @@ HUD_SERVICE.prototype =
    * @returns void
    */
   wakeup: function HS_wakeup()
   {
     if (Object.keys(this.hudReferences).length > 0) {
       return;
     }
 
-    // begin observing HTTP traffic
-    this.startHTTPObservation();
-
-    HUDWindowObserver.init();
-    HUDConsoleObserver.init();
-    ConsoleAPIObserver.init();
+
+    WebConsoleObserver.init();
   },
 
   /**
    * Suspend Web Console activity. This is called when all Web Consoles are
    * closed.
    *
    * @returns void
    */
   suspend: function HS_suspend()
   {
-    activityDistributor.removeObserver(this.httpObserver);
-    delete this.httpObserver;
-
-    Services.obs.removeObserver(this.httpResponseExaminer,
-                                "http-on-examine-response");
-
-    this.openRequests = {};
-    this.openResponseHeaders = {};
-
-    delete this.defaultFilterPrefs;
-
-    delete this.lastFinishedRequestCallback;
-
-    HUDWindowObserver.uninit();
-    HUDConsoleObserver.uninit();
-    ConsoleAPIObserver.shutdown();
+    WebConsoleObserver.uninit();
   },
 
   /**
-   * Shutdown all HeadsUpDisplays on xpcom-shutdown
+   * Shutdown all HeadsUpDisplays on quit-application-granted.
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
   {
-    for (let hudId in this.hudReferences) {
-      this.deactivateHUDForContext(this.hudReferences[hudId].tab, false);
+    for each (let hud in this.hudReferences) {
+      dump("shutdown hud " + hud.hudId + "\n");
+      this.deactivateHUDForContext(hud.tab, false);
     }
   },
 
   /**
    * Returns the HeadsUpDisplay object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
@@ -1998,17 +890,17 @@ HUD_SERVICE.prototype =
    * Returns the hudId that is corresponding to the hud activated for the
    * passed aContentWindow. If there is no matching hudId null is returned.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns string or null
    */
   getHudIdByWindow: function HS_getHudIdByWindow(aContentWindow)
   {
-    let windowId = this.getWindowId(aContentWindow);
+    let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow);
     return this.getHudIdByWindowId(windowId);
   },
 
   /**
    * Returns the hudReference for a given id.
    *
    * @param string aId
    * @returns Object
@@ -2062,55 +954,41 @@ HUD_SERVICE.prototype =
    * @param object aMessage
    *        The message reported by the console service.
    * @return void
    */
   logConsoleAPIMessage: function HS_logConsoleAPIMessage(aHUDId, aMessage)
   {
     // Pipe the message to createMessageNode().
     let hud = HUDService.hudReferences[aHUDId];
-    function formatResult(x) {
-      if (typeof(x) == "string") {
-        return x;
-      }
-      if (hud.gcliterm) {
-        return hud.gcliterm.formatResult(x);
-      }
-      if (hud.jsterm) {
-        return hud.jsterm.formatResult(x);
-      }
-      return x;
-    }
-
     let body = null;
     let clipboardText = null;
     let sourceURL = null;
     let sourceLine = 0;
-    let level = aMessage.level;
-    let args = aMessage.arguments;
+    let level = aMessage.apiMessage.level;
+    let args = aMessage.apiMessage.arguments;
 
     switch (level) {
       case "log":
       case "info":
       case "warn":
       case "error":
       case "debug":
-        let mappedArguments = Array.map(args, formatResult);
-        body = Array.join(mappedArguments, " ");
-        sourceURL = aMessage.filename;
-        sourceLine = aMessage.lineNumber;
+        body = args.join(" ");
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
         break;
 
       case "trace":
-        let filename = ConsoleUtils.abbreviateSourceURL(args[0].filename);
+        let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
         let functionName = args[0].functionName ||
-                           this.getStr("stacktrace.anonymousFunction");
+                           l10n.getStr("stacktrace.anonymousFunction");
         let lineNumber = args[0].lineNumber;
 
-        body = this.getFormatStr("stacktrace.outputMessage",
+        body = l10n.getFormatStr("stacktrace.outputMessage",
                                  [filename, functionName, lineNumber]);
 
         sourceURL = args[0].filename;
         sourceLine = args[0].lineNumber;
 
         clipboardText = "";
 
         args.forEach(function(aFrame) {
@@ -2118,58 +996,64 @@ HUD_SERVICE.prototype =
                            aFrame.functionName + " :: " +
                            aFrame.lineNumber + "\n";
         });
 
         clipboardText = clipboardText.trimRight();
         break;
 
       case "dir":
-        body = unwrap(args[0]);
-        clipboardText = body.toString();
-        sourceURL = aMessage.filename;
-        sourceLine = aMessage.lineNumber;
+        body = {
+          cacheId: aMessage.objectsCacheId,
+          resultString: aMessage.argumentsToString[0],
+          remoteObject: aMessage.apiMessage.arguments[0],
+          remoteObjectProvider: hud.jsterm.remoteObjectProvider.bind(hud.jsterm),
+        };
+        clipboardText = body.resultString;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
         break;
 
+      // FIXME
       case "group":
       case "groupCollapsed":
         clipboardText = body = formatResult(args);
-        sourceURL = aMessage.filename;
-        sourceLine = aMessage.lineNumber;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
         hud.groupDepth++;
         break;
 
       case "groupEnd":
         if (hud.groupDepth > 0) {
           hud.groupDepth--;
         }
         return;
 
       case "time":
         if (!args) {
           return;
         }
         if (args.error) {
-          Cu.reportError(this.getStr(args.error));
+          Cu.reportError(l10n.getStr(args.error));
           return;
         }
-        body = this.getFormatStr("timerStarted", [args.name]);
+        body = l10n.getFormatStr("timerStarted", [args.name]);
         clipboardText = body;
-        sourceURL = aMessage.filename;
-        sourceLine = aMessage.lineNumber;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
         break;
 
       case "timeEnd":
         if (!args) {
           return;
         }
-        body = this.getFormatStr("timeEnd", [args.name, args.duration]);
+        body = l10n.getFormatStr("timeEnd", [args.name, args.duration]);
         clipboardText = body;
-        sourceURL = aMessage.filename;
-        sourceLine = aMessage.lineNumber;
+        sourceURL = aMessage.apiMessage.filename;
+        sourceLine = aMessage.apiMessage.lineNumber;
         break;
 
       default:
         Cu.reportError("Unknown Console API log level: " + level);
         return;
     }
 
     let node = ConsoleUtils.createMessageNode(hud.outputNode.ownerDocument,
@@ -2181,83 +1065,73 @@ HUD_SERVICE.prototype =
                                               sourceLine,
                                               clipboardText,
                                               level,
                                               aMessage.timeStamp);
 
     // Make the node bring up the property panel, to allow the user to inspect
     // the stack trace.
     if (level == "trace") {
-      node._stacktrace = args;
-
-      let linkNode = node.querySelector(".webconsole-msg-body");
-      linkNode.classList.add("hud-clickable");
-      linkNode.setAttribute("aria-haspopup", "true");
-
-      node.addEventListener("mousedown", function(aEvent) {
-        this._startX = aEvent.clientX;
-        this._startY = aEvent.clientY;
-      }, false);
-
-      node.addEventListener("click", function(aEvent) {
-        if (aEvent.detail != 1 || aEvent.button != 0 ||
-            (this._startX != aEvent.clientX &&
-             this._startY != aEvent.clientY)) {
-          return;
+      hud.makeOutputMessageLink(node, function() {
+        if (!node._panelOpen) {
+          let options = {
+            anchor: node,
+            data: { object: args },
+          };
+
+          let propPanel = hud.jsterm.openPropertyPanel(options);
+          propPanel.panel.setAttribute("hudId", aHUDId);
         }
-
-        if (!this._panelOpen) {
-          let propPanel = hud.jsterm.openPropertyPanel(null,
-                                                       node._stacktrace,
-                                                       this);
-          propPanel.panel.setAttribute("hudId", aHUDId);
-          this._panelOpen = true;
-        }
-      }, false);
+      });
     }
 
     ConsoleUtils.outputMessageNode(node, aHUDId);
 
     if (level == "dir") {
       // Initialize the inspector message node, by setting the PropertyTreeView
       // object on the tree view. This has to be done *after* the node is
       // shown, because the tree binding must be attached first.
       let tree = node.querySelector("tree");
       tree.view = node.propertyTreeView;
+
+      // Make sure the cached evaluated object will be purged when the node is
+      // removed.
+      node._evalCacheId = aMessage.objectsCacheId;
     }
   },
 
   /**
    * Inform user that the Web Console API has been replaced by a script
    * in a content page.
    *
    * @param string aHUDId
    *        The ID of the Web Console to which to send the message.
    * @return void
    */
   logWarningAboutReplacedAPI:
   function HS_logWarningAboutReplacedAPI(aHUDId)
   {
     let hud = this.hudReferences[aHUDId];
     let chromeDocument = hud.HUDBox.ownerDocument;
-    let message = stringBundle.GetStringFromName("ConsoleAPIDisabled");
+    let message = l10n.getStr("ConsoleAPIDisabled");
     let node = ConsoleUtils.createMessageNode(chromeDocument, CATEGORY_JS,
                                               SEVERITY_WARNING, message,
                                               aHUDId);
     ConsoleUtils.outputMessageNode(node, aHUDId);
   },
 
   /**
    * Reports an error in the page source, either JavaScript or CSS.
    *
    * @param nsIScriptError aScriptError
    *        The error message to report.
    * @return void
    */
-  reportPageError: function HS_reportPageError(aScriptError)
+  // TODO: update comment. FIXME: needs rebase fixes.
+  reportPageError: function HS_reportPageError(aHUDId, aCategory, aScriptError)
   {
     if (!aScriptError.outerWindowID) {
       return;
     }
 
     let category;
 
     switch (aScriptError.category) {
@@ -2285,36 +1159,28 @@ HUD_SERVICE.prototype =
     // Warnings and legacy strict errors become warnings; other types become
     // errors.
     let severity = SEVERITY_ERROR;
     if ((aScriptError.flags & aScriptError.warningFlag) ||
         (aScriptError.flags & aScriptError.strictFlag)) {
       severity = SEVERITY_WARNING;
     }
 
-    let window = HUDService.getWindowByWindowId(aScriptError.outerWindowID);
-    if (window) {
-      let hudId = HUDService.getHudIdByWindow(window.top);
-      if (hudId) {
-        let outputNode = this.hudReferences[hudId].outputNode;
-        let chromeDocument = outputNode.ownerDocument;
-
-        let node = ConsoleUtils.createMessageNode(chromeDocument,
-                                                  category,
-                                                  severity,
-                                                  aScriptError.errorMessage,
-                                                  hudId,
-                                                  aScriptError.sourceName,
-                                                  aScriptError.lineNumber,
-                                                  null, null,
-                                                  aScriptError.timeStamp);
-
-        ConsoleUtils.outputMessageNode(node, hudId);
-      }
-    }
+    let outputNode = this.hudReferences[aHUDId].outputNode;
+    let chromeDocument = outputNode.ownerDocument;
+
+    let node = ConsoleUtils.createMessageNode(chromeDocument,
+                                              aCategory,
+                                              severity,
+                                              aScriptError.errorMessage,
+                                              aHUDId,
+                                              aScriptError.sourceName,
+                                              aScriptError.lineNumber);
+
+    ConsoleUtils.outputMessageNode(node, aHUDId);
   },
 
   /**
    * Register a Gecko app's specialized ApplicationHooks object
    *
    * @returns void or throws "UNSUPPORTED APPLICATION" error
    */
   registerApplicationHooks:
@@ -2332,473 +1198,107 @@ HUD_SERVICE.prototype =
   /**
    * Registry of ApplicationHooks used by specified Gecko Apps
    *
    * @returns Specific Gecko 'ApplicationHooks' Object/Mixin
    */
   applicationHooks: null,
 
   /**
-   * Assign a function to this property to listen for finished httpRequests.
-   * Used by unit tests.
-   */
-  lastFinishedRequestCallback: null,
-
-  /**
    * Opens a NetworkPanel.
    *
    * @param nsIDOMNode aNode
    *        DOMNode to display the panel next to.
-   * @param object aHttpActivity
-   *        httpActivity object. The data of this object is displayed in the
-   *        NetworkPanel.
    * @returns NetworkPanel
    */
-  openNetworkPanel: function HS_openNetworkPanel(aNode, aHttpActivity)
+  // TODO: update comment
+  openNetworkPanel: function HS_openNetworkPanel(aNode)
   {
     let doc = aNode.ownerDocument;
     let parent = doc.getElementById("mainPopupSet");
-    let netPanel = new NetworkPanel(parent, aHttpActivity);
+    let netPanel = new NetworkPanel(parent, aNode._httpActivity);
     netPanel.linkNode = aNode;
+    aNode._netPanel = netPanel;
+
+    netPanel.update();
 
     let panel = netPanel.panel;
     panel.openPopup(aNode, "after_pointer", 0, 0, false, false);
     panel.sizeTo(450, 500);
-    panel.setAttribute("hudId", aHttpActivity.hudId);
-    aHttpActivity.panels.push(Cu.getWeakReference(netPanel));
+    panel.setAttribute("hudId", aNode._httpActivity.hudId);
     return netPanel;
   },
 
   /**
-   * Begin observing HTTP traffic that we care about,
-   * namely traffic that originates inside any context that a Heads Up Display
-   * is active for.
-   */
-  startHTTPObservation: function HS_httpObserverFactory()
-  {
-    // creates an observer for http traffic
-    var self = this;
-    var httpObserver = {
-      observeActivity :
-      function HS_SHO_observeActivity(aChannel,
-                                      aActivityType,
-                                      aActivitySubtype,
-                                      aTimestamp,
-                                      aExtraSizeData,
-                                      aExtraStringData)
-      {
-        if (aActivityType ==
-              activityDistributor.ACTIVITY_TYPE_HTTP_TRANSACTION ||
-            aActivityType ==
-              activityDistributor.ACTIVITY_TYPE_SOCKET_TRANSPORT) {
-
-          aChannel = aChannel.QueryInterface(Ci.nsIHttpChannel);
-
-          let transCodes = this.httpTransactionCodes;
-          let hudId;
-
-          if (aActivitySubtype ==
-              activityDistributor.ACTIVITY_SUBTYPE_REQUEST_HEADER ) {
-            // Try to get the source window of the request.
-            let win = NetworkHelper.getWindowForRequest(aChannel);
-            if (!win) {
-              return;
-            }
-
-            // Try to get the hudId that is associated to the window.
-            hudId = self.getHudIdByWindow(win.top);
-            if (!hudId) {
-              return;
-            }
-
-            // The httpActivity object will hold all information concerning
-            // this request and later response.
-
-            let httpActivity = {
-              id: self.sequenceId(),
-              hudId: hudId,
-              url: aChannel.URI.spec,
-              method: aChannel.requestMethod,
-              channel: aChannel,
-              charset: win.document.characterSet,
-
-              panels: [],
-              request: {
-                header: { }
-              },
-              response: {
-                header: null
-              },
-              timing: {
-                "REQUEST_HEADER": aTimestamp
-              }
-            };
-
-            // Add a new output entry.
-            let loggedNode = self.logNetActivity(httpActivity);
-
-            // In some cases loggedNode can be undefined (e.g. if an image was
-            // requested). Don't continue in such a case.
-            if (!loggedNode) {
-              return;
-            }
-
-            aChannel.QueryInterface(Ci.nsITraceableChannel);
-
-            // The response will be written into the outputStream of this pipe.
-            // This allows us to buffer the data we are receiving and read it
-            // asynchronously.
-            // Both ends of the pipe must be blocking.
-            let sink = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
-
-            // The streams need to be blocking because this is required by the
-            // stream tee.
-            sink.init(false, false, HUDService.responsePipeSegmentSize,
-                      PR_UINT32_MAX, null);
-
-            // Add listener for the response body.
-            let newListener = new ResponseListener(httpActivity);
-
-            // Remember the input stream, so it isn't released by GC.
-            newListener.inputStream = sink.inputStream;
-            newListener.sink = sink;
-
-            let tee = Cc["@mozilla.org/network/stream-listener-tee;1"].
-                      createInstance(Ci.nsIStreamListenerTee);
-
-            let originalListener = aChannel.setNewListener(tee);
-
-            tee.init(originalListener, sink.outputStream, newListener);
-
-            // Copy the request header data.
-            aChannel.visitRequestHeaders({
-              visitHeader: function(aName, aValue) {
-                httpActivity.request.header[aName] = aValue;
-              }
-            });
-
-            // Store the loggedNode and the httpActivity object for later reuse.
-            let linkNode = loggedNode.querySelector(".webconsole-msg-link");
-
-            httpActivity.messageObject = {
-              messageNode: loggedNode,
-              linkNode:    linkNode
-            };
-            self.openRequests[httpActivity.id] = httpActivity;
-
-            // Make the network span clickable.
-            linkNode.setAttribute("aria-haspopup", "true");
-            linkNode.addEventListener("mousedown", function(aEvent) {
-              this._startX = aEvent.clientX;
-              this._startY = aEvent.clientY;
-            }, false);
-
-            linkNode.addEventListener("click", function(aEvent) {
-              if (aEvent.detail != 1 || aEvent.button != 0 ||
-                  (this._startX != aEvent.clientX &&
-                   this._startY != aEvent.clientY)) {
-                return;
-              }
-
-              if (!this._panelOpen) {
-                self.openNetworkPanel(this, httpActivity);
-                this._panelOpen = true;
-              }
-            }, false);
-          }
-          else {
-            // Iterate over all currently ongoing requests. If aChannel can't
-            // be found within them, then exit this function.
-            let httpActivity = null;
-            for each (let item in self.openRequests) {
-              if (item.channel !== aChannel) {
-                continue;
-              }
-              httpActivity = item;
-              break;
-            }
-
-            if (!httpActivity) {
-              return;
-            }
-
-            hudId = httpActivity.hudId;
-            let msgObject = httpActivity.messageObject;
-
-            let updatePanel = false;
-            let data;
-            // Store the time information for this activity subtype.
-            httpActivity.timing[transCodes[aActivitySubtype]] = aTimestamp;
-
-            switch (aActivitySubtype) {
-              case activityDistributor.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT: {
-                if (!self.saveRequestAndResponseBodies) {
-                  httpActivity.request.bodyDiscarded = true;
-                  break;
-                }
-
-                let gBrowser = msgObject.messageNode.ownerDocument.
-                               defaultView.gBrowser;
-                let HUD = HUDService.hudReferences[hudId];
-                let browser = gBrowser.
-                              getBrowserForDocument(HUD.contentDocument);
-
-                let sentBody = NetworkHelper.
-                               readPostTextFromRequest(aChannel, browser);
-                if (!sentBody) {
-                  // If the request URL is the same as the current page url, then
-                  // we can try to get the posted text from the page directly.
-                  // This check is necessary as otherwise the
-                  //   NetworkHelper.readPostTextFromPage
-                  // function is called for image requests as well but these
-                  // are not web pages and as such don't store the posted text
-                  // in the cache of the webpage.
-                  if (httpActivity.url == browser.contentWindow.location.href) {
-                    sentBody = NetworkHelper.readPostTextFromPage(browser);
-                  }
-                  if (!sentBody) {
-                    sentBody = "";
-                  }
-                }
-                httpActivity.request.body = sentBody;
-                break;
-              }
-
-              case activityDistributor.ACTIVITY_SUBTYPE_RESPONSE_HEADER: {
-                // aExtraStringData contains the response header. The first line
-                // contains the response status (e.g. HTTP/1.1 200 OK).
-                //
-                // Note: The response header is not saved here. Calling the
-                //       aChannel.visitResponseHeaders at this point sometimes
-                //       causes an NS_ERROR_NOT_AVAILABLE exception. Therefore,
-                //       the response header and response body is stored on the
-                //       httpActivity object within the RL_onStopRequest function.
-                httpActivity.response.status =
-                  aExtraStringData.split(/\r\n|\n|\r/)[0];
-
-                // Add the response status.
-                let linkNode = msgObject.linkNode;
-                let statusNode = linkNode.
-                  querySelector(".webconsole-msg-status");
-                let statusText = "[" + httpActivity.response.status + "]";
-                statusNode.setAttribute("value", statusText);
-
-                let clipboardTextPieces =
-                  [ httpActivity.method, httpActivity.url, statusText ];
-                msgObject.messageNode.clipboardText =
-                  clipboardTextPieces.join(" ");
-
-                let status = parseInt(httpActivity.response.status.
-                  replace(/^HTTP\/\d\.\d (\d+).+$/, "$1"));
-
-                if (status >= MIN_HTTP_ERROR_CODE &&
-                    status < MAX_HTTP_ERROR_CODE) {
-                  ConsoleUtils.setMessageType(msgObject.messageNode,
-                                              CATEGORY_NETWORK,
-                                              SEVERITY_ERROR);
-                }
-
-                break;
-              }
-
-              case activityDistributor.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE: {
-                let timing = httpActivity.timing;
-                let requestDuration =
-                  Math.round((timing.RESPONSE_COMPLETE -
-                                timing.REQUEST_HEADER) / 1000);
-
-                // Add the request duration.
-                let linkNode = msgObject.linkNode;
-                let statusNode = linkNode.
-                  querySelector(".webconsole-msg-status");
-
-                let statusText = httpActivity.response.status;
-                let timeText = self.getFormatStr("NetworkPanel.durationMS",
-                                                 [ requestDuration ]);
-                let fullStatusText = "[" + statusText + " " + timeText + "]";
-                statusNode.setAttribute("value", fullStatusText);
-
-                let clipboardTextPieces =
-                  [ httpActivity.method, httpActivity.url, fullStatusText ];
-                msgObject.messageNode.clipboardText =
-                  clipboardTextPieces.join(" ");
-
-                delete httpActivity.messageObject;
-                delete self.openRequests[httpActivity.id];
-                updatePanel = true;
-                break;
-              }
-            }
-
-            if (updatePanel) {
-              httpActivity.panels.forEach(function(weakRef) {
-                let panel = weakRef.get();
-                if (panel) {
-                  panel.update();
-                }
-              });
-            }
-          }
-        }
-      },
-
-      httpTransactionCodes: {
-        0x5001: "REQUEST_HEADER",
-        0x5002: "REQUEST_BODY_SENT",
-        0x5003: "RESPONSE_START",
-        0x5004: "RESPONSE_HEADER",
-        0x5005: "RESPONSE_COMPLETE",
-        0x5006: "TRANSACTION_CLOSE",
-
-        0x804b0003: "STATUS_RESOLVING",
-        0x804b000b: "STATUS_RESOLVED",
-        0x804b0007: "STATUS_CONNECTING_TO",
-        0x804b0004: "STATUS_CONNECTED_TO",
-        0x804b0005: "STATUS_SENDING_TO",
-        0x804b000a: "STATUS_WAITING_FOR",
-        0x804b0006: "STATUS_RECEIVING_FROM"
-      }
-    };
-
-    this.httpObserver = httpObserver;
-
-    activityDistributor.addObserver(httpObserver);
-
-    // This is used to find the correct HTTP response headers.
-    Services.obs.addObserver(this.httpResponseExaminer,
-                             "http-on-examine-response", false);
-  },
-
-  /**
-   * Observe notifications for the http-on-examine-response topic, coming from
-   * the nsIObserver service.
-   *
-   * @param string aTopic
-   * @param nsIHttpChannel aSubject
-   * @returns void
-   */
-  httpResponseExaminer: function HS_httpResponseExaminer(aSubject, aTopic)
-  {
-    if (aTopic != "http-on-examine-response" ||
-        !(aSubject instanceof Ci.nsIHttpChannel)) {
-      return;
-    }
-
-    let channel = aSubject.QueryInterface(Ci.nsIHttpChannel);
-    let win = NetworkHelper.getWindowForRequest(channel);
-    if (!win) {
-      return;
-    }
-    let hudId = HUDService.getHudIdByWindow(win);
-    if (!hudId) {
-      return;
-    }
-
-    let response = {
-      id: HUDService.sequenceId(),
-      hudId: hudId,
-      channel: channel,
-      headers: {},
-    };
-
-    try {
-      channel.visitResponseHeaders({
-        visitHeader: function(aName, aValue) {
-          response.headers[aName] = aValue;
-        }
-      });
-    }
-    catch (ex) {
-      delete response.headers;
-    }
-
-    if (response.headers) {
-      HUDService.openResponseHeaders[response.id] = response;
-    }
-  },
-
-  /**
    * Logs network activity.
    *
    * @param object aActivityObject
    *        The activity to log.
    * @returns void
    */
-  logNetActivity: function HS_logNetActivity(aActivityObject)
+  // TODO: update the comment
+  logNetActivity: function HS_logNetActivity(aMessage)
   {
-    let hudId = aActivityObject.hudId;
-    let outputNode = this.hudReferences[hudId].outputNode;
-
-    let chromeDocument = outputNode.ownerDocument;
+    let request = aMessage.log.entries[0].request;
+
+    let hudId = aMessage.hudId;
+    let hud = this.hudReferences[hudId];
+
+    let chromeDocument = hud.chromeDocument;
     let msgNode = chromeDocument.createElementNS(XUL_NS, "hbox");
 
     let methodNode = chromeDocument.createElementNS(XUL_NS, "label");
-    methodNode.setAttribute("value", aActivityObject.method);
+    methodNode.setAttribute("value", request.method);
     methodNode.classList.add("webconsole-msg-body-piece");
     msgNode.appendChild(methodNode);
 
     let linkNode = chromeDocument.createElementNS(XUL_NS, "hbox");
     linkNode.setAttribute("flex", "1");
     linkNode.classList.add("webconsole-msg-body-piece");
     linkNode.classList.add("webconsole-msg-link");
     msgNode.appendChild(linkNode);
 
     let urlNode = chromeDocument.createElementNS(XUL_NS, "label");
     urlNode.setAttribute("crop", "center");
     urlNode.setAttribute("flex", "1");
-    urlNode.setAttribute("title", aActivityObject.url);
-    urlNode.setAttribute("value", aActivityObject.url);
+    urlNode.setAttribute("title", request.url);
+    urlNode.setAttribute("value", request.url);
     urlNode.classList.add("hud-clickable");
     urlNode.classList.add("webconsole-msg-body-piece");
     urlNode.classList.add("webconsole-msg-url");
     linkNode.appendChild(urlNode);
 
     let statusNode = chromeDocument.createElementNS(XUL_NS, "label");
     statusNode.setAttribute("value", "");
     statusNode.classList.add("hud-clickable");
     statusNode.classList.add("webconsole-msg-body-piece");
     statusNode.classList.add("webconsole-msg-status");
     linkNode.appendChild(statusNode);
 
-    let clipboardText = aActivityObject.method + " " + aActivityObject.url;
+    let clipboardText = request.method + " " + request.url;
 
     let messageNode = ConsoleUtils.createMessageNode(chromeDocument,
                                                      CATEGORY_NETWORK,
                                                      SEVERITY_LOG,
                                                      msgNode,
                                                      hudId,
                                                      null,
                                                      null,
                                                      clipboardText);
-
-    ConsoleUtils.outputMessageNode(messageNode, aActivityObject.hudId);
-    return messageNode;
-  },
-
-  /**
-   * Initialize the JSTerm object to create a JS Workspace by attaching the UI
-   * into the given parent node, using the mixin.
-   *
-   * @param nsIDOMWindow aContext the context used for evaluating user input
-   * @param nsIDOMNode aParentNode where to attach the JSTerm
-   * @param object aConsole
-   *        Console object used within the JSTerm instance to report errors
-   *        and log data (by calling console.error(), console.log(), etc).
-   */
-  initializeJSTerm: function HS_initializeJSTerm(aContext, aParentNode, aConsole)
-  {
-    // create Initial JS Workspace:
-    var context = Cu.getWeakReference(aContext);
-
-    // Attach the UI into the target parent node using the mixin.
-    var firefoxMixin = new JSTermFirefoxMixin(context, aParentNode);
-    var jsTerm = new JSTerm(context, aParentNode, firefoxMixin, aConsole);
-
-    // TODO: injection of additional functionality needs re-thinking/api
-    // see bug 559748
+    messageNode.setAttribute("connectionId", aMessage.log.entries[0].connection);
+
+    messageNode._httpActivity = aMessage;
+
+    hud.makeOutputMessageLink(messageNode, function() {
+      if (!messageNode._panelOpen) {
+        this.openNetworkPanel(messageNode);
+      }
+    }.bind(this));
+
+    ConsoleUtils.outputMessageNode(messageNode, aMessage.hudId);
   },
 
   /**
    * Creates a generator that always returns a unique number for use in the
    * indexes
    *
    * @returns Generator
    */
@@ -2811,29 +1311,31 @@ HUD_SERVICE.prototype =
         yield aInt;
       }
     }
     return sequencer(aInt);
   },
 
   // See jsapi.h (JSErrorReport flags):
   // http://mxr.mozilla.org/mozilla-central/source/js/src/jsapi.h#3429
+  // TODO: see if these are still needed.
   scriptErrorFlags: {
     0: "error", // JSREPORT_ERROR
     1: "warn", // JSREPORT_WARNING
     2: "exception", // JSREPORT_EXCEPTION
     4: "error", // JSREPORT_STRICT | JSREPORT_ERROR
     5: "warn", // JSREPORT_STRICT | JSREPORT_WARNING
     8: "error", // JSREPORT_STRICT_MODE_ERROR
     13: "warn", // JSREPORT_STRICT_MODE_ERROR | JSREPORT_WARNING | JSREPORT_ERROR
   },
 
   /**
    * replacement strings (L10N)
    */
+  // TODO: see if these are still needed.
   scriptMsgLogLevel: {
     0: "typeError", // JSREPORT_ERROR
     1: "typeWarning", // JSREPORT_WARNING
     2: "typeException", // JSREPORT_EXCEPTION
     4: "typeError", // JSREPORT_STRICT | JSREPORT_ERROR
     5: "typeStrict", // JSREPORT_STRICT | JSREPORT_WARNING
     8: "typeError", // JSREPORT_STRICT_MODE_ERROR
     13: "typeWarning", // JSREPORT_STRICT_MODE_ERROR | JSREPORT_WARNING | JSREPORT_ERROR
@@ -2870,137 +1372,34 @@ HUD_SERVICE.prototype =
     tabContainer.removeEventListener("TabClose", this.onTabClose, false);
 
     let tab = tabContainer.firstChild;
     while (tab != null) {
       this.deactivateHUDForContext(tab, false);
       tab = tab.nextSibling;
     }
 
+    // FIXME: remove controller only when all Web Consoles are closed from the 
+    // given chrome window
     if (window.webConsoleCommandController) {
       window.controllers.removeController(window.webConsoleCommandController);
       window.webConsoleCommandController = null;
     }
   },
 
   /**
-   * windowInitializer - checks what Gecko app is running and inits the HUD
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  windowInitializer: function HS_WindowInitalizer(aContentWindow)
-  {
-    var xulWindow = aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-      .getInterface(Ci.nsIWebNavigation)
-                      .QueryInterface(Ci.nsIDocShell)
-                      .chromeEventHandler.ownerDocument.defaultView;
-
-    let xulWindow = unwrap(xulWindow);
-
-    let docElem = xulWindow.document.documentElement;
-    if (!docElem || docElem.getAttribute("windowtype") != "navigator:browser" ||
-        !xulWindow.gBrowser) {
-      // Do not do anything unless we have a browser window.
-      // This may be a view-source window or other type of non-browser window.
-      return;
-    }
-
-    let gBrowser = xulWindow.gBrowser;
-
-    let _browser = gBrowser.
-      getBrowserForDocument(aContentWindow.top.document);
-
-    // ignore newly created documents that don't belong to a tab's browser
-    if (!_browser) {
-      return;
-    }
-
-    let nBox = gBrowser.getNotificationBox(_browser);
-    let nBoxId = nBox.getAttribute("id");
-    let hudId = "hud_" + nBoxId;
-    let windowUI = nBox.ownerDocument.getElementById("console_window_" + hudId);
-    if (windowUI) {
-      // The Web Console popup is already open, no need to continue.
-      if (aContentWindow == aContentWindow.top) {
-        let hud = this.hudReferences[hudId];
-        hud.reattachConsole(aContentWindow);
-      }
-      return;
-    }
-
-    if (!this.canActivateContext(hudId)) {
-      return;
-    }
-
-    xulWindow.addEventListener("unload", this.onWindowUnload, false);
-    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
-
-    this.registerDisplay(hudId);
-
-    let hudNode;
-    let childNodes = nBox.childNodes;
-
-    for (let i = 0; i < childNodes.length; i++) {
-      let id = childNodes[i].getAttribute("id");
-      // `id` is a string with the format "hud_<number>".
-      if (id.split("_")[0] == "hud") {
-        hudNode = childNodes[i];
-        break;
-      }
-    }
-
-    let hud;
-    // If there is no HUD for this tab create a new one.
-    if (!hudNode) {
-      // get nBox object and call new HUD
-      let config = { parentNode: nBox,
-                     contentWindow: aContentWindow.top
-                   };
-
-      hud = new HeadsUpDisplay(config);
-
-      HUDService.registerHUDReference(hud);
-      let windowId = this.getWindowId(aContentWindow.top);
-      this.windowIds[windowId] = hudId;
-
-      hud.progressListener = new ConsoleProgressListener(hudId);
-
-      _browser.webProgress.addProgressListener(hud.progressListener,
-        Ci.nsIWebProgress.NOTIFY_STATE_ALL);
-
-      hud.displayCachedConsoleMessages();
-    }
-    else {
-      hud = this.hudReferences[hudId];
-      if (aContentWindow == aContentWindow.top) {
-        // TODO: name change?? doesn't actually re-attach the console
-        hud.reattachConsole(aContentWindow);
-      }
-    }
-
-    // Need to detect that the console component has been paved over.
-    let consoleObject = unwrap(aContentWindow).console;
-    if (!("__mozillaConsole__" in consoleObject))
-      this.logWarningAboutReplacedAPI(hudId);
-
-    // register the controller to handle "select all" properly
-    this.createController(xulWindow);
-  },
-
-  /**
    * Adds the command controller to the XUL window if it's not already present.
    *
    * @param nsIDOMWindow aWindow
    *        The browser XUL window.
    * @returns void
    */
-  createController: function HUD_createController(aWindow)
+  createController: function HS_createController(aWindow)
   {
-    if (aWindow.webConsoleCommandController == null) {
+    if (!aWindow.webConsoleCommandController) {
       aWindow.webConsoleCommandController = new CommandController(aWindow);
       aWindow.controllers.insertControllerAt(0,
         aWindow.webConsoleCommandController);
     }
   },
 
   /**
    * Animates the Console appropriately.
@@ -3055,18 +1454,18 @@ HUD_SERVICE.prototype =
   /**
    * Reset the height of the Web Console.
    *
    * @param string aHUDId The ID of the Web Console.
    */
   resetHeight: function HS_resetHeight(aHUDId)
   {
     let HUD = this.hudReferences[aHUDId];
-    let innerHeight = HUD.contentWindow.innerHeight;
-    let chromeWindow = HUD.chromeDocument.defaultView;
+    let innerHeight = HUD.browser.innerHeight;
+    let chromeWindow = HUD.chromeWindow;
     if (!HUD.consolePanel) {
       let splitterStyle = chromeWindow.getComputedStyle(HUD.splitter, null);
       innerHeight += parseInt(splitterStyle.height) +
                      parseInt(splitterStyle.borderTopWidth) +
                      parseInt(splitterStyle.borderBottomWidth);
     }
 
     let boxStyle = chromeWindow.getComputedStyle(HUD.HUDBox, null);
@@ -3135,185 +1534,92 @@ HUD_SERVICE.prototype =
       // copied output.
       if (i > 0 && item.classList.contains("webconsole-new-group")) {
         newGroup = true;
       }
 
       // Ensure the selected item hasn't been filtered by type or string.
       if (!item.classList.contains("hud-filtered-by-type") &&
           !item.classList.contains("hud-filtered-by-string")) {
-        let timestampString = ConsoleUtils.timestampString(item.timestamp);
+        let timestampString = l10n.timestampString(item.timestamp);
         if (newGroup) {
           strings.push("--");
           newGroup = false;
         }
         strings.push("[" + timestampString + "] " + item.clipboardText);
       }
     }
     clipboardHelper.copyString(strings.join("\n"));
   }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplay
 //////////////////////////////////////////////////////////////////////////
 
-/*
+/**
  * HeadsUpDisplay is an interactive console initialized *per tab*  that
  * displays console log data as well as provides an interactive terminal to
  * manipulate the current tab's document content.
- * */
-function HeadsUpDisplay(aConfig)
+ *
+ * @param nsIDOMElement aTab
+ *        The xul:tab for which you want the HeadsUpDisplay object.
+ */
+function HeadsUpDisplay(aTab)
 {
-  // sample config: { parentNode: aDOMNode,
-  //                  // or
-  //                  parentNodeId: "myHUDParent123",
-  //
-  //                  placement: "appendChild"
-  //                  // or
-  //                  placement: "insertBefore",
-  //                  placementChildNodeIndex: 0,
-  //                }
-
-  this.HUDBox = null;
-
-  if (aConfig.parentNode) {
-    // TODO: need to replace these DOM calls with internal functions
-    // that operate on each application's node structure
-    // better yet, we keep these functions in a "bridgeModule" or the HUDService
-    // to keep a registry of nodeGetters for each application
-    // see bug 568647
-    this.parentNode = aConfig.parentNode;
-    this.notificationBox = aConfig.parentNode;
-    this.chromeDocument = aConfig.parentNode.ownerDocument;
-    this.contentWindow = aConfig.contentWindow;
-    this.uriSpec = aConfig.contentWindow.location.href;
-    this.hudId = "hud_" + aConfig.parentNode.getAttribute("id");
+  this.tab = aTab;
+  this.hudId = "hud_" + this.tab.linkedPanel;
+  this.chromeDocument = this.tab.ownerDocument;
+  this.chromeWindow = this.chromeDocument.defaultView;
+  this.notificationBox = this.chromeDocument.getElementById(this.tab.linkedPanel);
+  this.browser = this.tab.linkedBrowser;
+
+  // create a panel dynamically and attach to the parentNode
+  this.createHUD();
+
+  this.HUDBox.lastTimestamp = 0;
+
+  // create the JSTerm input element
+  let usegcli = false;
+
+  if (usegcli) {
+    let contentWindow = this.browser.contentWindow;
+    this.gcliterm = new GcliTerm(contentWindow, this.hudId, this.chromeDocument,
+                                 contentWindow.console, this.hintNode);
+    this.consoleWrap.appendChild(this.gcliterm.element);
   }
   else {
-    // parentNodeId is the node's id where we attach the HUD
-    // TODO: is the "navigator:browser" below used in all Gecko Apps?
-    // see bug 568647
-    let windowEnum = Services.wm.getEnumerator("navigator:browser");
-    let parentNode;
-    let contentDocument;
-    let contentWindow;
-    let chromeDocument;
-
-    // TODO: the following  part is still very Firefox specific
-    // see bug 568647
-
-    while (windowEnum.hasMoreElements()) {
-      let window = windowEnum.getNext();
-      try {
-        let gBrowser = window.gBrowser;
-        let _browsers = gBrowser.browsers;
-        let browserLen = _browsers.length;
-
-        for (var i = 0; i < browserLen; i++) {
-          var _notificationBox = gBrowser.getNotificationBox(_browsers[i]);
-          this.notificationBox = _notificationBox;
-
-          if (_notificationBox.getAttribute("id") == aConfig.parentNodeId) {
-            this.parentNodeId = _notificationBox.getAttribute("id");
-            this.hudId = "hud_" + this.parentNodeId;
-
-            parentNode = _notificationBox;
-
-            this.contentDocument =
-              _notificationBox.childNodes[0].contentDocument;
-            this.contentWindow =
-              _notificationBox.childNodes[0].contentWindow;
-            this.uriSpec = aConfig.contentWindow.location.href;
-
-            this.chromeDocument =
-              _notificationBox.ownerDocument;
-
-            break;
-          }
-        }
-      }
-      catch (ex) {
-        Cu.reportError(ex);
-      }
-
-      if (parentNode) {
-        break;
-      }
-    }
-    if (!parentNode) {
-      throw new Error(this.ERRORS.PARENTNODE_NOT_FOUND);
-    }
-    this.parentNode = parentNode;
-    this.notificationBox = parentNode;
+    this.jsterm = new JSTerm(this);
   }
 
-  // create textNode Factory:
-  this.textFactory = NodeFactory("text", "xul", this.chromeDocument);
-
-  this.chromeWindow = this.chromeDocument.defaultView;
-
-  // create a panel dynamically and attach to the parentNode
-  this.createHUD();
-
-  this.HUDBox.lastTimestamp = 0;
-  // create the JSTerm input element
-  try {
-    this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    if (this.jsterm) {
-      this.jsterm.inputNode.focus();
-    }
-    if (this.gcliterm) {
-      this.gcliterm.inputNode.focus();
-    }
+  if (this.jsterm) {
+    this.jsterm.inputNode.focus();
   }
-  catch (ex) {
-    Cu.reportError(ex);
+  else if (this.gcliterm) {
+    this.gcliterm.inputNode.focus();
   }
 
   // A cache for tracking repeated CSS Nodes.
   this.cssNodes = {};
 }
 
 HeadsUpDisplay.prototype = {
-
   consolePanel: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   get mainPopupSet()
   {
     return this.chromeDocument.getElementById("mainPopupSet");
   },
 
   /**
-   * Get the tab associated to the HeadsUpDisplay object.
-   */
-  get tab()
-  {
-    // TODO: we should only keep a reference to the tab object and use
-    // getters to determine the rest of objects we need - the chrome window,
-    // document, etc. We should simplify the entire code to use only a single
-    // tab object ref. See bug 656231.
-    let tab = null;
-    let id = this.notificationBox.id;
-    Array.some(this.chromeDocument.defaultView.gBrowser.tabs, function(aTab) {
-      if (aTab.linkedPanel == id) {
-        tab = aTab;
-        return true;
-      }
-    });
-
-    return tab;
-  },
-
-  /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    */
   createOwnWindowPanel: function HUD_createOwnWindowPanel()
   {
     if (this.uiInOwnWindow) {
       return this.consolePanel;
     }
@@ -3460,17 +1766,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function HUD_getPanelTitle()
   {
-    return this.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -3565,82 +1871,26 @@ HeadsUpDisplay.prototype = {
       this.jsterm.inputNode.focus();
     }
     if (this.gcliterm) {
       this.gcliterm.inputNode.focus();
     }
   },
 
   /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @returns string
-   */
-  getStr: function HUD_getStr(aName)
-  {
-    return stringBundle.GetStringFromName(aName);
-  },
-
-  /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @param array aArray
-   * @returns string
-   */
-  getFormatStr: function HUD_getFormatStr(aName, aArray)
-  {
-    return stringBundle.formatStringFromName(aName, aArray, aArray.length);
-  },
-
-  /**
    * The JSTerm object that contains the console's inputNode
-   *
    */
   jsterm: null,
 
   /**
-   * The GcliTerm object that contains the console's GCLI
+   * FIXME: The GcliTerm object that contains the console's GCLI
    */
   gcliterm: null,
 
-  /**
-   * creates and attaches the console input node
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns void
-   */
-  createConsoleInput:
-  function HUD_createConsoleInput(aWindow, aParentNode, aExistingConsole)
-  {
-    let usegcli = false;
-    try {
-      usegcli = Services.prefs.getBoolPref("devtools.gcli.enable");
-    }
-    catch (ex) {}
-
-    if (appName() == "FIREFOX") {
-      if (!usegcli) {
-        let context = Cu.getWeakReference(aWindow);
-        let mixin = new JSTermFirefoxMixin(context, aParentNode,
-                                           aExistingConsole);
-        this.jsterm = new JSTerm(context, aParentNode, mixin, this.console);
-      }
-      else {
-        this.gcliterm = new GcliTerm(aWindow, this.hudId, this.chromeDocument,
-                                     this.console, this.hintNode, this.consoleWrap);
-        aParentNode.appendChild(this.gcliterm.element);
-      }
-    }
-    else {
-      throw new Error("Unsupported Gecko Application");
-    }
-  },
-
+  //FIXME deal with cached console messages
   /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
    * @returns void
    */
   displayCachedConsoleMessages: function HUD_displayCachedConsoleMessages()
   {
@@ -3684,45 +1934,16 @@ HeadsUpDisplay.prototype = {
     if (numChildren && this.outputNode.clientHeight) {
       // We also check the clientHeight to force a reflow, otherwise
       // ensureIndexIsVisible() does not work after outputNode.hidden = false.
       this.outputNode.ensureIndexIsVisible(numChildren - 1);
     }
   },
 
   /**
-   * Re-attaches a console when the contentWindow is recreated
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  reattachConsole: function HUD_reattachConsole(aContentWindow)
-  {
-    this.contentWindow = aContentWindow;
-    this.contentDocument = this.contentWindow.document;
-    this.uriSpec = this.contentWindow.location.href;
-
-    if (this.consolePanel) {
-      this.consolePanel.label = this.getPanelTitle();
-    }
-
-    if (this.jsterm) {
-      this.jsterm.context = Cu.getWeakReference(this.contentWindow);
-      this.jsterm.console = this.console;
-      this.jsterm.createSandbox();
-    }
-    else if (this.gcliterm) {
-      this.gcliterm.reattachConsole(this.contentWindow, this.console);
-    }
-    else {
-      this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    }
-  },
-
-  /**
    * Shortcut to make XUL nodes
    *
    * @param string aTag
    * @returns nsIDOMNode
    */
   makeXULNode:
   function HUD_makeXULNode(aTag)
   {
@@ -3731,45 +1952,42 @@ HeadsUpDisplay.prototype = {
 
   /**
    * Build the UI of each HeadsUpDisplay
    *
    * @returns nsIDOMNode
    */
   makeHUDNodes: function HUD_makeHUDNodes()
   {
-    let self = this;
-
     this.splitter = this.makeXULNode("splitter");
     this.splitter.setAttribute("class", "hud-splitter");
 
     this.HUDBox = this.makeXULNode("vbox");
     this.HUDBox.setAttribute("id", this.hudId);
     this.HUDBox.setAttribute("class", "hud-box animated");
     this.HUDBox.style.height = 0;
 
     let outerWrap = this.makeXULNode("vbox");
     outerWrap.setAttribute("class", "hud-outer-wrapper");
     outerWrap.setAttribute("flex", "1");
 
     let consoleCommandSet = this.makeXULNode("commandset");
     outerWrap.appendChild(consoleCommandSet);
 
-    let consoleWrap = this.makeXULNode("vbox");
-    this.consoleWrap = consoleWrap;
-    consoleWrap.setAttribute("class", "hud-console-wrapper");
-    consoleWrap.setAttribute("flex", "1");
+    this.consoleWrap = this.makeXULNode("vbox");
+    this.consoleWrap.setAttribute("class", "hud-console-wrapper");
+    this.consoleWrap.setAttribute("flex", "1");
 
     this.filterSpacer = this.makeXULNode("spacer");
     this.filterSpacer.setAttribute("flex", "1");
 
     this.filterBox = this.makeXULNode("textbox");
     this.filterBox.setAttribute("class", "compact hud-filter-box");
     this.filterBox.setAttribute("hudId", this.hudId);
-    this.filterBox.setAttribute("placeholder", this.getStr("stringFilter"));
+    this.filterBox.setAttribute("placeholder", l10n.getStr("stringFilter"));
     this.filterBox.setAttribute("type", "search");
 
     this.setFilterTextBoxEvents();
 
     this.createConsoleMenu(this.consoleWrap);
 
     this.filterPrefs = HUDService.getDefaultFilterPrefs(this.hudId);
 
@@ -3797,24 +2015,24 @@ HeadsUpDisplay.prototype = {
     this.outputNode.setAttribute("orient", "vertical");
     this.outputNode.setAttribute("context", this.hudId + "-output-contextmenu");
     this.outputNode.setAttribute("style", "direction: ltr;");
     this.outputNode.setAttribute("seltype", "multiple");
 
     hbox.appendChild(hintParentNode);
     hbox.appendChild(this.outputNode);
 
-    consoleWrap.appendChild(consoleFilterToolbar);
-    consoleWrap.appendChild(hbox);
-
-    outerWrap.appendChild(consoleWrap);
+    this.consoleWrap.appendChild(consoleFilterToolbar);
+    this.consoleWrap.appendChild(hbox);
+
+    outerWrap.appendChild(this.consoleWrap);
 
     this.HUDBox.lastTimestamp = 0;
 
-    this.jsTermParentNode = outerWrap;
+    this.jsTermParentNode = this.consoleWrap;
     this.HUDBox.appendChild(outerWrap);
 
     return this.HUDBox;
   },
 
   /**
    * sets the click events for all binary toggle filter buttons
    *
@@ -3937,38 +2155,38 @@ HeadsUpDisplay.prototype = {
       this.positionConsole("below");
     }).bind(this);
     this._positionConsoleWindow = (function HUD_positionWindow() {
       this.positionConsole("window");
     }).bind(this);
 
     let button = this.makeXULNode("toolbarbutton");
     button.setAttribute("type", "menu");
-    button.setAttribute("label", this.getStr("webConsolePosition"));
-    button.setAttribute("tooltip", this.getStr("webConsolePositionTooltip"));
+    button.setAttribute("label", l10n.getStr("webConsolePosition"));
+    button.setAttribute("tooltip", l10n.getStr("webConsolePositionTooltip"));
 
     let menuPopup = this.makeXULNode("menupopup");
     button.appendChild(menuPopup);
 
     let itemAbove = this.makeXULNode("menuitem");
-    itemAbove.setAttribute("label", this.getStr("webConsolePositionAbove"));
+    itemAbove.setAttribute("label", l10n.getStr("webConsolePositionAbove"));
     itemAbove.setAttribute("type", "checkbox");
     itemAbove.setAttribute("autocheck", "false");
     itemAbove.addEventListener("command", this._positionConsoleAbove, false);
     menuPopup.appendChild(itemAbove);
 
     let itemBelow = this.makeXULNode("menuitem");
-    itemBelow.setAttribute("label", this.getStr("webConsolePositionBelow"));
+    itemBelow.setAttribute("label", l10n.getStr("webConsolePositionBelow"));
     itemBelow.setAttribute("type", "checkbox");
     itemBelow.setAttribute("autocheck", "false");
     itemBelow.addEventListener("command", this._positionConsoleBelow, false);
     menuPopup.appendChild(itemBelow);
 
     let itemWindow = this.makeXULNode("menuitem");
-    itemWindow.setAttribute("label", this.getStr("webConsolePositionWindow"));
+    itemWindow.setAttribute("label", l10n.getStr("webConsolePositionWindow"));
     itemWindow.setAttribute("type", "checkbox");
     itemWindow.setAttribute("autocheck", "false");
     itemWindow.addEventListener("command", this._positionConsoleWindow, false);
     menuPopup.appendChild(itemWindow);
 
     this.positionMenuitems = {
       last: null,
       above: itemAbove,
@@ -3991,38 +2209,38 @@ HeadsUpDisplay.prototype = {
     let id = this.hudId + "-output-contextmenu";
     menuPopup.setAttribute("id", id);
     menuPopup.addEventListener("popupshowing", function() {
       saveBodiesItem.setAttribute("checked",
         HUDService.saveRequestAndResponseBodies);
     }, true);
 
     let saveBodiesItem = this.makeXULNode("menuitem");
-    saveBodiesItem.setAttribute("label", this.getStr("saveBodies.label"));
+    saveBodiesItem.setAttribute("label", l10n.getStr("saveBodies.label"));
     saveBodiesItem.setAttribute("accesskey",
-                                 this.getStr("saveBodies.accesskey"));
+                                 l10n.getStr("saveBodies.accesskey"));
     saveBodiesItem.setAttribute("type", "checkbox");
     saveBodiesItem.setAttribute("buttonType", "saveBodies");
     saveBodiesItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
     menuPopup.appendChild(saveBodiesItem);
 
     menuPopup.appendChild(this.makeXULNode("menuseparator"));
 
     let copyItem = this.makeXULNode("menuitem");
-    copyItem.setAttribute("label", this.getStr("copyCmd.label"));
-    copyItem.setAttribute("accesskey", this.getStr("copyCmd.accesskey"));
+    copyItem.setAttribute("label", l10n.getStr("copyCmd.label"));
+    copyItem.setAttribute("accesskey", l10n.getStr("copyCmd.accesskey"));
     copyItem.setAttribute("key", "key_copy");
     copyItem.setAttribute("command", "cmd_copy");
     copyItem.setAttribute("buttonType", "copy");
     menuPopup.appendChild(copyItem);
 
     let selectAllItem = this.makeXULNode("menuitem");
-    selectAllItem.setAttribute("label", this.getStr("selectAllCmd.label"));
+    selectAllItem.setAttribute("label", l10n.getStr("selectAllCmd.label"));
     selectAllItem.setAttribute("accesskey",
-                               this.getStr("selectAllCmd.accesskey"));
+                               l10n.getStr("selectAllCmd.accesskey"));
     selectAllItem.setAttribute("hudId", this.hudId);
     selectAllItem.setAttribute("buttonType", "selectAll");
     selectAllItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
     menuPopup.appendChild(selectAllItem);
 
     aConsoleWrapper.appendChild(menuPopup);
     aConsoleWrapper.setAttribute("context", id);
   },
@@ -4043,30 +2261,30 @@ HeadsUpDisplay.prototype = {
     let toolbarButton = this.makeXULNode("toolbarbutton");
     aParent.appendChild(toolbarButton);
 
     let toggleFilter = HeadsUpDisplayUICommands.toggleFilter;
     toolbarButton.addEventListener("click", toggleFilter, false);
 
     let name = aDescriptor.name;
     toolbarButton.setAttribute("type", "menu-button");
-    toolbarButton.setAttribute("label", this.getStr("btn" + name));
-    toolbarButton.setAttribute("tooltip", this.getStr("tip" + name));
+    toolbarButton.setAttribute("label", l10n.getStr("btn" + name));
+    toolbarButton.setAttribute("tooltip", l10n.getStr("tip" + name));
     toolbarButton.setAttribute("category", aDescriptor.category);
     toolbarButton.setAttribute("hudId", this.hudId);
     toolbarButton.classList.add("webconsole-filter-button");
 
     let menuPopup = this.makeXULNode("menupopup");
     toolbarButton.appendChild(menuPopup);
 
     let someChecked = false;
     for (let i = 0; i < aDescriptor.severities.length; i++) {
       let severity = aDescriptor.severities[i];
       let menuItem = this.makeXULNode("menuitem");
-      menuItem.setAttribute("label", this.getStr("btn" + severity.name));
+      menuItem.setAttribute("label", l10n.getStr("btn" + severity.name));
       menuItem.setAttribute("type", "checkbox");
       menuItem.setAttribute("autocheck", "false");
       menuItem.setAttribute("hudId", this.hudId);
 
       let prefKey = severity.prefKey;
       menuItem.setAttribute("prefKey", prefKey);
 
       let checked = this.filterPrefs[prefKey];
@@ -4123,17 +2341,17 @@ HeadsUpDisplay.prototype = {
         hud.jsterm.clearOutput(true);
       }
       if (hud.gcliterm) {
         hud.gcliterm.clearOutput();
       }
     }
 
     let clearButton = this.makeXULNode("toolbarbutton");
-    clearButton.setAttribute("label", this.getStr("btnClear"));
+    clearButton.setAttribute("label", l10n.getStr("btnClear"));
     clearButton.classList.add("webconsole-clear-console-button");
     clearButton.addEventListener("command", HUD_clearButton_onCommand, false);
 
     aToolbar.appendChild(clearButton);
   },
 
   /**
    * Destroy the property inspector message node. This performs the necessary
@@ -4166,28 +2384,16 @@ HeadsUpDisplay.prototype = {
       let positionPref = Services.prefs.getCharPref("devtools.webconsole.position");
       this.positionConsole(positionPref);
     }
     return this.HUDBox;
   },
 
   uiInOwnWindow: false,
 
-  get console() { return this.contentWindow.wrappedJSObject.console; },
-
-  getLogCount: function HUD_getLogCount()
-  {
-    return this.outputNode.childNodes.length;
-  },
-
-  getLogNodes: function HUD_getLogNodes()
-  {
-    return this.outputNode.childNodes;
-  },
-
   ERRORS: {
     HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
     TAB_ID_REQUIRED: "Tab DOM ID is required",
     PARENTNODE_NOT_FOUND: "parentNode element not found"
   },
 
   /**
    * Destroy the HUD object. Call this method to avoid memory leaks when the Web
@@ -4207,59 +2413,72 @@ HeadsUpDisplay.prototype = {
     this.positionMenuitems.below.removeEventListener("command",
       this._positionConsoleBelow, false);
     this.positionMenuitems.window.removeEventListener("command",
       this._positionConsoleWindow, false);
 
     this.closeButton.removeEventListener("command",
       this.closeButtonOnCommand, false);
   },
+
+  // TODO: add a comment
+  makeOutputMessageLink: function HUD_makeOutputMessageLink(aNode, aCallback)
+  {
+    let linkNode;
+    if (aNode.category === CATEGORY_NETWORK) {
+      linkNode = aNode.querySelector(".webconsole-msg-link");
+    }
+    else {
+      linkNode = aNode.querySelector(".webconsole-msg-body");
+      linkNode.classList.add("hud-clickable");
+    }
+
+    linkNode.setAttribute("aria-haspopup", "true");
+
+    aNode.addEventListener("mousedown", function(aEvent) {
+      this._startX = aEvent.clientX;
+      this._startY = aEvent.clientY;
+    }, false);
+
+    aNode.addEventListener("click", function(aEvent) {
+      if (aEvent.detail != 1 || aEvent.button != 0 ||
+          (this._startX != aEvent.clientX &&
+           this._startY != aEvent.clientY)) {
+        return;
+      }
+
+      aCallback(this, aEvent);
+    }, false);
+  },
 };
 
 
 //////////////////////////////////////////////////////////////////////////////
-// ConsoleAPIObserver
+// WebConsoleObserver
 //////////////////////////////////////////////////////////////////////////////
 
-let ConsoleAPIObserver = {
-
+let WebConsoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
-  init: function CAO_init()
+  init: function WCO_init()
   {
     Services.obs.addObserver(this, "quit-application-granted", false);
-    Services.obs.addObserver(this, "console-api-log-event", false);
   },
 
-  observe: function CAO_observe(aMessage, aTopic, aData)
+  observe: function WCO_observe(aMessage, aTopic, aData)
   {
-    if (aTopic == "console-api-log-event") {
-      aMessage = aMessage.wrappedJSObject;
-      let windowId = parseInt(aData);
-      let win = HUDService.getWindowByWindowId(windowId);
-      if (!win)
-        return;
-
-      // Find the HUD ID for the topmost window
-      let hudId = HUDService.getHudIdByWindow(win.top);
-      if (!hudId)
-        return;
-
-      HUDService.logConsoleAPIMessage(hudId, aMessage);
-    }
-    else if (aTopic == "quit-application-granted") {
+    if (aTopic == "quit-application-granted") {
       HUDService.shutdown();
     }
   },
 
-  shutdown: function CAO_shutdown()
+  uninit: function WCO_uninit()
   {
     Services.obs.removeObserver(this, "quit-application-granted");
-    Services.obs.removeObserver(this, "console-api-log-event");
-  }
+  },
 };
 
 /**
  * Creates a DOM Node factory for XUL nodes - as well as textNodes
  * @param aFactoryType "xul" or "text"
  * @param ignored This parameter is currently ignored, and will be removed
  * See bug 594304
  * @param aDocument The document, the factory is to generate nodes from
@@ -4281,991 +2500,541 @@ function NodeFactory(aFactoryType, ignor
     }
   }
   else {
     throw new Error('NodeFactory: Unknown factory type: ' + aFactoryType);
   }
 }
 
 //////////////////////////////////////////////////////////////////////////
-// JS Completer
-//////////////////////////////////////////////////////////////////////////
-
-const STATE_NORMAL = 0;
-const STATE_QUOTE = 2;
-const STATE_DQUOTE = 3;
-
-const OPEN_BODY = '{[('.split('');
-const CLOSE_BODY = '}])'.split('');
-const OPEN_CLOSE_BODY = {
-  '{': '}',
-  '[': ']',
-  '(': ')'
-};
-
-/**
- * Analyses a given string to find the last statement that is interesting for
- * later completion.
- *
- * @param   string aStr
- *          A string to analyse.
- *
- * @returns object
- *          If there was an error in the string detected, then a object like
- *
- *            { err: "ErrorMesssage" }
- *
- *          is returned, otherwise a object like
- *
- *            {
- *              state: STATE_NORMAL|STATE_QUOTE|STATE_DQUOTE,
- *              startPos: index of where the last statement begins
- *            }
- */
-function findCompletionBeginning(aStr)
-{
-  let bodyStack = [];
-
-  let state = STATE_NORMAL;
-  let start = 0;
-  let c;
-  for (let i = 0; i < aStr.length; i++) {
-    c = aStr[i];
-
-    switch (state) {
-      // Normal JS state.
-      case STATE_NORMAL:
-        if (c == '"') {
-          state = STATE_DQUOTE;
-        }
-        else if (c == '\'') {
-          state = STATE_QUOTE;
-        }
-        else if (c == ';') {
-          start = i + 1;
-        }
-        else if (c == ' ') {
-          start = i + 1;
-        }
-        else if (OPEN_BODY.indexOf(c) != -1) {
-          bodyStack.push({
-            token: c,
-            start: start
-          });
-          start = i + 1;
-        }
-        else if (CLOSE_BODY.indexOf(c) != -1) {
-          var last = bodyStack.pop();
-          if (!last || OPEN_CLOSE_BODY[last.token] != c) {
-            return {
-              err: "syntax error"
-            };
-          }
-          if (c == '}') {
-            start = i + 1;
-          }
-          else {
-            start = last.start;
-          }
-        }
-        break;
-
-      // Double quote state > " <
-      case STATE_DQUOTE:
-        if (c == '\\') {
-          i ++;
-        }
-        else if (c == '\n') {
-          return {
-            err: "unterminated string literal"
-          };
-        }
-        else if (c == '"') {
-          state = STATE_NORMAL;
-        }
-        break;
-
-      // Single quoate state > ' <
-      case STATE_QUOTE:
-        if (c == '\\') {
-          i ++;
-        }
-        else if (c == '\n') {
-          return {
-            err: "unterminated string literal"
-          };
-          return;
-        }
-        else if (c == '\'') {
-          state = STATE_NORMAL;
-        }
-        break;
-    }
-  }
-
-  return {
-    state: state,
-    startPos: start
-  };
-}
-
-/**
- * Provides a list of properties, that are possible matches based on the passed
- * scope and inputValue.
- *
- * @param object aScope
- *        Scope to use for the completion.
- *
- * @param string aInputValue
- *        Value that should be completed.
- *
- * @returns null or object
- *          If no completion valued could be computed, null is returned,
- *          otherwise a object with the following form is returned:
- *            {
- *              matches: [ string, string, string ],
- *              matchProp: Last part of the inputValue that was used to find
- *                         the matches-strings.
- *            }
- */
-function JSPropertyProvider(aScope, aInputValue)
-{
-  let obj = unwrap(aScope);
-
-  // Analyse the aInputValue and find the beginning of the last part that
-  // should be completed.
-  let beginning = findCompletionBeginning(aInputValue);
-
-  // There was an error analysing the string.
-  if (beginning.err) {
-    return null;
-  }
-
-  // If the current state is not STATE_NORMAL, then we are inside of an string
-  // which means that no completion is possible.
-  if (beginning.state != STATE_NORMAL) {
-    return null;
-  }
-
-  let completionPart = aInputValue.substring(beginning.startPos);
-
-  // Don't complete on just an empty string.
-  if (completionPart.trim() == "") {
-    return null;
-  }
-
-  let properties = completionPart.split('.');
-  let matchProp;
-  if (properties.length > 1) {
-    matchProp = properties.pop().trimLeft();
-    for (let i = 0; i < properties.length; i++) {
-      let prop = properties[i].trim();
-
-      // If obj is undefined or null, then there is no chance to run completion
-      // on it. Exit here.
-      if (typeof obj === "undefined" || obj === null) {
-        return null;
-      }
-
-      // Check if prop is a getter function on obj. Functions can change other
-      // stuff so we can't execute them to get the next object. Stop here.
-      if (isNonNativeGetter(obj, prop)) {
-        return null;
-      }
-      try {
-        obj = obj[prop];
-      }
-      catch (ex) {
-        return null;
-      }
-    }
-  }
-  else {
-    matchProp = properties[0].trimLeft();
-  }
-
-  // If obj is undefined or null, then there is no chance to run
-  // completion on it. Exit here.
-  if (typeof obj === "undefined" || obj === null) {
-    return null;
-  }
-
-  // Skip Iterators and Generators.
-  if (isIteratorOrGenerator(obj)) {
-    return null;
-  }
-
-  let matches = [];
-  for (let prop in obj) {
-    if (prop.indexOf(matchProp) == 0) {
-      matches.push(prop);
-    }
-  }
-
-  return {
-    matchProp: matchProp,
-    matches: matches.sort(),
-  };
-}
-
-function isIteratorOrGenerator(aObject)
-{
-  if (aObject === null) {
-    return false;
-  }
-
-  if (typeof aObject == "object") {
-    if (typeof aObject.__iterator__ == "function" ||
-        aObject.constructor && aObject.constructor.name == "Iterator") {
-      return true;
-    }
-
-    try {
-      let str = aObject.toString();
-      if (typeof aObject.next == "function" &&
-          str.indexOf("[object Generator") == 0) {
-        return true;
-      }
-    }
-    catch (ex) {
-      // window.history.next throws in the typeof check above.
-      return false;
-    }
-  }
-
-  return false;
-}
-
-//////////////////////////////////////////////////////////////////////////
 // JSTerm
 //////////////////////////////////////////////////////////////////////////
 
 /**
- * JSTermHelper
+ * Create a JSTerminal or attach a JSTerm input node to an existing
+ * HeadsUpDisplay object.
  *
- * Defines a set of functions ("helper functions") that are available from the
- * WebConsole but not from the webpage.
- * A list of helper functions used by Firebug can be found here:
- *   http://getfirebug.com/wiki/index.php/Command_Line_API
+ * @constructor
+ * @param object aHUD
+ *        The HeadsUpDisplay object to attach to.
  */
-function JSTermHelper(aJSTerm)
+function JSTerm(aHUD)
 {
-  /**
-   * Returns the result of document.getElementById(aId).
-   *
-   * @param string aId
-   *        A string that is passed to window.document.getElementById.
-   * @returns nsIDOMNode or null
-   */
-  aJSTerm.sandbox.$ = function JSTH_$(aId)
-  {
-    try {
-      return aJSTerm._window.document.getElementById(aId);
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Returns the result of document.querySelectorAll(aSelector).
-   *
-   * @param string aSelector
-   *        A string that is passed to window.document.querySelectorAll.
-   * @returns array of nsIDOMNode
-   */
-  aJSTerm.sandbox.$$ = function JSTH_$$(aSelector)
-  {
-    try {
-      return aJSTerm._window.document.querySelectorAll(aSelector);
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Runs a xPath query and returns all matched nodes.
-   *
-   * @param string aXPath
-   *        xPath search query to execute.
-   * @param [optional] nsIDOMNode aContext
-   *        Context to run the xPath query on. Uses window.document if not set.
-   * @returns array of nsIDOMNode
-   */
-  aJSTerm.sandbox.$x = function JSTH_$x(aXPath, aContext)
-  {
-    let nodes = [];
-    let doc = aJSTerm._window.document;
-    let aContext = aContext || doc;
-
-    try {
-      let results = doc.evaluate(aXPath, aContext, null,
-                                  Ci.nsIDOMXPathResult.ANY_TYPE, null);
-
-      let node;
-      while (node = results.iterateNext()) {
-        nodes.push(node);
-      }
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-
-    return nodes;
-  };
-
-  /**
-   * Returns the currently selected object in the highlighter.
-   *
-   * @returns nsIDOMNode or null
-   */
-  Object.defineProperty(aJSTerm.sandbox, "$0", {
-    get: function() {
-      let mw = HUDService.currentContext();
-      try {
-        return mw.InspectorUI.selection;
-      }
-      catch (ex) {
-        aJSTerm.console.error(ex.message);
-      }
-    },
-    enumerable: true,
-    configurable: false
-  });
-
-  /**
-   * Clears the output of the JSTerm.
-   */
-  aJSTerm.sandbox.clear = function JSTH_clear()
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm.clearOutput(true);
-  };
-
-  /**
-   * Returns the result of Object.keys(aObject).
-   *
-   * @param object aObject
-   *        Object to return the property names from.
-   * @returns array of string
-   */
-  aJSTerm.sandbox.keys = function JSTH_keys(aObject)
-  {
-    try {
-      return Object.keys(unwrap(aObject));
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-  };
-
-  /**
-   * Returns the values of all properties on aObject.
-   *
-   * @param object aObject
-   *        Object to display the values from.
-   * @returns array of string
-   */
-  aJSTerm.sandbox.values = function JSTH_values(aObject)
-  {
-    let arrValues = [];
-    let obj = unwrap(aObject);
-
-    try {
-      for (let prop in obj) {
-        arrValues.push(obj[prop]);
-      }
-    }
-    catch (ex) {
-      aJSTerm.console.error(ex.message);
-    }
-    return arrValues;
-  };
-
-  /**
-   * Opens a help window in MDC
-   */
-  aJSTerm.sandbox.help = function JSTH_help()
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm._window.open(
-        "https://developer.mozilla.org/AppLinks/WebConsoleHelp?locale=" +
-        aJSTerm._window.navigator.language, "help", "");
-  };
-
-  /**
-   * Inspects the passed aObject. This is done by opening the PropertyPanel.
-   *
-   * @param object aObject
-   *        Object to inspect.
-   * @returns void
-   */
-  aJSTerm.sandbox.inspect = function JSTH_inspect(aObject)
-  {
-    aJSTerm.helperEvaluated = true;
-    let propPanel = aJSTerm.openPropertyPanel(null, unwrap(aObject));
-    propPanel.panel.setAttribute("hudId", aJSTerm.hudId);
-  };
-
-  aJSTerm.sandbox.inspectrules = function JSTH_inspectrules(aNode)
-  {
-    aJSTerm.helperEvaluated = true;
-    let doc = aJSTerm.inputNode.ownerDocument;
-    let win = doc.defaultView;
-    let panel = createElement(doc, "panel", {
-      label: "CSS Rules",
-      titlebar: "normal",
-      noautofocus: "true",
-      noautohide: "true",
-      close: "true",
-      width: 350,
-      height: (win.screen.height / 2)
-    });
-
-    let iframe = createAndAppendElement(panel, "iframe", {
-      src: "chrome://browser/content/devtools/cssruleview.xul",
-      flex: "1",
-    });
-
-    panel.addEventListener("load", function onLoad() {
-      panel.removeEventListener("load", onLoad, true);
-      let doc = iframe.contentDocument;
-      let view = new CssRuleView(doc);
-      doc.documentElement.appendChild(view.element);
-      view.highlight(aNode);
-    }, true);
-
-    let parent = doc.getElementById("mainPopupSet");
-    parent.appendChild(panel);
-
-    panel.addEventListener("popuphidden", function onHide() {
-      panel.removeEventListener("popuphidden", onHide);
-      parent.removeChild(panel);
-    });
-
-    let footer = createElement(doc, "hbox", { align: "end" });
-    createAndAppendElement(footer, "spacer", { flex: 1});
-    createAndAppendElement(footer, "resizer", { dir: "bottomend" });
-    panel.appendChild(footer);
-
-    let anchor = win.gBrowser.selectedBrowser;
-    panel.openPopup(anchor, "end_before", 0, 0, false, false);
-
-  }
-
-  /**
-   * Prints aObject to the output.
-   *
-   * @param object aObject
-   *        Object to print to the output.
-   * @returns void
-   */
-  aJSTerm.sandbox.pprint = function JSTH_pprint(aObject)
-  {
-    aJSTerm.helperEvaluated = true;
-    if (aObject === null || aObject === undefined || aObject === true || aObject === false) {
-      aJSTerm.console.error(HUDService.getStr("helperFuncUnsupportedTypeError"));
-      return;
-    }
-    else if (typeof aObject === TYPEOF_FUNCTION) {
-      aJSTerm.writeOutput(aObject + "\n", CATEGORY_OUTPUT, SEVERITY_LOG);
-      return;
-    }
-
-    let output = [];
-    let pairs = namesAndValuesOf(unwrap(aObject));
-
-    pairs.forEach(function(pair) {
-      output.push("  " + pair.display);
-    });
-
-    aJSTerm.writeOutput(output.join("\n"), CATEGORY_OUTPUT, SEVERITY_LOG);
-  };
-
-  /**
-   * Print a string to the output, as-is.
-   *
-   * @param string aString
-   *        A string you want to output.
-   * @returns void
-   */
-  aJSTerm.sandbox.print = function JSTH_print(aString)
-  {
-    aJSTerm.helperEvaluated = true;
-    aJSTerm.writeOutput("" + aString, CATEGORY_OUTPUT, SEVERITY_LOG);
-  };
-}
-
-/**
- * JSTerm
- *
- * JavaScript Terminal: creates input nodes for console code interpretation
- * and 'JS Workspaces'
- */
-
-/**
- * Create a JSTerminal or attach a JSTerm input node to an existing output node,
- * given by the parent node.
- *
- * @param object aContext
- *        Usually nsIDOMWindow, but doesn't have to be
- * @param nsIDOMNode aParentNode where to attach the JSTerm
- * @param object aMixin
- *        Gecko-app (or Jetpack) specific utility object
- * @param object aConsole
- *        Console object to use within the JSTerm.
- */
-function JSTerm(aContext, aParentNode, aMixin, aConsole)
-{
-  // set the context, attach the UI by appending to aParentNode
-
-  this.application = appName();
-  this.context = aContext;
-  this.parentNode = aParentNode;
-  this.mixins = aMixin;
-  this.console = aConsole;
-  this.document = aParentNode.ownerDocument
-
-  this.setTimeout = aParentNode.ownerDocument.defaultView.setTimeout;
-
-  let node = aParentNode;
-  while (!node.hasAttribute("id")) {
-    node = node.parentNode;
-  }
-  this.hudId = node.getAttribute("id");
-
+  this.hud = aHUD;
+  this.hudId = this.hud.hudId;
+  this.parentNode = this.hud.jsTermParentNode;
+  this.document = this.parentNode.ownerDocument;
+  this.messageManager = this.hud.browser.messageManager;
+
+  // track callback functions registered for specific async requests sent to the
+  // content process.
+  this.asyncRequests = {};
+
+  this.lastCompletion = {};
+  this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
-  this.log = LogFactory("*** JSTerm:");
-  this.autocompletePopup = new AutocompletePopup(aParentNode.ownerDocument);
+  this.autocompletePopup = new AutocompletePopup(this.parentNode.ownerDocument);
   this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
   this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
   this.init();
 }
 
 JSTerm.prototype = {
-
-  propertyProvider: JSPropertyProvider,
-
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   init: function JST_init()
   {
-    this.createSandbox();
-
-    this.inputNode = this.mixins.inputNode;
-    this.outputNode = this.mixins.outputNode;
-    this.completeNode = this.mixins.completeNode;
+    this.setupMessageManager();
+
+    this.generateUI();
 
     this._keyPress = this.keyPress.bind(this);
     this._inputEventHandler = this.inputEventHandler.bind(this);
 
-    this.inputNode.addEventListener("keypress",
-      this._keyPress, false);
-    this.inputNode.addEventListener("input",
-      this._inputEventHandler, false);
-    this.inputNode.addEventListener("keyup",
-      this._inputEventHandler, false);
+    this.inputNode.addEventListener("keypress", this._keyPress, false);
+    this.inputNode.addEventListener("input", this._inputEventHandler, false);
+    this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
   },
 
-  get codeInputString()
-  {
-    return this.inputNode.value;
-  },
-
+  /**
+   * Generates and attaches the UI for an entire JS Workspace or
+   * just the input node used under the console output
+   */
   generateUI: function JST_generateUI()
   {
-    this.mixins.generateUI();
+    this.completeNode = this.hud.makeXULNode("textbox");
+    this.completeNode.setAttribute("class", "jsterm-complete-node");
+    this.completeNode.setAttribute("multiline", "true");
+    this.completeNode.setAttribute("rows", "1");
+
+    this.inputNode = this.hud.makeXULNode("textbox");
+    this.inputNode.setAttribute("class", "jsterm-input-node");
+    this.inputNode.setAttribute("multiline", "true");
+    this.inputNode.setAttribute("rows", "1");
+
+    let inputStack = this.hud.makeXULNode("stack");
+    inputStack.setAttribute("class", "jsterm-stack-node");
+    inputStack.setAttribute("flex", "1");
+    inputStack.appendChild(this.completeNode);
+    inputStack.appendChild(this.inputNode);
+
+    let term = this.hud.makeXULNode("hbox");
+    term.setAttribute("class", "jsterm-input-container");
+    term.setAttribute("style", "direction: ltr;");
+    term.appendChild(inputStack);
+
+    this.parentNode.appendChild(term);
   },
 
-  attachUI: function JST_attachUI()
+  setupMessageManager: function JST_setupMessageManager()
   {
-    this.mixins.attachUI();
+    dump('setupMessageManager');
+    this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
+    this._messageListeners = ["JSTerm:EvalResult", "JSTerm:EvalObject",
+      "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
+      "JSTerm:InspectObject", "WebConsole:ConsoleAPI", "WebConsole:PageError",
+      "WebConsole:NetworkActivity"];
+
+    this._messageListeners.forEach(function(aName) {
+      this.messageManager.addMessageListener(aName, this);
+    }, this);
+
+    this.sendMessageToContent("JSTerm:Init", {hudId: this.hudId});
   },
 
-  createSandbox: function JST_setupSandbox()
+  receiveMessage: function JST_receiveMessage(aMessage)
   {
-    // create a JS Sandbox out of this.context
-    this.sandbox = new Cu.Sandbox(this._window,
-      { sandboxPrototype: this._window, wantXrays: false });
-    this.sandbox.console = this.console;
-    JSTermHelper(this);
+    if (!aMessage.json || aMessage.json.hudId != this.hudId) {
+      Cu.reportError("JSTerm: received message " + aMessage.name +
+                     " from wrong hudId.");
+      dump("JST_receiveMessage chrome " + aMessage.name + " this.hudId " + this.hudId + " aMessage.json.hudId " + aMessage.json.hudId + "\n");
+      return;
+    }
+
+    dump("JST_receiveMessage chrome " + aMessage.name + "\n");
+
+    switch (aMessage.name) {
+      case "JSTerm:EvalResult":
+      case "JSTerm:EvalObject":
+      case "JSTerm:AutocompleteProperties":
+        this.receiveMessageWithCallback(aMessage.json);
+        break;
+      case "JSTerm:ClearOutput":
+        this.clearOutput();
+        break;
+      case "JSTerm:InspectObject":
+        this.handleInspectObject(aMessage.json);
+        break;
+      case "WebConsole:ConsoleAPI":
+        HUDService.logConsoleAPIMessage(this.hudId, aMessage.json);
+        break;
+      case "WebConsole:PageError":
+        HUDService.reportPageError(this.hudId, aMessage.json.category,
+                                   aMessage.json.error);
+        break;
+      case "WebConsole:NetworkActivity":
+        this.handleNetworkActivity(aMessage.json);
+        break;
+    }
   },
 
-  get _window()
+  receiveMessageWithCallback: function JST_receiveMessageWithCallback(aResponse)
   {
-    return this.context.get().QueryInterface(Ci.nsIDOMWindow);
+    if (aResponse.id in this.asyncRequests) {
+      let request = this.asyncRequests[aResponse.id];
+      dump("JST_receiveMessageWithCallback id " + aResponse.id + " name " + request.name + "\n");
+      request.callback(aResponse, request.message);
+      delete this.asyncRequests[aResponse.id];
+    }
+    else {
+      Cu.reportError("receiveMessageWithCallback response for stale request #" + aResponse.id);
+    }
   },
 
+  sendMessageToContent:
+  function JST_sendMessageToContent(aName, aMessage, aCallback)
+  {
+    aMessage.hudId = this.hudId;
+    if (!aMessage.id) {
+      aMessage.id = "HUDChrome-" + HUDService.sequenceId();
+    }
+
+    dump("JST_sendMessageToContent " + aName + " id " + aMessage.id + "\n");
+
+    if (aCallback) {
+      this.asyncRequests[aMessage.id] = {
+        name: aName,
+        message: aMessage,
+        callback: aCallback,
+      };
+    }
+
+    this.messageManager.sendAsyncMessage(aName, aMessage);
+  },
+
   /**
-   * Evaluates a string in the sandbox.
+   * Asynchronously evaluate a string in the content process sandbox.
    *
    * @param string aString
    *        String to evaluate in the sandbox.
-   * @returns something
-   *          The result of the evaluation.
+   * @returns void
    */
-  evalInSandbox: function JST_evalInSandbox(aString)
+  evalInContentSandbox: function JST_evalInContentSandbox(aString, aCallback)
   {
-    // The help function needs to be easy to guess, so we make the () optional
-    if (aString.trim() === "help" || aString.trim() === "?") {
-      aString = "help()";
+    let message = {
+      str: aString,
+      resultCacheId: "HUDEval-" + HUDService.sequenceId(),
+    };
+
+    this.sendMessageToContent("JSTerm:EvalRequest", message, aCallback);
+  },
+
+  _executeResultCallback: function JST__executeResultCallback(aResponse)
+  {
+    let errorMessage = aResponse.errorMessage;
+    let resultString = aResponse.resultString;
+
+    // Hide undefined results coming from JSTerm helper functions.
+    if (!errorMessage && resultString == "undefined" &&
+        aResponse.helperResult && !aResponse.inspectable) {
+      return;
     }
 
-    let window = unwrap(this.sandbox.window);
-    let $ = null, $$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      $ = this.sandbox.$;
-      delete this.sandbox.$;
+    if (aResponse.errorMessage) {
+      this.writeOutput(aResponse.errorMessage, CATEGORY_OUTPUT, SEVERITY_ERROR);
     }
-    if (typeof window.$$ == "function") {
-      $$ = this.sandbox.$$;
-      delete this.sandbox.$$;
+    else if (aResponse.inspectable) {
+      let node = this.writeOutputJS(aResponse.resultString,
+                                    this._evalOutputClick.bind(this, aResponse));
+      node._evalCacheId = aResponse.childrenCacheId;
     }
-
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
-
-    if ($) {
-      this.sandbox.$ = $;
+    else {
+      this.writeOutput(aResponse.resultString, CATEGORY_OUTPUT, SEVERITY_LOG);
     }
-    if ($$) {
-      this.sandbox.$$ = $$;
-    }
-
-    return result;
   },
 
-
   execute: function JST_execute(aExecuteString)
   {
     // attempt to execute the content of the inputNode
     aExecuteString = aExecuteString || this.inputNode.value;
     if (!aExecuteString) {
       this.writeOutput("no value to execute", CATEGORY_OUTPUT, SEVERITY_LOG);
       return;
     }
 
     this.writeOutput(aExecuteString, CATEGORY_INPUT, SEVERITY_LOG);
 
-    try {
-      this.helperEvaluated = false;
-      let result = this.evalInSandbox(aExecuteString);
-
-      // Hide undefined results coming from helpers.
-      let shouldShow = !(result === undefined && this.helperEvaluated);
-      if (shouldShow) {
-        let inspectable = this.isResultInspectable(result);
-        let resultString = this.formatResult(result);
-
-        if (inspectable) {
-          this.writeOutputJS(aExecuteString, result, resultString);
-        }
-        else {
-          this.writeOutput(resultString, CATEGORY_OUTPUT, SEVERITY_LOG);
-        }
-      }
-    }
-    catch (ex) {
-      this.writeOutput("" + ex, CATEGORY_OUTPUT, SEVERITY_ERROR);
-    }
+    this.evalInContentSandbox(aExecuteString,
+                              this._executeResultCallback.bind(this));
 
     this.history.push(aExecuteString);
     this.historyIndex++;
     this.historyPlaceHolder = this.history.length;
     this.setInputValue("");
     this.clearCompletion();
   },
 
   /**
    * Opens a new PropertyPanel. The panel has two buttons: "Update" reexecutes
    * the passed aEvalString and places the result inside of the tree. The other
    * button closes the panel.
    *
-   * @param string aEvalString
-   *        String that was used to eval the aOutputObject. Used as title
-   *        and to update the tree content.
-   * @param object aOutputObject
-   *        Object to display/inspect inside of the tree.
+   * @param object aResponse
+   *        The response object to display/inspect inside of the tree.
    * @param nsIDOMNode aAnchor
    *        A node to popup the panel next to (using "after_pointer").
    * @returns object the created and opened propertyPanel.
    */
-  openPropertyPanel: function JST_openPropertyPanel(aEvalString, aOutputObject,
-                                                    aAnchor)
+  // TODO: update the comments
+  openPropertyPanel: function JST_openPropertyPanel(aOptions)
   {
-    let self = this;
-    let propPanel;
     // The property panel has one button:
     //    `Update`: reexecutes the string executed on the command line. The
     //    result will be inspected by this panel.
     let buttons = [];
 
     // If there is a evalString passed to this function, then add a `Update`
     // button to the panel so that the evalString can be reexecuted to update
     // the content of the panel.
-    if (aEvalString !== null) {
+    if (aOptions.updateButtonCallback) {
       buttons.push({
-        label: HUDService.getStr("update.button"),
-        accesskey: HUDService.getStr("update.accesskey"),
-        oncommand: function () {
-          try {
-            var result = self.evalInSandbox(aEvalString);
-
-            if (result !== undefined) {
-              // TODO: This updates the value of the tree.
-              // However, the states of opened nodes is not saved.
-              // See bug 586246.
-              propPanel.treeView.data = result;
-            }
-          }
-          catch (ex) {
-            self.console.error(ex);
-          }
-        }
+        label: l10n.getStr("update.button"),
+        accesskey: l10n.getStr("update.accesskey"),
+        oncommand: aOptions.updateButtonCallback,
       });
     }
 
-    let doc = self.document;
-    let parent = doc.getElementById("mainPopupSet");
-    let title = (aEvalString
-        ? HUDService.getFormatStr("jsPropertyInspectTitle", [aEvalString])
-        : HUDService.getStr("jsPropertyTitle"));
-
-    propPanel = new PropertyPanel(parent, doc, title, aOutputObject, buttons);
-    propPanel.linkNode = aAnchor;
-
-    let panel = propPanel.panel;
-    panel.openPopup(aAnchor, "after_pointer", 0, 0, false, false);
-    panel.sizeTo(350, 450);
+    let parent = this.document.getElementById("mainPopupSet");
+    let title = aOptions.title ?
+        l10n.getFormatStr("jsPropertyInspectTitle", [aOptions.title]) :
+        l10n.getStr("jsPropertyTitle");
+
+    let propPanel = new PropertyPanel(parent, title, aOptions.data, buttons);
+
+    propPanel.panel.openPopup(aOptions.anchor, "after_pointer", 0, 0, false, false);
+    propPanel.panel.sizeTo(350, 450);
+
+    if (aOptions.anchor) {
+      propPanel.panel.addEventListener("popuphiding", function onPopupHide() {
+        propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+        aOptions.anchor._panelOpen = false;
+      }, false);
+      aOptions.anchor._panelOpen = true;
+    }
+
     return propPanel;
   },
 
+  remoteObjectProvider:
+  function JST_remoteObjectProvider(aCacheId, aObjectId, aResultCacheId, aCallback) {
+    let message = {
+      cacheId: aCacheId,
+      objectId: aObjectId,
+      resultCacheId: aResultCacheId,
+    };
+
+    dump("objectProvider " + message.id + " cacheId " + message.cacheId + " objectId " + message.objectId + " resultCacheId " + message.resultCacheId + "\n");
+
+    this.sendMessageToContent("JSTerm:GetEvalObject", message, aCallback);
+  },
+
+  clearObjectCache: function JST_clearObjectCache(aCacheId)
+  {
+    dump("JST_clearObjectCache " + aCacheId + "\n");
+
+    this.sendMessageToContent("JSTerm:ClearObjectCache", {cacheId: aCacheId});
+  },
+
+  handleInspectObject: function JST_handleInspectObject(aRequest)
+  {
+    let options = {
+      title: aRequest.input,
+
+      data: {
+        rootCacheId: aRequest.objectCacheId,
+        panelCacheId: aRequest.objectCacheId,
+        remoteObject: aRequest.resultObject,
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      dump("panel popuphiding panelCacheId " + options.data.panelCacheId + "\n");
+
+      this.clearObjectCache(options.data.panelCacheId);
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
   /**
    * Writes a JS object to the JSTerm outputNode. If the user clicks on the
    * written object, openPropertyPanel is called to open up a panel to inspect
    * the object.
    *
-   * @param string aEvalString
-   *        String that was evaluated to get the aOutputObject.
-   * @param object aResultObject
-   *        The evaluation result object.
-   * @param object aOutputString
-   *        The output string to be written to the outputNode.
+   * @param object aResponse
+   *        The evaluation result object, coming from the content process.
    */
-  writeOutputJS: function JST_writeOutputJS(aEvalString, aOutputObject, aOutputString)
+  // TODO: update comment.
+  writeOutputJS: function JST_writeOutputJS(aOutputMessage, aCallback)
   {
-    let node = ConsoleUtils.createMessageNode(this.document,
-                                              CATEGORY_OUTPUT,
-                                              SEVERITY_LOG,
-                                              aOutputString,
-                                              this.hudId);
-
-    let linkNode = node.querySelector(".webconsole-msg-body");
-
-    linkNode.classList.add("hud-clickable");
-    linkNode.setAttribute("aria-haspopup", "true");
-
-    // Make the object bring up the property panel.
-    node.addEventListener("mousedown", function(aEvent) {
-      this._startX = aEvent.clientX;
-      this._startY = aEvent.clientY;
-    }, false);
-
-    let self = this;
-    node.addEventListener("click", function(aEvent) {
-      if (aEvent.detail != 1 || aEvent.button != 0 ||
-          (this._startX != aEvent.clientX &&
-           this._startY != aEvent.clientY)) {
-        return;
+    let node = this.writeOutput(aOutputMessage, CATEGORY_OUTPUT, SEVERITY_LOG);
+    if (aCallback) {
+      this.hud.makeOutputMessageLink(node, aCallback);
+    }
+    return node;
+  },
+
+  _evalOutputClick: function JST__evalOutputClick(aResponse, aLinkNode)
+  {
+    if (aLinkNode._panelOpen) {
+      return;
+    }
+
+    let options = {
+      title: aResponse.input,
+      anchor: aLinkNode,
+
+      // Data to inspect.
+      data: {
+        // This is where the resultObject children are cached.
+        rootCacheId: aResponse.childrenCacheId,
+        remoteObject: aResponse.resultObject,
+        // This is where all objects retrieved by the panel will be cached.
+        panelCacheId: "HUDPanel-" + HUDService.sequenceId(),
+        remoteObjectProvider: this.remoteObjectProvider.bind(this),
+      },
+    };
+
+    options.updateButtonCallback = function() {
+      this.evalInContentSandbox(aResponse.input,
+        this._updatePanelCallback.bind(this, options, propPanel, aResponse));
+    }.bind(this);
+
+    let propPanel = this.openPropertyPanel(options);
+    propPanel.panel.setAttribute("hudId", this.hudId);
+
+    let onPopupHide = function() {
+      propPanel.panel.removeEventListener("popuphiding", onPopupHide, false);
+
+      dump("panel popuphiding panelCacheId " + options.data.panelCacheId + " aAnchor.parentNode " + aLinkNode.parentNode + " _evalCacheId " + aLinkNode._evalCacheId + "\n");
+
+      this.clearObjectCache(options.data.panelCacheId);
+
+      if (!aLinkNode.parentNode && aLinkNode._evalCacheId) {
+        this.clearObjectCache(aLinkNode._evalCacheId);
       }
-
-      if (!this._panelOpen) {
-        let propPanel = self.openPropertyPanel(aEvalString, aOutputObject, this);
-        propPanel.panel.setAttribute("hudId", self.hudId);
-        this._panelOpen = true;
+    }.bind(this);
+
+    propPanel.panel.addEventListener("popuphiding", onPopupHide, false);
+  },
+
+  _updatePanelCallback:
+  function JST__updatePanelCallback(aOptions, aPropPanel, aOldResponse,
+                                    aNewResponse)
+  {
+    if (aNewResponse.errorMessage) {
+      this.writeOutput(aNewResponse.errorMessage, CATEGORY_OUTPUT,
+                       SEVERITY_ERROR);
+      return;
+    }
+
+    if (!aNewResponse.inspectable) {
+      // TODO: decide what to do here. clear treeView.data? output an error?
+      return;
+    }
+
+    this.clearObjectCache(aOptions.data.panelCacheId);
+    this.clearObjectCache(aOptions.data.rootCacheId);
+
+    if (aOptions.anchor && aOptions.anchor._evalCacheId) {
+      aOptions.anchor._evalCacheId = aNewResponse.childrenCacheId;
+    }
+
+    // Update the old response object such that when the panel is reopen, the
+    // user sees the new response.
+    aOldResponse.id = aNewResponse.id;
+    aOldResponse.childrenCacheId = aNewResponse.childrenCacheId;
+    aOldResponse.resultObject = aNewResponse.resultObject;
+    aOldResponse.resultString = aNewResponse.resultString;
+
+    aOptions.data.rootCacheId = aNewResponse.childrenCacheId;
+    aOptions.data.remoteObject = aNewResponse.resultObject;
+
+    // TODO: This updates the value of the tree.
+    // However, the states of open nodes is not saved.
+    // See bug 586246.
+    aPropPanel.treeView.data = aOptions.data;
+  },
+
+  handleNetworkActivity: function JST_handleNetworkActivity(aMessage)
+  {
+    dump("JST_handleNetworkActivity stage " + aMessage.stage + "\n");
+
+    if (aMessage.stage == "REQUEST_HEADER") {
+      HUDService.logNetActivity(aMessage);
+      return;
+    }
+
+    let hud = HUDService.getHudReferenceById(aMessage.hudId);
+    let entry = aMessage.log.entries[0];
+    let request = entry.request;
+    let response = entry.response;
+
+    let messageNode = hud.outputNode.
+      querySelector("richlistitem[connectionId=" + entry.connection + "]");
+    if (!messageNode) {
+      dump("JST_handleNetworkActivity: unknown connection ID!\n");
+      return;
+    }
+    messageNode._httpActivity = aMessage;
+
+    if (aMessage.stage == "TRANSACTION_CLOSE" ||
+        aMessage.stage == "RESPONSE_HEADER") {
+      let status = "[" + response.httpVersion + " " + response.status + " " +
+                   response.statusText;
+      if (aMessage.stage == "TRANSACTION_CLOSE") {
+        status += " " + l10n.getFormatStr("NetworkPanel.durationMS",
+                                          [entry.time]);
       }
-    }, false);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
+      status += "]";
+
+      let linkNode = messageNode.querySelector(".webconsole-msg-link");
+      let statusNode = linkNode.querySelector(".webconsole-msg-status");
+      statusNode.setAttribute("value", status);
+
+      messageNode.clipboardText =
+        [request.method, request.url, status].join(" ");
+
+      if (aMessage.stage == "RESPONSE_HEADER" &&
+          response.status >= MIN_HTTP_ERROR_CODE &&
+          response.status <= MAX_HTTP_ERROR_CODE) {
+        ConsoleUtils.setMessageType(messageNode, CATEGORY_NETWORK,
+                                    SEVERITY_ERROR);
+      }
+    }
+
+    if (messageNode._netPanel) {
+      messageNode._netPanel.update();
+    }
   },
 
   /**
    * Writes a message to the HUD that originates from the interactive
    * JavaScript console.
    *
    * @param string aOutputMessage
    *        The message to display.
    * @param number aCategory
    *        The category of message: one of the CATEGORY_ constants.
    * @param number aSeverity
    *        The severity of message: one of the SEVERITY_ constants.
    * @returns void
    */
+  // TODO: update comment.
   writeOutput: function JST_writeOutput(aOutputMessage, aCategory, aSeverity)
   {
-    let node = ConsoleUtils.createMessageNode(this.document,
-                                              aCategory, aSeverity,
-                                              aOutputMessage, this.hudId);
+    let node = ConsoleUtils.createMessageNode(this.document, aCategory,
+                                              aSeverity, aOutputMessage,
+                                              this.hudId);
 
     ConsoleUtils.outputMessageNode(node, this.hudId);
+    return node;
   },
 
-  /**
-   * Format the jsterm execution result based on its type.
-   *
-   * @param mixed aResult
-   *        The evaluation result object you want displayed.
-   * @returns string
-   *          The string that can be displayed.
-   */
-  formatResult: function JST_formatResult(aResult)
+  clearOutput: function JST_clearOutput()
   {
-    let output = "";
-    let type = this.getResultType(aResult);
-
-    switch (type) {
-      case "string":
-        output = this.formatString(aResult);
-        break;
-      case "boolean":
-      case "date":
-      case "error":
-      case "number":
-      case "regexp":
-        output = aResult.toString();
-        break;
-      case "null":
-      case "undefined":
-        output = type;
-        break;
-      default:
-        if (aResult.toSource) {
-          try {
-            output = aResult.toSource();
-          } catch (ex) { }
-        }
-        if (!output || output == "({})") {
-          output = aResult.toString();
-        }
-        break;
-    }
-
-    return output;
-  },
-
-  /**
-   * Format a string for output.
-   *
-   * @param string aString
-   *        The string you want to display.
-   * @returns string
-   *          The string that can be displayed.
-   */
-  formatString: function JST_formatString(aString)
-  {
-    function isControlCode(c) {
-      // See http://en.wikipedia.org/wiki/C0_and_C1_control_codes
-      // C0 is 0x00-0x1F, C1 is 0x80-0x9F (inclusive).
-      // We also include DEL (U+007F) and NBSP (U+00A0), which are not strictly
-      // in C1 but border it.
-      return (c <= 0x1F) || (0x7F <= c && c <= 0xA0);
-    }
-
-    function replaceFn(aMatch, aType, aHex) {
-      // Leave control codes escaped, but unescape the rest of the characters.
-      let c = parseInt(aHex, 16);
-      return isControlCode(c) ? aMatch : String.fromCharCode(c);
-    }
-
-    let output = uneval(aString).replace(/\\(x)([0-9a-fA-F]{2})/g, replaceFn)
-                 .replace(/\\(u)([0-9a-fA-F]{4})/g, replaceFn);
-
-    return output;
-  },
-
-  /**
-   * Determine if the jsterm execution result is inspectable or not.
-   *
-   * @param mixed aResult
-   *        The evaluation result object you want to check if it is inspectable.
-   * @returns boolean
-   *          True if the object is inspectable or false otherwise.
-   */
-  isResultInspectable: function JST_isResultInspectable(aResult)
-  {
-    let isEnumerable = false;
-
-    // Skip Iterators and Generators.
-    if (isIteratorOrGenerator(aResult)) {
-      return false;
-    }
-
-    for (let p in aResult) {
-      isEnumerable = true;
-      break;
-    }
-
-    return isEnumerable && typeof(aResult) != "string";
-  },
-
-  /**
-   * Determine the type of the jsterm execution result.
-   *
-   * @param mixed aResult
-   *        The evaluation result object you want to check.
-   * @returns string
-   *          Constructor name or type: string, number, boolean, regexp, date,
-   *          function, object, null, undefined...
-   */
-  getResultType: function JST_getResultType(aResult)
-  {
-    let type = aResult === null ? "null" : typeof aResult;
-    if (type == "object" && aResult.constructor && aResult.constructor.name) {
-      type = aResult.constructor.name;
-    }
-
-    return type.toLowerCase();
-  },
-
-  /**
-   * Clear the Web Console output.
-   *
-   * @param boolean aClearStorage
-   *        True if you want to clear the console messages storage associated to
-   *        this Web Console.
-   */
-  clearOutput: function JST_clearOutput(aClearStorage)
-  {
-    let hud = HUDService.getHudReferenceById(this.hudId);
-    hud.cssNodes = {};
-
-    let node = hud.outputNode;
-    while (node.firstChild) {
-      if (node.firstChild.classList &&
-          node.firstChild.classList.contains("webconsole-msg-inspector")) {
-        hud.pruneConsoleDirNode(node.firstChild);
+    dump("JST_clearOutput\n"); // FIXME: aClearStorage
+    this.hud.cssNodes = {};
+
+    let outputNode = this.hud.outputNode;
+    let node;
+    while (node = outputNode.firstChild) {
+      if (node._evalCacheId && !node._panelOpen) {
+        this.clearObjectCache(node._evalCacheId);
+      }
+
+      if (node.classList &&
+          node.classList.contains("webconsole-msg-inspector")) {
+        this.hud.pruneConsoleDirNode(node);
       }
       else {
-        hud.outputNode.removeChild(node.firstChild);
+        outputNode.removeChild(node);
       }
     }
 
-    hud.HUDBox.lastTimestamp = 0;
-    hud.groupDepth = 0;
-
-    if (aClearStorage) {
-      let windowId = HUDService.getInnerWindowId(hud.contentWindow);
-      gConsoleStorage.clearEvents(windowId);
-    }
+    this.hud.HUDBox.lastTimestamp = 0;
   },
 
   /**
    * Updates the size of the input field (command line) to fit its contents.
    *
    * @returns void
    */
   resizeInput: function JST_resizeInput()
@@ -5393,21 +3162,25 @@ JSTerm.prototype = {
       case Ci.nsIDOMKeyEvent.DOM_VK_TAB:
         // Generate a completion and accept the first proposed value.
         if (this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion &&
             this.acceptProposedCompletion()) {
           aEvent.preventDefault();
         }
         else {
-          this.updateCompleteNode(HUDService.getStr("Autocomplete.blank"));
+          this.updateCompleteNode(l10n.getStr("Autocomplete.blank"));
           aEvent.preventDefault();
         }
         break;
 
+      case Ci.nsIDOMKeyEvent.DOM_VK_F6:
+        this.hud.browser.focus(); // FIXME: how to focus the contentWindow?
+        break;
+
       default:
         break;
     }
   },
 
   /**
    * Go up/down the history stack of input values.
    *
@@ -5500,27 +3273,27 @@ JSTerm.prototype = {
       return false;
     }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == node.value.length ? true :
            node.selectionStart == 0 && !multiline;
   },
 
-  history: [],
+  history: null,
 
   // Stores the data for the last completion.
   lastCompletion: null,
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
    * only if the selection/cursor is at the end of the string. If no completion
    * is found, the current inputNode value and cursor/selection stay.
    *
-   * @param int type possible values are
+   * @param int aType possible values are:
    *    - this.COMPLETE_FORWARD: If there is more than one possible completion
    *          and the input value stayed the same compared to the last time this
    *          function was called, then the next completion of all possible
    *          completions is used. If the value changed, then the first possible
    *          completion is used and the selection is set from the current
    *          cursor position to the end of the completed text.
    *          If there is only one possible completion, then this completion
    *          value is used and the cursor is put at the end of the completion.
@@ -5532,99 +3305,139 @@ JSTerm.prototype = {
    *          last time this function was called, then the same completion is
    *          used again. If there is only one possible completion, then
    *          the inputNode.value is set to this value and the selection is set
    *          from the current cursor position to the end of the completed text.
    *
    * @returns boolean true if there existed a completion for the current input,
    *          or false otherwise.
    */
-  complete: function JSTF_complete(type)
+  complete: function JSTF_complete(aType)
   {
     let inputNode = this.inputNode;
     let inputValue = inputNode.value;
     // If the inputNode has no value, then don't try to complete on it.
     if (!inputValue) {
       this.clearCompletion();
       return false;
     }
 
     // Only complete if the selection is empty and at the end of the input.
     if (inputNode.selectionStart == inputNode.selectionEnd &&
         inputNode.selectionEnd != inputValue.length) {
       this.clearCompletion();
       return false;
     }
 
+    // Update the completion results.
+    if (this.lastCompletion.value != inputValue) {
+      this.updateCompletionResult(aType);
+      return false;
+    }
+
     let popup = this.autocompletePopup;
-
-    if (!this.lastCompletion || this.lastCompletion.value != inputValue) {
-      let properties = this.propertyProvider(this.sandbox.window, inputValue);
-      if (!properties || !properties.matches.length) {
-        this.clearCompletion();
-        return false;
-      }
-
-      let items = properties.matches.map(function(aMatch) {
-        return {label: aMatch};
-      });
-      popup.setItems(items);
-      this.lastCompletion = {value: inputValue,
-                             matchProp: properties.matchProp};
-
-      if (items.length > 1 && !popup.isOpen) {
-        popup.openPopup(this.inputNode);
-      }
-      else if (items.length < 2 && popup.isOpen) {
-        popup.hidePopup();
-      }
-
-      if (items.length == 1) {
-          popup.selectedIndex = 0;
-      }
-      this.onAutocompleteSelect();
-    }
-
     let accepted = false;
 
-    if (type != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+    if (aType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
       this.acceptProposedCompletion();
       accepted = true;
     }
-    else if (type == this.COMPLETE_BACKWARD) {
-      this.autocompletePopup.selectPreviousItem();
+    else if (aType == this.COMPLETE_BACKWARD) {
+      popup.selectPreviousItem();
     }
-    else if (type == this.COMPLETE_FORWARD) {
-      this.autocompletePopup.selectNextItem();
+    else if (aType == this.COMPLETE_FORWARD) {
+      popup.selectNextItem();
     }
 
     return accepted || popup.itemCount > 0;
   },
 
+  updateCompletionResult: function JST_updateCompletionResult(aType)
+  {
+    if (this.lastCompletion.value == this.inputNode.value) {
+      return;
+    }
+
+    let message = {
+      id: "HUDComplete-" + HUDService.sequenceId(),
+      input: this.inputNode.value,
+    };
+
+    this.lastCompletion = {requestId: message.id, completionType: aType};
+    this.sendMessageToContent("JSTerm:Autocomplete", message,
+                              this.receiveAutocompleteProperties.bind(this));
+  },
+
+  receiveAutocompleteProperties:
+  function JST_receiveAutocompleteProperties(aMessage)
+  {
+    let inputNode = this.inputNode;
+    let inputValue = inputNode.value;
+    if (aMessage.input != inputValue || this.lastCompletion.value == inputValue ||
+        aMessage.id != this.lastCompletion.requestId) {
+      return;
+    }
+
+    let matches = aMessage.matches;
+    if (!matches.length) {
+      this.clearCompletion();
+      return;
+    }
+
+    let items = matches.map(function(aMatch) {
+      return {label: aMatch};
+    });
+
+    let popup = this.autocompletePopup;
+    popup.setItems(items);
+
+    let completionType = this.lastCompletion.completionType;
+    this.lastCompletion = {value: inputValue, matchProp: aMessage.matchProp};
+
+    if (items.length > 1 && !popup.isOpen) {
+      popup.openPopup(inputNode);
+    }
+    else if (items.length < 2 && popup.isOpen) {
+      popup.hidePopup();
+    }
+
+    if (items.length > 0) {
+      popup.selectedIndex = 0;
+      if (items.length == 1) {
+        // onSelect is not fired when the popup is not open.
+        this.onAutocompleteSelect();
+      }
+    }
+
+    if (completionType != this.COMPLETE_HINT_ONLY && popup.itemCount == 1) {
+      this.acceptProposedCompletion();
+    }
+  },
+
   onAutocompleteSelect: function JSTF_onAutocompleteSelect()
   {
     let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion) {
+    if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.updateCompleteNode(suffix);
     }
     else {
       this.updateCompleteNode("");
     }
   },
 
   /**
    * Clear the current completion information and close the autocomplete popup,
    * if needed.
    */
   clearCompletion: function JSTF_clearCompletion()
   {
     this.autocompletePopup.clearItems();
-    this.lastCompletion = null;
+    this.lastCompletion = {};
     this.updateCompleteNode("");
     if (this.autocompletePopup.isOpen) {
       this.autocompletePopup.hidePopup();
     }
   },
 
   /**
    * Accept the proposed input completion.
@@ -5633,17 +3446,17 @@ JSTerm.prototype = {
    *         True if there was a selected completion item and the input value
    *         was updated, false otherwise.
    */
   acceptProposedCompletion: function JSTF_acceptProposedCompletion()
   {
     let updated = false;
 
     let currentItem = this.autocompletePopup.selectedItem;
-    if (currentItem && this.lastCompletion) {
+    if (currentItem && this.lastCompletion.value) {
       let suffix = currentItem.label.substring(this.lastCompletion.
                                                matchProp.length);
       this.setInputValue(this.inputNode.value + suffix);
       updated = true;
     }
 
     this.clearCompletion();
 
@@ -5663,110 +3476,38 @@ JSTerm.prototype = {
     this.completeNode.value = prefix + aSuffix;
   },
 
   /**
    * Destroy the JSTerm object. Call this method to avoid memory leaks.
    */
   destroy: function JST_destroy()
   {
+    this.clearCompletion();
+    this.clearOutput();
+
+    this.autocompletePopup.destroy();
+
+    this.sendMessageToContent("JSTerm:Destroy", {hudId: this.hudId});
+
+    this._messageListeners.forEach(function(aName) {
+      this.messageManager.removeMessageListener(aName, this);
+    }, this);
+
     this.inputNode.removeEventListener("keypress", this._keyPress, false);
     this.inputNode.removeEventListener("input", this._inputEventHandler, false);
     this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
+
+    delete this.asyncRequests;
+    delete this.messageManager;
+    delete this.history;
   },
 };
 
 /**
- * Generates and attaches the JS Terminal part of the Web Console, which
- * essentially consists of the interactive JavaScript input facility.
- *
- * @param nsWeakPtr<nsIDOMWindow> aContext
- *        A weak pointer to the DOM window that contains the Web Console.
- * @param nsIDOMNode aParentNode
- *        The Web Console wrapper node.
- * @param nsIDOMNode aExistingConsole
- *        The Web Console output node.
- * @return void
- */
-function
-JSTermFirefoxMixin(aContext,
-                   aParentNode,
-                   aExistingConsole)
-{
-  // aExisting Console is the existing outputNode to use in favor of
-  // creating a new outputNode - this is so we can just attach the inputNode to
-  // a normal HeadsUpDisplay console output, and re-use code.
-  this.context = aContext;
-  this.parentNode = aParentNode;
-  this.existingConsoleNode = aExistingConsole;
-  this.setTimeout = aParentNode.ownerDocument.defaultView.setTimeout;
-
-  if (aParentNode.ownerDocument) {
-    this.xulElementFactory =
-      NodeFactory("xul", "xul", aParentNode.ownerDocument);
-
-    this.textFactory = NodeFactory("text", "xul", aParentNode.ownerDocument);
-    this.generateUI();
-    this.attachUI();
-  }
-  else {
-    throw new Error("aParentNode should be a DOM node with an ownerDocument property ");
-  }
-}
-
-JSTermFirefoxMixin.prototype = {
-  /**
-   * Generates and attaches the UI for an entire JS Workspace or
-   * just the input node used under the console output
-   *
-   * @returns void
-   */
-  generateUI: function JSTF_generateUI()
-  {
-    this.completeNode = this.xulElementFactory("textbox");
-    this.completeNode.setAttribute("class", "jsterm-complete-node");
-    this.completeNode.setAttribute("multiline", "true");
-    this.completeNode.setAttribute("rows", "1");
-    this.completeNode.setAttribute("tabindex", "-1");
-
-    this.inputNode = this.xulElementFactory("textbox");
-    this.inputNode.setAttribute("class", "jsterm-input-node");
-    this.inputNode.setAttribute("multiline", "true");
-    this.inputNode.setAttribute("rows", "1");
-
-    let inputStack = this.xulElementFactory("stack");
-    inputStack.setAttribute("class", "jsterm-stack-node");
-    inputStack.setAttribute("flex", "1");
-    inputStack.appendChild(this.completeNode);
-    inputStack.appendChild(this.inputNode);
-
-    if (this.existingConsoleNode == undefined) {
-      throw new Error("This can't happen");
-    }
-
-    this.outputNode = this.existingConsoleNode;
-
-    this.term = this.xulElementFactory("hbox");
-    this.term.setAttribute("class", "jsterm-input-container");
-    this.term.setAttribute("style", "direction: ltr;");
-    this.term.appendChild(inputStack);
-  },
-
-  get inputValue()
-  {
-    return this.inputNode.value;
-  },
-
-  attachUI: function JSTF_attachUI()
-  {
-    this.parentNode.appendChild(this.term);
-  }
-};
-
-/**
  * Firefox-specific Application Hooks.
  * Each Gecko-based application will need an object like this in
  * order to use the Heads Up Display
  */
 function FirefoxApplicationHooks()
 { }
 
 FirefoxApplicationHooks.prototype = {
@@ -5800,42 +3541,16 @@ ConsoleUtils = {
   {
     let str = Cc["@mozilla.org/supports-string;1"].
       createInstance(Ci.nsISupportsString);
     str.data = aString;
     return str;
   },
 
   /**
-   * Generates a millisecond resolution timestamp.
-   *
-   * @returns integer
-   */
-  timestamp: function ConsoleUtils_timestamp()
-  {
-    return Date.now();
-  },
-
-  /**
-   * Generates a formatted timestamp string for displaying in console messages.
-   *
-   * @param integer [ms] Optional, allows you to specify the timestamp in
-   * milliseconds since the UNIX epoch.
-   * @returns string The timestamp formatted for display.
-   */
-  timestampString: function ConsoleUtils_timestampString(ms)
-  {
-    var d = new Date(ms ? ms : null);
-    let hours = d.getHours(), minutes = d.getMinutes();
-    let seconds = d.getSeconds(), milliseconds = d.getMilliseconds();
-    let parameters = [ hours, minutes, seconds, milliseconds ];
-    return HUDService.getFormatStr("timestampFormat", parameters);
-  },
-
-  /**
    * Scrolls a node so that it's visible in its containing XUL "scrollbox"
    * element.
    *
    * @param nsIDOMNode aNode
    *        The node to make visible.
    * @returns void
    */
   scrollToVisible: function ConsoleUtils_scrollToVisible(aNode) {
@@ -5924,18 +3639,20 @@ ConsoleUtils = {
     // Store the body text, since it is needed later for the property tree
     // case.
     let body = aBody;
     // If a string was supplied for the body, turn it into a DOM node and an
     // associated clipboard string now.
     aClipboardText = aClipboardText ||
                      (aBody + (aSourceURL ? " @ " + aSourceURL : "") +
                               (aSourceLine ? ":" + aSourceLine : ""));
-    aBody = aBody instanceof Ci.nsIDOMNode && !(aLevel == "dir") ?
-            aBody : aDocument.createTextNode(aBody);
+    if (!(aBody instanceof Ci.nsIDOMNode)) {
+      aBody = aDocument.createTextNode(aLevel == "dir" ?
+                                       aBody.resultString : aBody);
+    }
 
     if (!aBody.nodeType) {
       aBody = aDocument.createTextNode(aBody.toString());
     }
     if (typeof aBody == "string") {
       aBody = aDocument.createTextNode(aBody);
     }
 
@@ -5946,18 +3663,18 @@ ConsoleUtils = {
     let repeatNode = aDocument.createElementNS(XUL_NS, "label");
     repeatNode.setAttribute("value", "1");
     repeatNode.classList.add("webconsole-msg-repeat");
     repeatContainer.appendChild(repeatNode);
 
     // Create the timestamp.
     let timestampNode = aDocument.createElementNS(XUL_NS, "label");
     timestampNode.classList.add("webconsole-timestamp");
-    let timestamp = aTimeStamp || ConsoleUtils.timestamp();
-    let timestampString = ConsoleUtils.timestampString(timestamp);
+    let timestamp = aTimeStamp || Date.now();
+    let timestampString = l10n.timestampString(timestamp);
     timestampNode.setAttribute("value", timestampString);
 
     // Create the source location (e.g. www.example.com:6) that sits on the
     // right side of the message, if applicable.
     let locationNode;
     if (aSourceURL) {
       locationNode = this.createLocationNode(aDocument, aSourceURL,
                                              aSourceLine);
@@ -5998,17 +3715,24 @@ ConsoleUtils = {
 
       tree.appendChild(aDocument.createElement("treechildren"));
 
       bodyContainer.appendChild(tree);
       node.appendChild(bodyContainer);
       node.classList.add("webconsole-msg-inspector");
       // Create the treeView object.
       let treeView = node.propertyTreeView = new PropertyTreeView();
-      treeView.data = body;
+
+      treeView.data = {
+        rootCacheId: body.cacheId,
+        panelCacheId: body.cacheId,
+        remoteObject: body.remoteObject,
+        remoteObjectProvider: body.remoteObjectProvider,
+      };
+
       tree.setAttribute("rows", treeView.rowCount);
     }
     else {
       node.appendChild(bodyNode);
     }
     node.appendChild(repeatContainer);
     if (locationNode) {
       node.appendChild(locationNode);
@@ -6073,17 +3797,17 @@ ConsoleUtils = {
    */
   createLocationNode:
   function ConsoleUtils_createLocationNode(aDocument, aSourceURL,
                                            aSourceLine) {
     let locationNode = aDocument.createElementNS(XUL_NS, "label");
 
     // Create the text, which consists of an abbreviated version of the URL
     // plus an optional line number.
-    let text = ConsoleUtils.abbreviateSourceURL(aSourceURL);
+    let text = WebConsoleUtils.abbreviateSourceURL(aSourceURL);
     if (aSourceLine) {
       text += ":" + aSourceLine;
     }
     locationNode.setAttribute("value", text);
 
     // Style appropriately.
     locationNode.setAttribute("crop", "center");
     locationNode.setAttribute("title", aSourceURL);
@@ -6293,64 +4017,33 @@ ConsoleUtils = {
   {
     let lastNodeHeight = aOutputNode.lastChild ?
                          aOutputNode.lastChild.clientHeight : 0;
     let scrollBox = aOutputNode.scrollBoxObject.element;
 
     return scrollBox.scrollTop + scrollBox.clientHeight >=
            scrollBox.scrollHeight - lastNodeHeight / 2;
   },
-
-  /**
-   * Abbreviates the given source URL so that it can be displayed flush-right
-   * without being too distracting.
-   *
-   * @param string aSourceURL
-   *        The source URL to shorten.
-   * @return string
-   *         The abbreviated form of the source URL.
-   */
-  abbreviateSourceURL: function ConsoleUtils_abbreviateSourceURL(aSourceURL) {
-    // Remove any query parameters.
-    let hookIndex = aSourceURL.indexOf("?");
-    if (hookIndex > -1) {
-      aSourceURL = aSourceURL.substring(0, hookIndex);
-    }
-
-    // Remove a trailing "/".
-    if (aSourceURL[aSourceURL.length - 1] == "/") {
-      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
-    }
-
-    // Remove all but the last path component.
-    let slashIndex = aSourceURL.lastIndexOf("/");
-    if (slashIndex > -1) {
-      aSourceURL = aSourceURL.substring(slashIndex + 1);
-    }
-
-    return aSourceURL;
-  }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 HeadsUpDisplayUICommands = {
   toggleHUD: function UIC_toggleHUD() {
+    dump("toggleHUD 1\n");
     var window = HUDService.currentContext();
     var gBrowser = window.gBrowser;
-    var linkedBrowser = gBrowser.selectedTab.linkedBrowser;
-    var tabId = gBrowser.getNotificationBox(linkedBrowser).getAttribute("id");
-    var hudId = "hud_" + tabId;
+    var hudId = "hud_" + gBrowser.selectedTab.linkedPanel;
     var ownerDocument = gBrowser.selectedTab.ownerDocument;
-    var hud = ownerDocument.getElementById(hudId);
+    var hudBox = ownerDocument.getElementById(hudId);
     var hudRef = HUDService.hudReferences[hudId];
 
-    if (hudRef && hud) {
+    if (hudRef && hudBox) {
       if (hudRef.consolePanel) {
         hudRef.consolePanel.hidePopup();
       }
       else {
         HUDService.storeHeight(hudId);
 
         HUDService.animate(hudId, ANIMATE_OUT, function() {
           // If the user closes the console while the console is animating away,
@@ -6362,16 +4055,17 @@ HeadsUpDisplayUICommands = {
           }
         });
       }
     }
     else {
       HUDService.activateHUDForContext(gBrowser.selectedTab, true);
       HUDService.animate(hudId, ANIMATE_IN);
     }
+    dump("toggleHUD end\n");
   },
 
   /**
    * Find the hudId for the active chrome window.
    * @return string|null
    *         The hudId or null if the active chrome window has no open Web
    *         Console.
    */
@@ -6510,50 +4204,16 @@ function ConsoleEntry(aConfig, id)
 
 ConsoleEntry.prototype = {
 
   updateTransaction: function CE_updateTransaction(aActivity) {
     this.transactions[aActivity.stage] = aActivity;
   }
 };
 
-//////////////////////////////////////////////////////////////////////////
-// HUDWindowObserver
-//////////////////////////////////////////////////////////////////////////
-
-HUDWindowObserver = {
-  QueryInterface: XPCOMUtils.generateQI(
-    [Ci.nsIObserver,]
-  ),
-
-  init: function HWO_init()
-  {
-    Services.obs.addObserver(this, "xpcom-shutdown", false);
-    Services.obs.addObserver(this, "content-document-global-created", false);
-  },
-
-  observe: function HWO_observe(aSubject, aTopic, aData)
-  {
-    if (aTopic == "content-document-global-created") {
-      HUDService.windowInitializer(aSubject);
-    }
-    else if (aTopic == "xpcom-shutdown") {
-      this.uninit();
-    }
-  },
-
-  uninit: function HWO_uninit()
-  {
-    Services.obs.removeObserver(this, "content-document-global-created");
-    Services.obs.removeObserver(this, "xpcom-shutdown");
-    this.initialConsoleCreated = false;
-  },
-
-};
-
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
 
 /**
  * A controller (an instance of nsIController) that makes editing actions
  * behave appropriately in the context of the Web Console.
  */
@@ -6634,136 +4294,16 @@ CommandController.prototype = {
         break;
       case "cmd_selectAll":
         this.selectAll(outputNode);
         break;
     }
   }
 };
 
-///////////////////////////////////////////////////////////////////////////////
-// HUDConsoleObserver
-///////////////////////////////////////////////////////////////////////////////
-
-/**
- * HUDConsoleObserver: Observes nsIConsoleService for global consoleMessages,
- * if a message originates inside a contentWindow we are tracking,
- * then route that message to the HUDService for logging.
- */
-
-HUDConsoleObserver = {
-  QueryInterface: XPCOMUtils.generateQI(
-    [Ci.nsIObserver]
-  ),
-
-  init: function HCO_init()
-  {
-    Services.console.registerListener(this);
-    Services.obs.addObserver(this, "quit-application-granted", false);
-  },
-
-  uninit: function HCO_uninit()
-  {
-    Services.console.unregisterListener(this);
-    Services.obs.removeObserver(this, "quit-application-granted");
-  },
-
-  observe: function HCO_observe(aSubject, aTopic, aData)
-  {
-    if (aTopic == "quit-application-granted") {
-      this.uninit();
-    }
-    else if (aSubject instanceof Ci.nsIScriptError) {
-      HUDService.reportPageError(aSubject);
-    }
-  }
-};
-
-/**
- * A WebProgressListener that listens for location changes, to update HUDService
- * state information on page navigation.
- *
- * @constructor
- * @param string aHudId
- *        The HeadsUpDisplay ID.
- */
-function ConsoleProgressListener(aHudId)
-{
-  this.hudId = aHudId;
-}
-
-ConsoleProgressListener.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
-                                         Ci.nsISupportsWeakReference]),
-
-  onStateChange: function CPL_onStateChange(aProgress, aRequest, aState,
-                                            aStatus)
-  {
-    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
-      return;
-    }
-
-    let uri = null;
-    if (aRequest instanceof Ci.imgIRequest) {
-      let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
-      uri = imgIRequest.URI;
-    }
-    else if (aRequest instanceof Ci.nsIChannel) {
-      let nsIChannel = aRequest.QueryInterface(Ci.nsIChannel);
-      uri = nsIChannel.URI;
-    }
-
-    if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
-      return;
-    }
-
-    let outputNode = HUDService.hudReferences[this.hudId].outputNode;
-
-    let chromeDocument = outputNode.ownerDocument;
-    let msgNode = chromeDocument.createElementNS(HTML_NS, "html:span");
-
-    // Create the clickable URL part of the message.
-    let linkNode = chromeDocument.createElementNS(HTML_NS, "html:span");
-    linkNode.appendChild(chromeDocument.createTextNode(uri.spec));
-    linkNode.classList.add("hud-clickable");
-    linkNode.classList.add("webconsole-msg-url");
-
-    linkNode.addEventListener("mousedown", function(aEvent) {
-      this._startX = aEvent.clientX;
-      this._startY = aEvent.clientY;
-    }, false);
-
-    linkNode.addEventListener("click", function(aEvent) {
-      if (aEvent.detail == 1 && aEvent.button == 0 &&
-          this._startX == aEvent.clientX && this._startY == aEvent.clientY) {
-        let viewSourceUtils = chromeDocument.defaultView.gViewSourceUtils;
-        viewSourceUtils.viewSource(uri.spec, null, chromeDocument);
-      }
-    }, false);
-
-    msgNode.appendChild(linkNode);
-
-    let messageNode = ConsoleUtils.createMessageNode(chromeDocument,
-                                                     CATEGORY_NETWORK,
-                                                     SEVERITY_LOG,
-                                                     msgNode,
-                                                     this.hudId,
-                                                     null,
-                                                     null,
-                                                     uri.spec);
-
-    ConsoleUtils.outputMessageNode(messageNode, this.hudId);
-  },
-
-  onLocationChange: function() {},
-  onStatusChange: function() {},
-  onProgressChange: function() {},
-  onSecurityChange: function() {},
-};
-
 ///////////////////////////////////////////////////////////////////////////
 // appName
 ///////////////////////////////////////////////////////////////////////////
 
 /**
  * Get the app's name so we can properly dispatch app-specific
  * methods per API call
  * @returns Gecko application name
@@ -6782,23 +4322,29 @@ function appName()
   let name = APP_ID_TABLE[APP_ID];
 
   if (name){
     return name;
   }
   throw new Error("appName: UNSUPPORTED APPLICATION UUID");
 }
 
-XPCOMUtils.defineLazyGetter(this, "HUDService", function () {
+///////////////////////////////////////////////////////////////////////////
+// HUDService (exported symbol)
+///////////////////////////////////////////////////////////////////////////
+
+XPCOMUtils.defineLazyGetter(this, "HUDService", function() {
+  let instance = null;
   try {
-    return new HUD_SERVICE();
+    instance = new HUD_SERVICE();
   }
   catch (ex) {
     Cu.reportError(ex);
   }
+  return instance;
 });
 
 ///////////////////////////////////////////////////////////////////////////
 // GcliTerm
 ///////////////////////////////////////////////////////////////////////////
 
 /**
  * Some commands need customization - this is how we get at them.
@@ -6820,22 +4366,24 @@ let commandExports = undefined;
  * @param object aConsole
  *        Console object to use within the GcliTerm.
  * @param nsIDOMElement aHintNode
  *        The node to which we add GCLI's hints.
  * @constructor
  */
 function GcliTerm(aContentWindow, aHudId, aDocument, aConsole, aHintNode, aConsoleWrap)
 {
+  // FIXME: GCLI no longer works, even if e10s is disabled.
+  // FIXME: logConsoleAPIMessage and gcliterm formatResult
+
   this.context = Cu.getWeakReference(aContentWindow);
   this.hudId = aHudId;
   this.document = aDocument;
   this.console = aConsole;
   this.hintNode = aHintNode;
-  this._window = this.context.get().QueryInterface(Ci.nsIDOMWindow);
 
   this.createUI();
   this.createSandbox();
 
   this.show = this.show.bind(this);
   this.hide = this.hide.bind(this);
 
   // Allow GCLI:Inputter to decide how and when to open a scratchpad window
@@ -6844,29 +4392,29 @@ function GcliTerm(aContentWindow, aHudId
       return aEvent.shiftKey &&
           aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
     },
     activate: function Scratchpad_activate(aValue) {
       aValue = aValue.replace(/^\s*{\s*/, '');
       ScratchpadManager.openScratchpad({ text: aValue });
       return true;
     },
-    linkText: stringBundle.GetStringFromName('scratchpad.linkText')
+    linkText: l10n.getStr('scratchpad.linkText')
   };
 
   this.opts = {
     environment: {
       hudId: this.hudId,
       chromeDocument: this.document,
       contentDocument: aContentWindow.document
     },
     chromeDocument: this.document,
     contentDocument: aContentWindow.document,
     jsEnvironment: {
-      globalObject: unwrap(aContentWindow),
+      globalObject: WebConsoleUtils.unwrap(aContentWindow),
       evalFunction: this.evalInSandbox.bind(this)
     },
     inputElement: this.inputNode,
     completeElement: this.completeNode,
     inputBackgroundElement: this.inputStack,
     hintElement: this.hintNode,
     consoleWrap: aConsoleWrap,
     scratchpad: scratchpad,
@@ -6922,44 +4470,37 @@ GcliTerm.prototype = {
     delete this.opts.contentDocument;
     delete this.opts.jsEnvironment;
     delete this.opts.gcliTerm;
 
     delete this.context;
     delete this.document;
     delete this.console;
     delete this.hintNode;
-    delete this._window;
 
     delete this.sandbox;
-    delete this.element
-    delete this.inputStack
-    delete this.completeNode
-    delete this.inputNode
+    delete this.element;
+    delete this.inputStack;
+    delete this.completeNode;
+    delete this.inputNode;
   },
 
   /**
    * Re-attaches a console when the contentWindow is recreated.
    *
    * @param nsIDOMWindow aContentWindow
    *        The content window that we're providing as the context to commands
    * @param object aConsole
    *        Console object to use within the GcliTerm.
    */
   reattachConsole: function Gcli_reattachConsole(aContentWindow, aConsole)
   {
     this.context = Cu.getWeakReference(aContentWindow);
     this.console = aConsole;
     this.createSandbox();
-
-    this.opts.environment.contentDocument = aContentWindow.document;
-    this.opts.contentDocument = aContentWindow.document;
-    this.opts.jsEnvironment.globalObject = unwrap(aContentWindow);
-
-    gcli._internal.reattachConsole(this.opts);
   },
 
   /**
    * Generates and attaches the GCLI Terminal part of the Web Console, which
    * essentially consists of the interactive JavaScript input facility.
    */
   createUI: function Gcli_createUI()
   {
@@ -6988,72 +4529,30 @@ GcliTerm.prototype = {
   onCommandOutput: function Gcli_onCommandOutput(aEvent)
   {
     // When we can update the history of the console, then we should stop
     // filtering incomplete reports.
     if (!aEvent.output.completed) {
       return;
     }
 
-    this.writeOutput(aEvent.output.typed, CATEGORY_INPUT);
-
-    // This is an experiment to see how much people yell when we stop reporting
-    // undefined replies.
-    if (aEvent.output.output === undefined) {
+    this.writeOutput(aEvent.output.typed, { category: CATEGORY_INPUT });
+
+    if (aEvent.output.output == null) {
       return;
     }
 
     let output = aEvent.output.output;
-    let declaredType = aEvent.output.command.returnType || "";
-
-    if (declaredType == "object") {
-      let actualType = typeof output;
-      if (output === null) {
-        output = "null";
-      }
-      else if (actualType == "string") {
-        output = "\"" + output + "\"";
-      }
-      else if (actualType == "object" || actualType == "function") {
-        let formatOpts = [ nameObject(output) ];
-        output = stringBundle.formatStringFromName('gcliterm.instanceLabel',
-                formatOpts, formatOpts.length);
-        let linkNode = this.document.createElementNS(HTML_NS, 'html:span');
-        linkNode.appendChild(this.document.createTextNode(output));
-        linkNode.classList.add("hud-clickable");
-        linkNode.setAttribute("aria-haspopup", "true");
-
-        // Make the object bring up the property panel.
-        linkNode.addEventListener("mousedown", function(aEv) {
-          this._startX = aEv.clientX;
-          this._startY = aEv.clientY;
-        }.bind(this), false);
-
-        linkNode.addEventListener("click", function(aEv) {
-          if (aEv.detail != 1 || aEv.button != 0 ||
-              (this._startX != aEv.clientX && this._startY != aEv.clientY)) {
-            return;
-          }
-
-          if (!this._panelOpen) {
-            let propPanel = this.openPropertyPanel(aEvent.output.typed, aEvent.output.output, this);
-            propPanel.panel.setAttribute("hudId", this.hudId);
-            this._panelOpen = true;
-          }
-        }.bind(this), false);
-
-        output = linkNode;
-      }
-      // else if (actualType == number/boolean/undefined) do nothing
-    }
-
-    if (declaredType == "html" && typeof output == "string") {
+    if (aEvent.output.command.returnType == "html" && typeof output == "string") {
       output = this.document.createRange().createContextualFragment(
           '<div xmlns="' + HTML_NS + '" xmlns:xul="' + XUL_NS + '">' +
           output + '</div>');
+
+      output = this.document.createElementNS(HTML_NS, "div");
+      output.appendChild(frag);
     }
 
     // See https://github.com/mozilla/domtemplate/blob/master/README.md
     // for docs on the template() function
     let element = this.document.createRange().createContextualFragment(
       '<richlistitem xmlns="' + XUL_NS + '" _clipboardText="${clipboardText}"' +
       '    _timestamp="${timestamp}" _id="${id}" class="hud-msg-node">' +
       '  <label class="webconsole-timestamp" _value="${timestampString}"/>' +
@@ -7061,115 +4560,103 @@ GcliTerm.prototype = {
       '    <image class="webconsole-msg-icon"/>' +
       '    <spacer flex="1"/>' +
       '  </vbox>' +
       '  <hbox flex="1" class="gcliterm-msg-body">${output}</hbox>' +
       '  <hbox align="start"><label value="1" class="webconsole-msg-repeat"/></hbox>' +
       '</richlistitem>').firstChild;
 
     let hud = HUDService.getHudReferenceById(this.hudId);
-    let timestamp = ConsoleUtils.timestamp();
+    let timestamp = Date.now();
     template(element, {
       iconContainerStyle: "margin-left=" + (hud.groupDepth * GROUP_INDENT) + "px",
       output: output,
       timestamp: timestamp,
-      timestampString: ConsoleUtils.timestampString(timestamp),
+      timestampString: l10n.timestampString(timestamp),
       clipboardText: output.innerText,
       id: "console-msg-" + HUDService.sequenceId()
     });
 
     ConsoleUtils.setMessageType(element, CATEGORY_OUTPUT, SEVERITY_LOG);
     ConsoleUtils.outputMessageNode(element, this.hudId);
   },
 
   /**
    * Setup the eval sandbox, should be called whenever we are attached.
    */
   createSandbox: function Gcli_createSandbox()
   {
+    let win = this.context.get().QueryInterface(Ci.nsIDOMWindow);
+
     // create a JS Sandbox out of this.context
-    this.sandbox = new Cu.Sandbox(this._window, {
-      sandboxPrototype: this._window,
+    this.sandbox = new Cu.Sandbox(win, {
+      sandboxPrototype: win,
       wantXrays: false
     });
     this.sandbox.console = this.console;
-
-    JSTermHelper(this);
   },
 
   /**
    * Evaluates a string in the sandbox.
    *
    * @param string aString
    *        String to evaluate in the sandbox
    * @return The result of the evaluation
    */
   evalInSandbox: function Gcli_evalInSandbox(aString)
   {
-    let window = unwrap(this.sandbox.window);
-    let temp$ = null;
-    let temp$$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      temp$ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      temp$$ = this.sandbox.$$;
-      delete this.sandbox.$$;
-    }
-
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
-
-    if (temp$) {
-      this.sandbox.$ = temp$;
-    }
-    if (temp$$) {
-      this.sandbox.$$ = temp$$;
-    }
-
-    return result;
+    return Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
   },
 
   /**
    * Writes a message to the HUD that originates from the interactive
    * JavaScript console.
    *
    * @param string aOutputMessage
    *        The message to display.
    * @param number aCategory
    *        One of the CATEGORY_ constants.
    * @param number aSeverity
    *        One of the SEVERITY_ constants.
    */
-  writeOutput: function Gcli_writeOutput(aOutputMessage, aCategory, aSeverity, aOptions)
+  writeOutput: function Gcli_writeOutput(aOutputMessage, aOptions)
   {
     aOptions = aOptions || {};
 
     let node = ConsoleUtils.createMessageNode(
                     this.document,
-                    aCategory || CATEGORY_OUTPUT,
-                    aSeverity || SEVERITY_LOG,
+                    aOptions.category || CATEGORY_OUTPUT,
+                    aOptions.severity || SEVERITY_LOG,
                     aOutputMessage,
                     this.hudId,
                     aOptions.sourceUrl || undefined,
                     aOptions.sourceLine || undefined,
                     aOptions.clipboardText || undefined);
 
     ConsoleUtils.outputMessageNode(node, this.hudId);
   },
 
-  clearOutput: JSTerm.prototype.clearOutput,
-  openPropertyPanel: JSTerm.prototype.openPropertyPanel,
-
-  formatResult: JSTerm.prototype.formatResult,
-  getResultType: JSTerm.prototype.getResultType,
-  formatString: JSTerm.prototype.formatString,
+  clearOutput: function Gcli_clearOutput()
+  {
+    let hud = HUDService.getHudReferenceById(this.hudId);
+    hud.cssNodes = {};
+
+    let node = hud.outputNode;
+    while (node.firstChild) {
+      if (node.firstChild.classList &&
+          node.firstChild.classList.contains("webconsole-msg-inspector")) {
+        hud.pruneConsoleDirNode(node.firstChild);
+      }
+      else {
+        hud.outputNode.removeChild(node.firstChild);
+      }
+    }
+
+    hud.HUDBox.lastTimestamp = 0;
+  }
 };
 
 /**
  * A fancy version of toString()
  */
 function nameObject(aObj) {
   if (aObj.constructor && aObj.constructor.name) {
     return aObj.constructor.name;
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -43,16 +43,18 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		PropertyPanel.jsm \
 		NetworkHelper.jsm \
 		AutocompletePopup.jsm \
+		WebConsoleUtils.jsm \
+		NetworkPanel.jsm \
 		gcli.jsm \
 		GcliCommands.jsm \
 		GcliTiltCommands.jsm \
 		$(NULL)
 
 EXTRA_PP_JS_MODULES = \
 		HUDService.jsm \
 		$(NULL)
diff --git a/browser/devtools/webconsole/NetworkHelper.jsm b/browser/devtools/webconsole/NetworkHelper.jsm
--- a/browser/devtools/webconsole/NetworkHelper.jsm
+++ b/browser/devtools/webconsole/NetworkHelper.jsm
@@ -44,16 +44,17 @@
  *  Curtis Bartley (Mozilla Corp.)
  *  Mike Collins (IBM Almaden)
  *  Kevin Decker
  *  Mike Ratcliffe (Comartis AG)
  *  Hernan Rodríguez Colmeiro
  *  Austin Andrews
  *  Christoph Dorn
  *  Steven Roussey (AppCenter Inc, Network54)
+ *  Mihai Sucan (Mozilla Corp.)
  */
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
@@ -123,72 +124,72 @@ var NetworkHelper =
       return text;
     }
   },
 
    /**
    * Reads the posted text from aRequest.
    *
    * @param nsIHttpChannel aRequest
-   * @param nsIDOMNode aBrowser
+   * @param string aCharset
+   *        The content document charset, used when reading the POSTed data.
    * @returns string or null
    *          Returns the posted string if it was possible to read from aRequest
    *          otherwise null.
    */
-  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aBrowser)
+  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aCharset)
   {
     if (aRequest instanceof Ci.nsIUploadChannel) {
       let iStream = aRequest.uploadStream;
 
       let isSeekableStream = false;
       if (iStream instanceof Ci.nsISeekableStream) {
         isSeekableStream = true;
       }
 
       let prevOffset;
       if (isSeekableStream) {
         prevOffset = iStream.tell();
         iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
       }
 
       // Read data from the stream.
-      let charset = aBrowser.contentWindow.document.characterSet;
-      let text = this.readAndConvertFromStream(iStream, charset);
+      let text = this.readAndConvertFromStream(iStream, aCharset);
 
       // Seek locks the file, so seek to the beginning only if necko hasn't
       // read it yet, since necko doesn't seek to 0 before reading (at lest
       // not till 459384 is fixed).
       if (isSeekableStream && prevOffset == 0) {
         iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
       }
       return text;
     }
     return null;
   },
 
   /**
    * Reads the posted text from the page's cache.
    *
-   * @param nsIDOMNode aBrowser
+   * @param nsIDocShell aDocShell
    * @returns string or null
-   *          Returns the posted string if it was possible to read from aBrowser
-   *          otherwise null.
+   *          Returns the posted string if it was possible to read from
+   *          aDocShell otherwise null.
    */
-  readPostTextFromPage: function NH_readPostTextFromPage(aBrowser)
+  // TODO: update comment.
+  readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset)
   {
-    let webNav = aBrowser.webNavigation;
+    let webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
     if (webNav instanceof Ci.nsIWebPageDescriptor) {
       let descriptor = webNav.currentDescriptor;
 
       if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
           descriptor instanceof Ci.nsISeekableStream) {
         descriptor.seek(NS_SEEK_SET, 0);
 
-        let charset = browser.contentWindow.document.characterSet;
-        return this.readAndConvertFromStream(descriptor, charset);
+        return this.readAndConvertFromStream(descriptor, aCharset);
       }
     }
     return null;
   },
 
   /**
    * Gets the nsIDOMWindow that is associated with aRequest.
    *
diff --git a/browser/devtools/webconsole/NetworkPanel.jsm b/browser/devtools/webconsole/NetworkPanel.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/NetworkPanel.jsm
@@ -0,0 +1,736 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Web Console network panel.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   David Dahl <ddahl@mozilla.com> (original author)
+ *   Rob Campbell <rcampbell@mozilla.com>
+ *   Johnathan Nightingale <jnightingale@mozilla.com>
+ *   Patrick Walton <pcwalton@mozilla.com>
+ *   Julian Viereck <jviereck@mozilla.com>
+ *   Mihai Șucan <mihai.sucan@gmail.com>
+ *   Michael Ratcliffe <mratcliffe@mozilla.com>
+ *   Joe Walker <jwalker@mozilla.com>
+ *   Sonny Piers <sonny.piers@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this, "mimeService",
+                                   "@mozilla.org/mime;1",
+                                   "nsIMIMEService");
+
+XPCOMUtils.defineLazyGetter(this, "NetworkHelper", function () {
+  let obj = {};
+  Cu.import("resource:///modules/NetworkHelper.jsm", obj);
+  return obj.NetworkHelper;
+});
+
+XPCOMUtils.defineLazyGetter(this, "NetUtil", function () {
+  var obj = {};
+  Cu.import("resource://gre/modules/NetUtil.jsm", obj);
+  return obj.NetUtil;
+});
+
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function () {
+  return WebConsoleUtils.l10n;
+});
+
+var EXPORTED_SYMBOLS = ["NetworkPanel"];
+
+/**
+ * Creates a new NetworkPanel.
+ *
+ * @param nsIDOMNode aParent
+ *        Parent node to append the created panel to.
+ * @param object aHttpActivity
+ *        HttpActivity to display in the panel.
+ */
+function NetworkPanel(aParent, aHttpActivity)
+{
+  let doc = aParent.ownerDocument;
+  this.httpActivity = aHttpActivity;
+
+  // Create the underlaying panel
+  this.panel = createElement(doc, "panel", {
+    label: l10n.getStr("NetworkPanel.label"),
+    titlebar: "normal",
+    noautofocus: "true",
+    noautohide: "true",
+    close: "true"
+  });
+
+  // Create the iframe that displays the NetworkPanel XHTML.
+  this.iframe = createAndAppendElement(this.panel, "iframe", {
+    src: "chrome://browser/content/NetworkPanel.xhtml",
+    type: "content",
+    flex: "1"
+  });
+
+  let self = this;
+
+  // Destroy the panel when it's closed.
+  this.panel.addEventListener("popuphidden", function onPopupHide() {
+    self.panel.removeEventListener("popuphidden", onPopupHide, false);
+    self.panel.parentNode.removeChild(self.panel);
+    self.panel = null;
+    self.iframe = null;
+    self.document = null;
+    self.httpActivity = null;
+
+    if (self.linkNode) {
+      self.linkNode._panelOpen = false;
+      self.linkNode = null;
+    }
+  }, false);
+
+  // Set the document object and update the content once the panel is loaded.
+  this.panel.addEventListener("load", function onLoad() {
+    self.panel.removeEventListener("load", onLoad, true);
+    self.document = self.iframe.contentWindow.document;
+    self.update();
+  }, true);
+
+  // Create the footer.
+  let footer = createElement(doc, "hbox", { align: "end" });
+  createAndAppendElement(footer, "spacer", { flex: 1 });
+
+  createAndAppendElement(footer, "resizer", { dir: "bottomend" });
+  this.panel.appendChild(footer);
+
+  aParent.appendChild(this.panel);
+}
+
+NetworkPanel.prototype =
+{
+  /**
+   * Callback is called once the NetworkPanel is processed completly. Used by
+   * unit tests.
+   */
+  isDoneCallback: null,
+
+  /**
+   * The current state of the output.
+   */
+  _state: 0,
+
+  /**
+   * State variables.
+   */
+  _INIT: 0,
+  _DISPLAYED_REQUEST_HEADER: 1,
+  _DISPLAYED_REQUEST_BODY: 2,
+  _DISPLAYED_RESPONSE_HEADER: 3,
+  _TRANSITION_CLOSED: 4,
+
+  _fromDataRegExp: /Content-Type\:\s*application\/x-www-form-urlencoded/,
+
+  /**
+   * Small helper function that is nearly equal to l10n.getFormatStr
+   * except that it prefixes aName with "NetworkPanel.".
+   *
+   * @param string aName
+   *        The name of an i10n string to format. This string is prefixed with
+   *        "NetworkPanel." before calling the HUDService.getFormatStr function.
+   * @param array aArray
+   *        Values used as placeholder for the i10n string.
+   * @returns string
+   *          The i10n formated string.
+   */
+  _format: function NP_format(aName, aArray)
+  {
+    return l10n.getFormatStr("NetworkPanel." + aName, aArray);
+  },
+
+  /**
+   * Returns the content type of the response body. This is based on the
+   * response.header["Content-Type"] info. If this value is not available, then
+   * the content type is tried to be estimated by the url file ending.
+   *
+   * @returns string or null
+   *          Content type or null if no content type could be figured out.
+   */
+  get _contentType()
+  {
+    let response = this.httpActivity.response;
+    let contentTypeValue = null;
+
+    if (response.header && response.header["Content-Type"]) {
+      let types = response.header["Content-Type"].split(/,|;/);
+      for (let i = 0; i < types.length; i++) {
+        let type = NetworkHelper.mimeCategoryMap[types[i]];
+        if (type) {
+          return types[i];
+        }
+      }
+    }
+
+    // Try to get the content type from the request file extension.
+    let uri = NetUtil.newURI(this.httpActivity.url);
+    let mimeType = null;
+    if ((uri instanceof Ci.nsIURL) && uri.fileExtension) {
+      try {
+        mimeType = mimeService.getTypeFromExtension(uri.fileExtension);
+      } catch(e) {
+        // Added to prevent failures on OS X 64. No Flash?
+        Cu.reportError(e);
+        // Return empty string to pass unittests.
+        return "";
+      }
+    }
+    return mimeType;
+  },
+
+  /**
+   *
+   * @returns boolean
+   *          True if the response is an image, false otherwise.
+   */
+  get _responseIsImage()
+  {
+    return NetworkHelper.mimeCategoryMap[this._contentType] == "image";
+  },
+
+  /**
+   *
+   * @returns boolean
+   *          True if the response body contains text, false otherwise.
+   */
+  get _isResponseBodyTextData()
+  {
+    let contentType = this._contentType;
+
+    if (!contentType)
+      return false;
+
+    if (contentType.indexOf("text/") == 0) {
+      return true;
+    }
+
+    switch (NetworkHelper.mimeCategoryMap[contentType]) {
+      case "txt":
+      case "js":
+      case "json":
+      case "css":
+      case "html":
+      case "svg":
+      case "xml":
+        return true;
+
+      default:
+        return false;
+    }
+  },
+
+  /**
+   *
+   * @returns boolean
+   *          Returns true if the server responded that the request is already
+   *          in the browser's cache, false otherwise.
+   */
+  get _isResponseCached()
+  {
+    return this.httpActivity.response.status.indexOf("304") != -1;
+  },
+
+  /**
+   *
+   * @returns boolean
+   *          Returns true if the posted body contains form data.
+   */
+  get _isRequestBodyFormData()
+  {
+    let requestBody = this.httpActivity.request.body;
+    return this._fromDataRegExp.test(requestBody);
+  },
+
+  /**
+   * Appends the node with id=aId by the text aValue.
+   *
+   * @param string aId
+   * @param string aValue
+   * @returns void
+   */
+  _appendTextNode: function NP_appendTextNode(aId, aValue)
+  {
+    let textNode = this.document.createTextNode(aValue);
+    this.document.getElementById(aId).appendChild(textNode);
+  },
+
+  /**
+   * Generates some HTML to display the key-value pair of the aList data. The
+   * generated HTML is added to node with id=aParentId.
+   *
+   * @param string aParentId
+   *        Id of the parent node to append the list to.
+   * @oaram object aList
+   *        Object that holds the key-value information to display in aParentId.
+   * @param boolean aIgnoreCookie
+   *        If true, the key-value named "Cookie" is not added to the list.
+   * @returns void
+   */
+  _appendList: function NP_appendList(aParentId, aList, aIgnoreCookie)
+  {
+    let parent = this.document.getElementById(aParentId);
+    let doc = this.document;
+
+    aList.sort(function(a, b) {
+      return a.name.toLowerCase() < b.name.toLowerCase();
+    });
+
+    aList.forEach(function(aItem) {
+      let name = aItem.name;
+      let value = aItem.value;
+      if (aIgnoreCookie && name == "Cookie") {
+        return;
+      }
+
+      /**
+       * The following code creates the HTML:
+       * <tr>
+       * <th scope="row" class="property-name">${line}:</th>
+       * <td class="property-value">${aList[line]}</td>
+       * </tr>
+       * and adds it to parent.
+       */
+      let row = doc.createElement("tr");
+      let textNode = doc.createTextNode(name + ":");
+      let th = doc.createElement("th");
+      th.setAttribute("scope", "row");
+      th.setAttribute("class", "property-name");
+      th.appendChild(textNode);
+      row.appendChild(th);
+
+      textNode = doc.createTextNode(value);
+      let td = doc.createElement("td");
+      td.setAttribute("class", "property-value");
+      td.appendChild(textNode);
+      row.appendChild(td);
+
+      parent.appendChild(row);
+    });
+  },
+
+  /**
+   * Displays the node with id=aId.
+   *
+   * @param string aId
+   * @returns void
+   */
+  _displayNode: function NP_displayNode(aId)
+  {
+    this.document.getElementById(aId).style.display = "block";
+  },
+
+  /**
+   * Sets the request URL, request method, the timing information when the
+   * request started and the request header content on the NetworkPanel.
+   * If the request header contains cookie data, a list of sent cookies is
+   * generated and a special sent cookie section is displayed + the cookie list
+   * added to it.
+   *
+   * @returns void
+   */
+  _displayRequestHeader: function NP_displayRequestHeader()
+  {
+    let entry = this.httpActivity.log.entries[0];
+    let timing = entry.timings;
+    let request = entry.request;
+    let requestTime = WebConsoleUtils.
+                      convertISO8601toMilliseconds(entry.startedDateTime);
+
+    this._appendTextNode("headUrl", request.url);
+    this._appendTextNode("headMethod", request.method);
+    this._appendTextNode("requestHeadersInfo",
+                         l10n.timestampString(requestTime));
+
+    this._appendList("requestHeadersContent", request.headers, true);
+
+    if (request.cookies.length > 0) {
+      this._displayNode("requestCookie");
+      this._appendList("requestCookieContent", request.cookies);
+    }
+  },
+
+  /**
+   * Displays the request body section of the NetworkPanel and set the request
+   * body content on the NetworkPanel.
+   *
+   * @returns void
+   */
+  _displayRequestBody: function NP_displayRequestBody() {
+    this._displayNode("requestBody");
+    this._appendTextNode("requestBodyContent", this.httpActivity.request.body);
+  },
+
+  /*
+   * Displays the `sent form data` section. Parses the request header for the
+   * submitted form data displays it inside of the `sent form data` section.
+   *
+   * @returns void
+   */
+  _displayRequestForm: function NP_processRequestForm() {
+    let requestBodyLines = this.httpActivity.request.body.split("\n");
+    let formData = requestBodyLines[requestBodyLines.length - 1].
+                      replace(/\+/g, " ").split("&");
+
+    function unescapeText(aText)
+    {
+      try {
+        return decodeURIComponent(aText);
+      }
+      catch (ex) {
+        return decodeURIComponent(unescape(aText));
+      }
+    }
+
+    let formDataObj = {};
+    for (let i = 0; i < formData.length; i++) {
+      let data = formData[i];
+      let idx = data.indexOf("=");
+      let key = data.substring(0, idx);
+      let value = data.substring(idx + 1);
+      formDataObj[unescapeText(key)] = unescapeText(value);
+    }
+
+    this._appendList("requestFormDataContent", formDataObj);
+    this._displayNode("requestFormData");
+  },
+
+  /**
+   * Displays the response section of the NetworkPanel, sets the response status,
+   * the duration between the start of the request and the receiving of the
+   * response header as well as the response header content on the the NetworkPanel.
+   *
+   * @returns void
+   */
+  _displayResponseHeader: function NP__displayResponseHeader()
+  {
+    let entry = this.httpActivity.log.entries[0];
+    let timing = entry.timings;
+    let response = entry.response;
+
+    this._appendTextNode("headStatus",
+                         [response.httpVersion, response.status,
+                          response.statusText].join(" "));
+
+    // Calculate how much time it took from the request start, until the
+    // response started to be received.
+    let deltaDuration = 0;
+    ["dns", "connect", "send", "wait"].forEach(function (aValue) {
+      let ms = timing[aValue];
+      if (ms > -1) {
+        deltaDuration += ms;
+      }
+    });
+
+    this._appendTextNode("responseHeadersInfo",
+      this._format("durationMS", [deltaDuration]));
+
+    this._displayNode("responseContainer");
+    this._appendList("responseHeadersContent", response.headers);
+  },
+
+  /**
+   * Displays the respones image section, sets the source of the image displayed
+   * in the image response section to the request URL and the duration between
+   * the receiving of the response header and the end of the request. Once the
+   * image is loaded, the size of the requested image is set.
+   *
+   * @returns void
+   */
+  _displayResponseImage: function NP_displayResponseImage()
+  {
+    let self = this;
+    let timing = this.httpActivity.timing;
+    let response = this.httpActivity.response;
+    let cached = "";
+
+    if (this._isResponseCached) {
+      cached = "Cached";
+    }
+
+    let imageNode = this.document.getElementById("responseImage" + cached +"Node");
+    imageNode.setAttribute("src", this.httpActivity.url);
+
+    // This function is called to set the imageInfo.
+    function setImageInfo() {
+      let deltaDuration =
+        Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
+      self._appendTextNode("responseImage" + cached + "Info",
+        self._format("imageSizeDeltaDurationMS", [
+          imageNode.width, imageNode.height, deltaDuration
+        ]
+      ));
+    }
+
+    // Check if the image is already loaded.
+    if (imageNode.width != 0) {
+      setImageInfo();
+    }
+    else {
+      // Image is not loaded yet therefore add a load event.
+      imageNode.addEventListener("load", function imageNodeLoad() {
+        imageNode.removeEventListener("load", imageNodeLoad, false);
+        setImageInfo();
+      }, false);
+    }
+
+    this._displayNode("responseImage" + cached);
+  },
+
+  /**
+   * Displays the response body section, sets the the duration between
+   * the receiving of the response header and the end of the request as well as
+   * the content of the response body on the NetworkPanel.
+   *
+   * @param [optional] string aCachedContent
+   *        Cached content for this request. If this argument is set, the
+   *        responseBodyCached section is displayed.
+   * @returns void
+   */
+  _displayResponseBody: function NP_displayResponseBody(aCachedContent)
+  {
+    let timing = this.httpActivity.timing;
+    let response = this.httpActivity.response;
+    let cached =  "";
+    if (aCachedContent) {
+      cached = "Cached";
+    }
+
+    let deltaDuration =
+      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
+    this._appendTextNode("responseBody" + cached + "Info",
+      this._format("durationMS", [deltaDuration]));
+
+    this._displayNode("responseBody" + cached);
+    this._appendTextNode("responseBody" + cached + "Content",
+                            aCachedContent || response.body);
+  },
+
+  /**
+   * Displays the `Unknown Content-Type hint` and sets the duration between the
+   * receiving of the response header on the NetworkPanel.
+   *
+   * @returns void
+   */
+  _displayResponseBodyUnknownType: function NP_displayResponseBodyUnknownType()
+  {
+    let timing = this.httpActivity.timing;
+
+    this._displayNode("responseBodyUnknownType");
+    let deltaDuration =
+      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
+    this._appendTextNode("responseBodyUnknownTypeInfo",
+      this._format("durationMS", [deltaDuration]));
+
+    this._appendTextNode("responseBodyUnknownTypeContent",
+      this._format("responseBodyUnableToDisplay.content", [this._contentType]));
+  },
+
+  /**
+   * Displays the `no response body` section and sets the the duration between
+   * the receiving of the response header and the end of the request.
+   *
+   * @returns void
+   */
+  _displayNoResponseBody: function NP_displayNoResponseBody()
+  {
+    let timing = this.httpActivity.timing;
+
+    this._displayNode("responseNoBody");
+    let deltaDuration =
+      Math.round((timing.RESPONSE_COMPLETE - timing.RESPONSE_HEADER) / 1000);
+    this._appendTextNode("responseNoBodyInfo",
+      this._format("durationMS", [deltaDuration]));
+  },
+
+  /*
+   * Calls the isDoneCallback function if one is specified.
+   */
+  _callIsDone: function() {
+    if (this.isDoneCallback) {
+      this.isDoneCallback();
+    }
+  },
+
+  /**
+   * Updates the content of the NetworkPanel's iframe.
+   *
+   * @returns void
+   */
+  update: function NP_update()
+  {
+    // After the iframe's contentWindow is ready, the document object is set.
+    // If the document object is not available yet nothing needs to be updated.
+    if (!this.document) {
+      return;
+    }
+
+    let entry = this.httpActivity.log.entries[0];
+    let timing = entry.timings;
+    let request = entry.request;
+    let response = entry.response;
+
+    switch (this._state) {
+      case this._INIT:
+        this._displayRequestHeader();
+        this._state = this._DISPLAYED_REQUEST_HEADER;
+        // FALL THROUGH
+
+      case this._DISPLAYED_REQUEST_HEADER:
+        // Process the request body if there is one.
+        // FIXME: need to be able to display the request body, if any.
+        if (!request.bodyDiscarded && request.body) {
+          // Check if we send some form data. If so, display the form data special.
+          if (this._isRequestBodyFormData) {
+            this._displayRequestForm();
+          }
+          else {
+            this._displayRequestBody();
+          }
+          this._state = this._DISPLAYED_REQUEST_BODY;
+        }
+        // FALL THROUGH
+
+      case this._DISPLAYED_REQUEST_BODY:
+        // There is always a response header. Therefore we can skip here if
+        // we don't have a response header yet and don't have to try updating
+        // anything else in the NetworkPanel.
+        if (!response.headers.length) {
+          break;
+        }
+        this._displayResponseHeader();
+        this._state = this._DISPLAYED_RESPONSE_HEADER;
+        // FALL THROUGH
+
+      case this._DISPLAYED_RESPONSE_HEADER:
+        // Check if the transition is done.
+        if (timing.TRANSACTION_CLOSE && response.isDone) {
+          if (response.bodyDiscarded) {
+            this._callIsDone();
+          }
+          else if (this._responseIsImage) {
+            this._displayResponseImage();
+            this._callIsDone();
+          }
+          else if (!this._isResponseBodyTextData) {
+            this._displayResponseBodyUnknownType();
+            this._callIsDone();
+          }
+          else if (response.body) {
+            this._displayResponseBody();
+            this._callIsDone();
+          }
+          else if (this._isResponseCached) {
+            let self = this;
+            NetworkHelper.loadFromCache(this.httpActivity.url,
+                                        this.httpActivity.charset,
+                                        function(aContent) {
+              // If some content could be loaded from the cache, then display
+              // the body.
+              if (aContent) {
+                self._displayResponseBody(aContent);
+                self._callIsDone();
+              }
+              // Otherwise, show the "There is no response body" hint.
+              else {
+                self._displayNoResponseBody();
+                self._callIsDone();
+              }
+            });
+          }
+          else {
+            this._displayNoResponseBody();
+            this._callIsDone();
+          }
+          this._state = this._TRANSITION_CLOSED;
+        }
+        break;
+    }
+  }
+}
+
+/**
+ * Creates a DOMNode and sets all the attributes of aAttributes on the created
+ * element.
+ *
+ * @param nsIDOMDocument aDocument
+ *        Document to create the new DOMNode.
+ * @param string aTag
+ *        Name of the tag for the DOMNode.
+ * @param object aAttributes
+ *        Attributes set on the created DOMNode.
+ *
+ * @returns nsIDOMNode
+ */
+function createElement(aDocument, aTag, aAttributes)
+{
+  let node = aDocument.createElement(aTag);
+  if (aAttributes) {
+    for (let attr in aAttributes) {
+      node.setAttribute(attr, aAttributes[attr]);
+    }
+  }
+  return node;
+}
+
+/**
+ * Creates a new DOMNode and appends it to aParent.
+ *
+ * @param nsIDOMNode aParent
+ *        A parent node to append the created element.
+ * @param string aTag
+ *        Name of the tag for the DOMNode.
+ * @param object aAttributes
+ *        Attributes set on the created DOMNode.
+ *
+ * @returns nsIDOMNode
+ */
+function createAndAppendElement(aParent, aTag, aAttributes)
+{
+  let node = createElement(aParent.ownerDocument, aTag, aAttributes);
+  aParent.appendChild(node);
+  return node;
+}
diff --git a/browser/devtools/webconsole/PropertyPanel.jsm b/browser/devtools/webconsole/PropertyPanel.jsm
--- a/browser/devtools/webconsole/PropertyPanel.jsm
+++ b/browser/devtools/webconsole/PropertyPanel.jsm
@@ -18,16 +18,17 @@
  * The Initial Developer of the Original Code is
  * the Mozilla Foundation.
  * Portions created by the Initial Developer are Copyright (C) 2010
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Rob Campbell <rcampbell@mozilla.com>
  *   Julian Viereck <jviereck@mozilla.com>
+ *   Mihai Sucan <mihai.sucan@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -40,263 +41,37 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
-var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView",
-                        "namesAndValuesOf", "isNonNativeGetter"];
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
 
-///////////////////////////////////////////////////////////////////////////
-//// Helper for PropertyTreeView
-
-const TYPE_OBJECT = 0, TYPE_FUNCTION = 1, TYPE_ARRAY = 2, TYPE_OTHER = 3;
-
-/**
- * Figures out the type of aObject and the string to display in the tree.
- *
- * @param object aObject
- *        The object to operate on.
- * @returns object
- *          A object with the form:
- *            {
- *              type: TYPE_OBJECT || TYPE_FUNCTION || TYPE_ARRAY || TYPE_OTHER,
- *              display: string for displaying the object in the tree
- *            }
- */
-function presentableValueFor(aObject)
-{
-  if (aObject === null || aObject === undefined) {
-    return {
-      type: TYPE_OTHER,
-      display: aObject === undefined ? "undefined" : "null"
-    };
-  }
-
-  let presentable;
-  switch (aObject.constructor && aObject.constructor.name) {
-    case "Array":
-      return {
-        type: TYPE_ARRAY,
-        display: "Array"
-      };
-
-    case "String":
-      return {
-        type: TYPE_OTHER,
-        display: "\"" + aObject + "\""
-      };
-
-    case "Date":
-    case "RegExp":
-    case "Number":
-    case "Boolean":
-      return {
-        type: TYPE_OTHER,
-        display: aObject
-      };
-
-    case "Iterator":
-      return {
-        type: TYPE_OTHER,
-        display: "Iterator"
-      };
-
-    case "Function":
-      presentable = aObject.toString();
-      return {
-        type: TYPE_FUNCTION,
-        display: presentable.substring(0, presentable.indexOf(')') + 1)
-      };
-
-    default:
-      presentable = aObject.toString();
-      let m = /^\[object (\S+)\]/.exec(presentable);
-
-      try {
-        if (typeof aObject == "object" && typeof aObject.next == "function" &&
-            m && m[1] == "Generator") {
-          return {
-            type: TYPE_OTHER,
-            display: m[1]
-          };
-        }
-      }
-      catch (ex) {
-        // window.history.next throws in the typeof check above.
-        return {
-          type: TYPE_OBJECT,
-          display: m ? m[1] : "Object"
-        };
-      }
-
-      if (typeof aObject == "object" && typeof aObject.__iterator__ == "function") {
-        return {
-          type: TYPE_OTHER,
-          display: "Iterator"
-        };
-      }
-
-      return {
-        type: TYPE_OBJECT,
-        display: m ? m[1] : "Object"
-      };
-  }
-}
-
-/**
- * Tells if the given function is native or not.
- *
- * @param function aFunction
- *        The function you want to check if it is native or not.
- *
- * @return boolean
- *         True if the given function is native, false otherwise.
- */
-function isNativeFunction(aFunction)
-{
-  return typeof aFunction == "function" && !("prototype" in aFunction);
-}
-
-/**
- * Tells if the given property of the provided object is a non-native getter or
- * not.
- *
- * @param object aObject
- *        The object that contains the property.
- *
- * @param string aProp
- *        The property you want to check if it is a getter or not.
- *
- * @return boolean
- *         True if the given property is a getter, false otherwise.
- */
-function isNonNativeGetter(aObject, aProp) {
-  if (typeof aObject != "object") {
-    return false;
-  }
-  let desc;
-  while (aObject) {
-    try {
-      if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
-        break;
-      }
-    }
-    catch (ex) {
-      // Native getters throw here. See bug 520882.
-      if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
-          ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
-        return false;
-      }
-      throw ex;
-    }
-    aObject = Object.getPrototypeOf(aObject);
-  }
-  if (desc && desc.get && !isNativeFunction(desc.get)) {
-    return true;
-  }
-  return false;
-}
-
-/**
- * Get an array of property name value pairs for the tree.
- *
- * @param object aObject
- *        The object to get properties for.
- * @returns array of object
- *          Objects have the name, value, display, type, children properties.
- */
-function namesAndValuesOf(aObject)
-{
-  let pairs = [];
-  let value, presentable;
-
-  let isDOMDocument = aObject instanceof Ci.nsIDOMDocument;
-
-  for (var propName in aObject) {
-    // See bug 632275: skip deprecated width and height properties.
-    if (isDOMDocument && (propName == "width" || propName == "height")) {
-      continue;
-    }
-
-    // Also skip non-native getters.
-    if (isNonNativeGetter(aObject, propName)) {
-      value = ""; // Value is never displayed.
-      presentable = {type: TYPE_OTHER, display: "Getter"};
-    }
-    else {
-      try {
-        value = aObject[propName];
-        presentable = presentableValueFor(value);
-      }
-      catch (ex) {
-        continue;
-      }
-    }
-
-    let pair = {};
-    pair.name = propName;
-    pair.display = propName + ": " + presentable.display;
-    pair.type = presentable.type;
-    pair.value = value;
-
-    // Convert the pair.name to a number for later sorting.
-    pair.nameNumber = parseFloat(pair.name)
-    if (isNaN(pair.nameNumber)) {
-      pair.nameNumber = false;
-    }
-
-    pairs.push(pair);
-  }
-
-  pairs.sort(function(a, b)
-  {
-    // Sort numbers.
-    if (a.nameNumber !== false && b.nameNumber === false) {
-      return -1;
-    }
-    else if (a.nameNumber === false && b.nameNumber !== false) {
-      return 1;
-    }
-    else if (a.nameNumber !== false && b.nameNumber !== false) {
-      return a.nameNumber - b.nameNumber;
-    }
-    // Sort string.
-    else if (a.name < b.name) {
-      return -1;
-    }
-    else if (a.name > b.name) {
-      return 1;
-    }
-    else {
-      return 0;
-    }
-  });
-
-  return pairs;
-}
+var EXPORTED_SYMBOLS = ["PropertyPanel", "PropertyTreeView"];
 
 ///////////////////////////////////////////////////////////////////////////
 //// PropertyTreeView.
 
-
 /**
  * This is an implementation of the nsITreeView interface. For comments on the
  * interface properties, see the documentation:
  * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsITreeView
  */
 var PropertyTreeView = function() {
   this._rows = [];
 };
 
 PropertyTreeView.prototype = {
-
   /**
    * Stores the visible rows of the tree.
    */
   _rows: null,
 
   /**
    * Stores the nsITreeBoxObject for this tree.
    */
@@ -304,19 +79,43 @@ PropertyTreeView.prototype = {
 
   /**
    * Use this setter to update the content of the tree.
    *
    * @param object aObject
    *        The new object to be displayed in the tree.
    * @returns void
    */
-  set data(aObject) {
+  set data(aData) {
     let oldLen = this._rows.length;
-    this._rows = this.getChildItems(aObject, true);
+    dump("set data oldLen " + oldLen + "\n");
+
+    this._cleanup();
+
+    if (!aData) {
+      return;
+    }
+
+    if (aData.remoteObject) {
+      this._rootCacheId = aData.rootCacheId;
+      this._panelCacheId = aData.panelCacheId;
+      this._remoteObjectProvider = aData.remoteObjectProvider;
+      this._rows = [].concat(aData.remoteObject);
+      this._updateRemoteObject(this._rows, 0);
+    }
+    else if (aData.object) {
+      this._rows = this._inspectObject(aData.object, 0);
+    }
+    else {
+      throw new Error("First argument must have a .remoteObject or " +
+                      "an .object property!");
+    }
+
+    dump("set data newLen " + this._rows.length + "\n");
+
     if (this._treeBox) {
       this._treeBox.beginUpdateBatch();
       if (oldLen) {
         this._treeBox.rowCountChanged(0, -oldLen);
       }
       this._treeBox.rowCountChanged(0, this._rows.length);
       this._treeBox.endUpdateBatch();
     }
@@ -329,122 +128,148 @@ PropertyTreeView.prototype = {
    * @param object aItem
    *        An item of the tree's elements to generate the children for.
    * @param boolean aRootElement
    *        If set, aItem is handled as an JS object and not as an item
    *        element of the tree.
    * @returns array of objects
    *        Child items of aItem.
    */
-  getChildItems: function(aItem, aRootElement)
+  // TODO: update comment
+  _updateRemoteObject: function PTV__updateRemoteObject(aObject, aLevel)
   {
-    // If item.children is an array, then the children has already been
-    // computed and can get returned directly.
-    // Skip this checking if aRootElement is true. It could happen, that aItem
-    // is passed as ({children:[1,2,3]}) which would be true, although these
-    // "kind" of children has no value/type etc. data as needed to display in
-    // the tree. As the passed ({children:[1,2,3]}) are instanceof
-    // itsWindow.Array and not this modules's global Array
-    // aItem.children instanceof Array can't be true, but for saftey the
-    // !aRootElement is kept here.
-    if (!aRootElement && aItem && aItem.children instanceof Array) {
-      return aItem.children;
-    }
+    aObject.forEach(function(aElement) {
+      aElement.level = aLevel;
+      aElement.isOpened = false;
+      aElement.children = null;
+    });
+  },
 
-    let pairs;
-    let newPairLevel;
+  _inspectObject: function PTV__inspectObject(aObject, aLevel)
+  {
+    this._objectCache = {};
+    this._remoteObjectProvider = this._localObjectProvider.bind(this);
+    let children = WebConsoleUtils.namesAndValuesOf(aObject, this._objectCache);
+    this._updateRemoteObject(children, aLevel);
+    return children;
+  },
 
-    if (!aRootElement) {
-      newPairLevel = aItem.level + 1;
-      aItem = aItem.value;
-    }
-    else {
-      newPairLevel = 0;
-    }
-
-    pairs = namesAndValuesOf(aItem);
-
-    for each (var pair in pairs) {
-      pair.level = newPairLevel;
-      pair.isOpened = false;
-      pair.children = pair.type == TYPE_OBJECT || pair.type == TYPE_FUNCTION ||
-                      pair.type == TYPE_ARRAY;
-    }
-
-    return pairs;
+  _localObjectProvider:
+  function PTV__localObjectProvider(aFromCacheId, aObjectId, aDestCacheId,
+                                    aCallback)
+  {
+    let object = WebConsoleUtils.namesAndValuesOf(this._objectCache[aObjectId],
+                                                  this._objectCache);
+    aCallback({cacheId: aFromCacheId,
+               objectId: aObjectId,
+               object: object,
+               childrenCacheId: aDestCacheId || aFromCacheId,
+    });
   },
 
   /** nsITreeView interface implementation **/
 
   selection: null,
 
   get rowCount()                     { return this._rows.length; },
   setTree: function(treeBox)         { this._treeBox = treeBox;  },
-  getCellText: function(idx, column) { return this._rows[idx].display; },
-  getLevel: function(idx)            { return this._rows[idx].level; },
-  isContainer: function(idx)         { return !!this._rows[idx].children; },
-  isContainerOpen: function(idx)     { return this._rows[idx].isOpened; },
+  getCellText: function(idx, column) {
+    let row = this._rows[idx];
+    return row.name + ": " + row.value;
+  },
+  getLevel: function(idx) {
+    return this._rows[idx].level;
+  },
+  isContainer: function(idx) {
+    return !!this._rows[idx].inspectable;
+  },
+  isContainerOpen: function(idx) {
+    return this._rows[idx].isOpened;
+  },
   isContainerEmpty: function(idx)    { return false; },
   isSeparator: function(idx)         { return false; },
   isSorted: function()               { return false; },
   isEditable: function(idx, column)  { return false; },
   isSelectable: function(row, col)   { return true; },
 
   getParentIndex: function(idx)
   {
     if (this.getLevel(idx) == 0) {
       return -1;
     }
-    for (var t = idx - 1; t >= 0 ; t--) {
+    for (var t = idx - 1; t >= 0; t--) {
       if (this.isContainer(t)) {
         return t;
       }
     }
     return -1;
   },
 
   hasNextSibling: function(idx, after)
   {
     var thisLevel = this.getLevel(idx);
     return this._rows.slice(after + 1).some(function (r) r.level == thisLevel);
   },
 
   toggleOpenState: function(idx)
   {
-    var item = this._rows[idx];
-    if (!item.children) {
+    let item = this._rows[idx];
+    if (!item.inspectable) {
       return;
     }
 
-    this._treeBox.beginUpdateBatch();
+    dump("toggleOpenState " + idx + " " + item.name + "\n");
+
     if (item.isOpened) {
+      this._treeBox.beginUpdateBatch();
       item.isOpened = false;
 
       var thisLevel = item.level;
       var t = idx + 1, deleteCount = 0;
       while (t < this._rows.length && this.getLevel(t++) > thisLevel) {
         deleteCount++;
       }
 
       if (deleteCount) {
         this._rows.splice(idx + 1, deleteCount);
         this._treeBox.rowCountChanged(idx + 1, -deleteCount);
       }
+      this._treeBox.invalidateRow(idx);
+      this._treeBox.endUpdateBatch();
     }
     else {
-      item.isOpened = true;
+      let levelUpdate = true;
+      let callback = function _onRemoteResponse(aResponse) {
+        dump("getRemoteObject callback " + idx + " " + item.name + "\n");
+        this._treeBox.beginUpdateBatch();
+        item.isOpened = true;
 
-      var toInsert = this.getChildItems(item);
-      item.children = toInsert;
-      this._rows.splice.apply(this._rows, [idx + 1, 0].concat(toInsert));
+        if (levelUpdate) {
+          this._updateRemoteObject(aResponse.object, item.level + 1);
+          item.children = aResponse.object;
+        }
 
-      this._treeBox.rowCountChanged(idx + 1, toInsert.length);
+        this._rows.splice.apply(this._rows, [idx + 1, 0].concat(item.children));
+
+        this._treeBox.rowCountChanged(idx + 1, item.children.length);
+        this._treeBox.invalidateRow(idx);
+        this._treeBox.endUpdateBatch();
+      }.bind(this);
+
+      if (!item.children) {
+        let fromCacheId = item.level > 0 ? this._panelCacheId :
+                                           this._rootCacheId;
+        this._remoteObjectProvider(fromCacheId, item.objectId,
+                                   this._panelCacheId, callback);
+      }
+      else {
+        levelUpdate = false;
+        callback({object: item.children});
+      }
     }
-    this._treeBox.invalidateRow(idx);
-    this._treeBox.endUpdateBatch();
   },
 
   getImageSrc: function(idx, column) { },
   getProgressMode : function(idx,column) { },
   getCellValue: function(idx, column) { },
   cycleHeader: function(col, elem) { },
   selectionChanged: function() { },
   cycleCell: function(idx, column) { },
@@ -453,17 +278,31 @@ PropertyTreeView.prototype = {
   performActionOnRow: function(action, row) { },
   getRowProperties: function(idx, column, prop) { },
   getCellProperties: function(idx, column, prop) { },
   getColumnProperties: function(column, element, prop) { },
 
   setCellValue: function(row, col, value)               { },
   setCellText: function(row, col, value)                { },
   drop: function(index, orientation, dataTransfer)      { },
-  canDrop: function(index, orientation, dataTransfer)   { return false; }
+  canDrop: function(index, orientation, dataTransfer)   { return false; },
+
+  _cleanup: function PTV__cleanup()
+  {
+    if (this._rows.length) {
+      // Reset the existing _rows children to the initial state.
+      this._updateRemoteObject(this._rows, 0);
+      this._rows = [];
+    }
+
+    delete this._objectCache;
+    delete this._rootCacheId;
+    delete this._panelCacheId;
+    delete this._remoteObjectProvider;
+  },
 };
 
 ///////////////////////////////////////////////////////////////////////////
 //// Helper for creating the panel.
 
 /**
  * Creates a DOMNode and sets all the attributes of aAttributes on the created
  * element.
@@ -508,80 +347,85 @@ function appendChild(aDocument, aParent,
 ///////////////////////////////////////////////////////////////////////////
 //// PropertyPanel
 
 /**
  * Creates a new PropertyPanel.
  *
  * @param nsIDOMNode aParent
  *        Parent node to append the created panel to.
- * @param nsIDOMDocument aDocument
- *        Document to create the new nodes on.
  * @param string aTitle
  *        Title for the panel.
  * @param string aObject
  *        Object to display in the tree.
  * @param array of objects aButtons
  *        Array with buttons to display at the bottom of the panel.
  */
-function PropertyPanel(aParent, aDocument, aTitle, aObject, aButtons)
+// TODO: update the comment
+function PropertyPanel(aParent, aTitle, aObject, aButtons)
 {
+  dump("new PropertyPanel\n");
+
+  let document = aParent.ownerDocument;
+
   // Create the underlying panel
-  this.panel = createElement(aDocument, "panel", {
+  this.panel = createElement(document, "panel", {
     label: aTitle,
     titlebar: "normal",
     noautofocus: "true",
     noautohide: "true",
     close: "true",
   });
 
   // Create the tree.
-  let tree = this.tree = createElement(aDocument, "tree", {
+  let tree = this.tree = createElement(document, "tree", {
     flex: 1,
     hidecolumnpicker: "true"
   });
 
-  let treecols = aDocument.createElement("treecols");
-  appendChild(aDocument, treecols, "treecol", {
+  let treecols = document.createElement("treecols");
+  appendChild(document, treecols, "treecol", {
     primary: "true",
     flex: 1,
     hideheader: "true",
     ignoreincolumnpicker: "true"
   });
   tree.appendChild(treecols);
 
-  tree.appendChild(aDocument.createElement("treechildren"));
+  tree.appendChild(document.createElement("treechildren"));
   this.panel.appendChild(tree);
 
   // Create the footer.
-  let footer = createElement(aDocument, "hbox", { align: "end" });
-  appendChild(aDocument, footer, "spacer", { flex: 1 });
+  let footer = createElement(document, "hbox", { align: "end" });
+  appendChild(document, footer, "spacer", { flex: 1 });
 
   // The footer can have butttons.
   let self = this;
   if (aButtons) {
     aButtons.forEach(function(button) {
-      let buttonNode = appendChild(aDocument, footer, "button", {
+      let buttonNode = appendChild(document, footer, "button", {
         label: button.label,
         accesskey: button.accesskey || "",
         class: button.class || "",
       });
       buttonNode.addEventListener("command", button.oncommand, false);
     });
   }
 
-  appendChild(aDocument, footer, "resizer", { dir: "bottomend" });
+  appendChild(document, footer, "resizer", { dir: "bottomend" });
   this.panel.appendChild(footer);
 
   aParent.appendChild(this.panel);
 
   // Create the treeView object.
   this.treeView = new PropertyTreeView();
   this.treeView.data = aObject;
 
+  dump("new treeView rows " + this.treeView._rows.length + "\n");
+
   // Set the treeView object on the tree view. This has to be done *after* the
   // panel is shown. This is because the tree binding must be attached first.
   this.panel.addEventListener("popupshown", function onPopupShow()
   {
     self.panel.removeEventListener("popupshown", onPopupShow, false);
     self.tree.view = self.treeView;
   }, false);
 
@@ -595,18 +439,15 @@ function PropertyPanel(aParent, aDocumen
 /**
  * Destroy the PropertyPanel. This closes the poped up panel and removes
  * it from the browser DOM.
  *
  * @returns void
  */
 PropertyPanel.prototype.destroy = function PP_destroy()
 {
+  dump("PP_destroy()\n");
+  this.treeView.data = null;
   this.panel.parentNode.removeChild(this.panel);
   this.treeView = null;
   this.panel = null;
   this.tree = null;
-
-  if (this.linkNode) {
-    this.linkNode._panelOpen = false;
-    this.linkNode = null;
-  }
 }
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -0,0 +1,961 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Web Console.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com>
+ *   David Dahl <ddahl@mozilla.com>
+ *   Rob Campbell <rcampbell@mozilla.com>
+ *   Johnathan Nightingale <jnightingale@mozilla.com>
+ *   Patrick Walton <pcwalton@mozilla.com>
+ *   Julian Viereck <jviereck@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+var EXPORTED_SYMBOLS = ["WebConsoleUtils", "JSPropertyProvider"];
+
+const HUD_STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+
+const TYPES = { OBJECT: 0,
+                FUNCTION: 1,
+                ARRAY: 2,
+                OTHER: 3,
+                ITERATOR: 4,
+                GETTER: 5,
+                GENERATOR: 6,
+                STRING: 7
+              };
+
+var gObjectId = 0;
+
+var WebConsoleUtils = {
+  TYPES: TYPES,
+
+  /**
+   * Convenience function to unwrap a wrapped object.
+   *
+   * @param aObject the object to unwrap.
+   * @return aObject unwrapped.
+   */
+  unwrap: function WCU_unwrap(aObject)
+  {
+    try {
+      return XPCNativeWrapper.unwrap(aObject);
+    }
+    catch (ex) {
+      return aObject;
+    }
+  },
+
+  /**
+   * Clone an object.
+   *
+   * @param object aObject
+   *        The object you want cloned.
+   * @param boolean aRecursive
+   *        Tells if you want to dig deeper into the object, to clone
+   *        recursively.
+   * @param function [aFilter]
+   *        Optional, filter function, called for every property. Three
+   *        arguments are passed: key, value and object. Return true if the
+   *        property should be added to the cloned object. Return false to skip
+   *        the property.
+   * @return object
+   *         The cloned object.
+   */
+  cloneObject: function WCU_cloneObject(aObject, aRecursive, aFilter)
+  {
+    if (typeof aObject != "object") {
+      return aObject;
+    }
+
+    let temp;
+
+    if (Array.isArray(aObject)) {
+      temp = [];
+      Array.forEach(aObject, function(aValue, aIndex) {
+        if (!aFilter || aFilter(aIndex, aValue, aObject)) {
+          temp.push(aRecursive ? WCU_cloneObject(aValue) : aValue);
+        }
+      });
+    }
+    else {
+      temp = {};
+      for (let key in aObject) {
+        let value = aObject[key];
+        if (aObject.hasOwnProperty(key) &&
+            (!aFilter || aFilter(key, value, aObject))) {
+          temp[key] = aRecursive ? WCU_cloneObject(value) : value;
+        }
+      }
+    }
+
+    return temp;
+  },
+
+  /**
+   * Gets the ID of the inner window of this DOM window.
+   *
+   * @param nsIDOMWindow aWindow
+   * @return integer
+   *         Inner ID for the given aWindow.
+   */
+  getInnerWindowId: function WCU_getInnerWindowId(aWindow)
+  {
+    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+           getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
+  },
+
+  /**
+   * Gets the ID of the outer window of this DOM window.
+   *
+   * @param nsIDOMWindow aWindow
+   * @return integer
+   *         Outer ID for the given aWindow.
+   */
+  getOuterWindowId: function WCU_getOuterWindowId(aWindow)
+  {
+    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+           getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+  },
+
+  /**
+   * Gets the window that has the given outer ID.
+   *
+   * @param integer aOuterId
+   * @param nsIDOMWindow [aHintWindow]
+   *        Optional, the window object used to QueryInterface to
+   *        nsIDOMWindowUtils. If this is not given,
+   *        Services.wm.getMostRecentWindow() is used.
+   * @return nsIDOMWindow|null
+   *         The window object with the given outer ID.
+   */
+  getWindowByOuterId: function WCU_getWindowByOuterId(aOuterId, aHintWindow)
+  {
+    let someWindow = aHintWindow || Services.wm.getMostRecentWindow(null);
+    let content = null;
+
+    if (someWindow) {
+      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+                                   getInterface(Ci.nsIDOMWindowUtils);
+      content = windowUtils.getOuterWindowWithId(aOuterId);
+    }
+
+    return content;
+  },
+
+  /**
+   * Gets the window that has the given inner ID.
+   *
+   * @param integer aInnerId
+   * @param nsIDOMWindow [aHintWindow]
+   *        Optional, the window object used to QueryInterface to
+   *        nsIDOMWindowUtils. If this is not given,
+   *        Services.wm.getMostRecentWindow() is used.
+   * @return nsIDOMWindow|null
+   *         The window object with the given inner ID.
+   */
+  getWindowByInnerId: function WCU_getWindowByInnerId(aInnerId, aHintWindow)
+  {
+    let someWindow = aHintWindow || Services.wm.getMostRecentWindow(null);
+    let content = null;
+
+    if (someWindow) {
+      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+                                   getInterface(Ci.nsIDOMWindowUtils);
+      content = windowUtils.getInnerWindowWithId(aInnerId);
+    }
+
+    return content;
+  },
+
+  /**
+   * Abbreviates the given source URL so that it can be displayed flush-right
+   * without being too distracting.
+   *
+   * @param string aSourceURL
+   *        The source URL to shorten.
+   * @return string
+   *         The abbreviated form of the source URL.
+   */
+  abbreviateSourceURL: function WCU_abbreviateSourceURL(aSourceURL)
+  {
+    // Remove any query parameters.
+    let hookIndex = aSourceURL.indexOf("?");
+    if (hookIndex > -1) {
+      aSourceURL = aSourceURL.substring(0, hookIndex);
+    }
+
+    // Remove a trailing "/".
+    if (aSourceURL[aSourceURL.length - 1] == "/") {
+      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
+    }
+
+    // Remove all but the last path component.
+    let slashIndex = aSourceURL.lastIndexOf("/");
+    if (slashIndex > -1) {
+      aSourceURL = aSourceURL.substring(slashIndex + 1);
+    }
+
+    return aSourceURL;
+  },
+
+  /**
+   * Format the jsterm execution result based on its type.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want displayed.
+   * @return string
+   *         The string that can be displayed.
+   */
+  formatResult: function WCU_formatResult(aResult)
+  {
+    let output = "";
+    let type = this.getResultType(aResult);
+
+    switch (type) {
+      case "string":
+        output = this.formatResultString(aResult);
+        break;
+      case "boolean":
+      case "date":
+      case "error":
+      case "number":
+      case "regexp":
+        output = aResult.toString();
+        break;
+      case "null":
+      case "undefined":
+        output = type;
+        break;
+      default:
+        if (aResult.toSource) {
+          try {
+            output = aResult.toSource();
+          } catch (ex) { }
+        }
+        if (!output || output == "({})") {
+          output = aResult.toString();
+        }
+        break;
+    }
+
+    return output;
+  },
+
+  /**
+   * Format a string for output.
+   *
+   * @param string aString
+   *        The string you want to display.
+   * @return string
+   *         The string that can be displayed.
+   */
+  formatResultString: function WCU_formatResultString(aString)
+  {
+    function isControlCode(c) {
+      // See http://en.wikipedia.org/wiki/C0_and_C1_control_codes
+      // C0 is 0x00-0x1F, C1 is 0x80-0x9F (inclusive).
+      // We also include DEL (U+007F) and NBSP (U+00A0), which are not strictly
+      // in C1 but border it.
+      return (c <= 0x1F) || (0x7F <= c && c <= 0xA0);
+    }
+
+    function replaceFn(aMatch, aType, aHex) {
+      // Leave control codes escaped, but unescape the rest of the characters.
+      let c = parseInt(aHex, 16);
+      return isControlCode(c) ? aMatch : String.fromCharCode(c);
+    }
+
+    let output = uneval(aString).replace(/\\(x)([0-9a-fA-F]{2})/g, replaceFn)
+                 .replace(/\\(u)([0-9a-fA-F]{4})/g, replaceFn);
+
+    return output;
+  },
+
+  /**
+   * Determine if the jsterm execution result is inspectable or not.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want to check if it is inspectable.
+   * @return boolean
+   *         True if the object is inspectable or false otherwise.
+   */
+  isResultInspectable: function WCU_isResultInspectable(aResult)
+  {
+    let isEnumerable = false;
+
+    // Skip Iterators and Generators.
+    if (this.isIteratorOrGenerator(aResult)) {
+      return false;
+    }
+
+    try {
+      for (let p in aResult) {
+        isEnumerable = true;
+        break;
+      }
+    }
+    catch (ex) {
+      // Proxy objects can lack an enumerable method.
+    }
+
+    return isEnumerable && typeof(aResult) != "string";
+  },
+
+  /**
+   * Determine the type of the jsterm execution result.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want to check.
+   * @return string
+   *         Constructor name or type: string, number, boolean, regexp, date,
+   *         function, object, null, undefined...
+   */
+  getResultType: function WCU_getResultType(aResult)
+  {
+    let type = aResult === null ? "null" : typeof aResult;
+    if (type == "object" && aResult.constructor && aResult.constructor.name) {
+      type = aResult.constructor.name;
+    }
+
+    return type.toLowerCase();
+  },
+
+  /**
+   * Figures out the type of aObject and the string to display in the tree.
+   *
+   * @param object aObject
+   *        The object to operate on.
+   * @return object
+   *         A object with the form:
+   *         {
+   *           type: TYPES.OBJECT || TYPES.FUNCTION || ...
+   *           display: string for displaying the object in the tree
+   *         }
+   */
+  presentableValueFor: function WCU_presentableValueFor(aObject)
+  {
+    let type = this.getResultType(aObject);
+    let presentable;
+
+    switch (type) {
+      case "undefined":
+      case "null":
+        return {
+          type: TYPES.OTHER,
+          display: type
+        };
+
+      case "array":
+        return {
+          type: TYPES.ARRAY,
+          display: "Array"
+        };
+
+      case "string":
+        return {
+          type: TYPES.STRING,
+          display: "\"" + aObject + "\""
+        };
+
+      case "date":
+      case "regexp":
+      case "number":
+      case "boolean":
+        return {
+          type: TYPES.OTHER,
+          display: aObject.toString()
+        };
+
+      case "iterator":
+        return {
+          type: TYPES.ITERATOR,
+          display: "Iterator"
+        };
+
+      case "function":
+        presentable = aObject.toString();
+        return {
+          type: TYPES.FUNCTION,
+          display: presentable.substring(0, presentable.indexOf(')') + 1)
+        };
+
+      default:
+        presentable = aObject.toString();
+        let m = /^\[object (\S+)\]/.exec(presentable);
+
+        try {
+          if (type == "object" && typeof aObject.next == "function" &&
+              m && m[1] == "Generator") {
+            return {
+              type: TYPES.GENERATOR,
+              display: m[1]
+            };
+          }
+        }
+        catch (ex) {
+          // window.history.next throws in the typeof check above.
+          return {
+            type: TYPES.OBJECT,
+            display: m ? m[1] : "Object"
+          };
+        }
+
+        if (type == "object" && typeof aObject.__iterator__ == "function") {
+          return {
+            type: TYPES.ITERATOR,
+            display: "Iterator"
+          };
+        }
+
+        return {
+          type: TYPES.OBJECT,
+          display: m ? m[1] : "Object"
+        };
+    }
+  },
+
+  /**
+   * Tells if the given function is native or not.
+   *
+   * @param function aFunction
+   *        The function you want to check if it is native or not.
+   *
+   * @return boolean
+   *         True if the given function is native, false otherwise.
+   */
+  isNativeFunction: function WCU_isNativeFunction(aFunction)
+  {
+    return typeof aFunction == "function" && !("prototype" in aFunction);
+  },
+
+  /**
+   * Tells if the given property of the provided object is a non-native getter or
+   * not.
+   *
+   * @param object aObject
+   *        The object that contains the property.
+   *
+   * @param string aProp
+   *        The property you want to check if it is a getter or not.
+   *
+   * @return boolean
+   *         True if the given property is a getter, false otherwise.
+   */
+  isNonNativeGetter: function WCU_isNonNativeGetter(aObject, aProp)
+  {
+    if (typeof aObject != "object") {
+      return false;
+    }
+    let desc;
+    while (aObject) {
+      try {
+        if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
+          break;
+        }
+      }
+      catch (ex) {
+        // Native getters throw here. See bug 520882.
+        if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
+            ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
+          return false;
+        }
+        throw ex;
+      }
+      aObject = Object.getPrototypeOf(aObject);
+    }
+    if (desc && desc.get && !this.isNativeFunction(desc.get)) {
+      return true;
+    }
+    return false;
+  },
+
+  /**
+   * Get an array of property name value pairs for the tree.
+   *
+   * @param object aObject
+   *        The object to get properties for.
+   * @param object aObjectCache
+   *        Optional object cache where to store references to properties of
+   *        aObject that are inspectable.
+   * @returns array of object
+   *          Objects have the name, value, display, type, children properties.
+   */
+  // TODO: check/update comment.
+  namesAndValuesOf: function WCU_namesAndValuesOf(aObject, aObjectCache)
+  {
+    let pairs = [];
+    let value, presentable;
+
+    let isDOMDocument = aObject instanceof Ci.nsIDOMDocument;
+
+    for (let propName in aObject) {
+      // See bug 632275: skip deprecated width and height properties.
+      if (isDOMDocument && (propName == "width" || propName == "height")) {
+        continue;
+      }
+
+      // Also skip non-native getters.
+      if (this.isNonNativeGetter(aObject, propName)) {
+        value = "";
+        presentable = {type: TYPES.GETTER, display: "Getter"};
+      }
+      else {
+        value = aObject[propName];
+        presentable = this.presentableValueFor(value);
+      }
+
+      let pair = {};
+      pair.name = propName;
+      pair.value = presentable.display;
+      pair.inspectable = false;
+      pair.type = presentable.type;
+
+      switch (presentable.type) {
+        case TYPES.GETTER:
+        case TYPES.ITERATOR:
+        case TYPES.GENERATOR:
+        case TYPES.STRING:
+          break;
+        default:
+          try {
+            for (let p in value) {
+              pair.inspectable = true;
+              break;
+            }
+          }
+          catch (ex) { }
+          break;
+      }
+
+      if (pair.inspectable && aObjectCache) {
+        pair.objectId = ++gObjectId;
+        aObjectCache[pair.objectId] = value;
+      }
+
+      pairs.push(pair);
+    }
+
+    pairs.sort(function(a, b)
+    {
+      // Convert the pair.name to a number for later sorting.
+      let aNumber = parseFloat(a.name);
+      let bNumber = parseFloat(b.name);
+
+      // Sort numbers.
+      if (!isNaN(aNumber) && isNaN(bNumber)) {
+        return -1;
+      }
+      else if (isNaN(aNumber) && !isNaN(bNumber)) {
+        return 1;
+      }
+      else if (!isNaN(aNumber) && !isNaN(bNumber)) {
+        return aNumber - bNumber;
+      }
+      // Sort string.
+      else if (a.name < b.name) {
+        return -1;
+      }
+      else if (a.name > b.name) {
+        return 1;
+      }
+      else {
+        return 0;
+      }
+    });
+
+    return pairs;
+  },
+
+  isIteratorOrGenerator: function WCU_isIteratorOrGenerator(aObject)
+  {
+    if (aObject === null) {
+      return false;
+    }
+
+    if (typeof aObject == "object") {
+      if (typeof aObject.__iterator__ == "function" ||
+          aObject.constructor && aObject.constructor.name == "Iterator") {
+        return true;
+      }
+
+      try {
+        let str = aObject.toString();
+        if (typeof aObject.next == "function" &&
+            str.indexOf("[object Generator") == 0) {
+          return true;
+        }
+      }
+      catch (ex) {
+        // window.history.next throws in the typeof check above.
+        return false;
+      }
+    }
+
+    return false;
+  },
+
+  /**
+   * Convert a date from the milliseconds format to the ISO 8601 date format.
+   *
+   * @param integer aTime
+   *        Milliseconds since 1 January 1970 00:00:00 UTC.
+   * @return string
+   *         The date in ISO 8601 format.
+   */
+  millisecondsToISO8601: function WCU_millisecondsToISO8601(aTime)
+  {
+    let date = new Date(aTime);
+    let month = date.getMonth();
+    let day = date.getDay();
+    let hours = date.getHours();
+    let minutes = date.getMinutes();
+    let seconds = date.getSeconds();
+    let ms = date.getMilliseconds();
+    let offset = date.getTimezoneOffset();
+    let offsetSign = offset > 0 ? "-" : "+";
+    let offsetHours = Math.abs(Math.floor(offset / 60));
+    let offsetMinutes = Math.abs(offset % 60);
+    return date.getFullYear() + "-" +
+           (month < 10 ? "0" + month : month) + "-" +
+           (day < 10 ? "0" + day : day) + "T" +
+           (hours < 10 ? "0" + hours : hours) + ":" +
+           (minutes < 10 ? "0" + minutes : minutes) + ":" +
+           (seconds < 10 ? "0" + seconds : seconds) + "." +
+           ms + offsetSign +
+           (offsetHours < 10 ? "0" + offsetHours : offsetHours) + ":" +
+           (offsetMinutes < 10 ? "0" + offsetMinutes : offsetMinutes);
+  },
+
+  /**
+   * Convert a date from the ISO 8601 format into milliseconds since 1 January 
+   * 1970 00:00:00 UTC.
+   *
+   * @param string aTime
+   *        The date in ISO 8601 format.
+   * @return string
+   *         Milliseconds since 1 January 1970 00:00:00 UTC.
+   */
+  convertISO8601toMilliseconds: function WCU_convertISO8601toMilliseconds(aTime)
+  {
+    return new Date(aTime).getTime();
+  },
+};
+
+//////////////////////////////////////////////////////////////////////////
+// Localization
+//////////////////////////////////////////////////////////////////////////
+
+WebConsoleUtils.l10n = {
+  /**
+   * Generates a formatted timestamp string for displaying in console messages.
+   *
+   * @param integer [aMilliseconds]
+   *        Optional, allows you to specify the timestamp in milliseconds since
+   *        the UNIX epoch.
+   * @returns string
+   *          The timestamp formatted for display.
+   */
+  timestampString: function WCU_l10n_timestampString(aMilliseconds)
+  {
+    let d = new Date(aMilliseconds ? aMilliseconds : null);
+    let hours = d.getHours(), minutes = d.getMinutes();
+    let seconds = d.getSeconds(), milliseconds = d.getMilliseconds();
+    let parameters = [ hours, minutes, seconds, milliseconds ];
+    return this.getFormatStr("timestampFormat", parameters);
+  },
+
+  getStr: function WCU_l10n_getStr(aName)
+  {
+    let result;
+    try {
+      result = this.stringBundle.GetStringFromName(aName);
+    }
+    catch (ex) {
+      Cu.reportError("Failed to get string: " + aName);
+      throw ex;
+    }
+    return result;
+  },
+
+  getFormatStr: function WCU_l10n_getFormatStr(aName, aArray)
+  {
+    let result;
+    try {
+      result = this.stringBundle.formatStringFromName(aName, aArray, aArray.length);
+    }
+    catch (ex) {
+      Cu.reportError("Failed to format string: " + aName);
+      throw ex;
+    }
+    return result;
+  },
+};
+
+XPCOMUtils.defineLazyGetter(WebConsoleUtils.l10n, "stringBundle", function() {
+  return Services.strings.createBundle(HUD_STRINGS_URI);
+});
+
+
+//////////////////////////////////////////////////////////////////////////
+// JS Completer
+//////////////////////////////////////////////////////////////////////////
+
+var JSPropertyProvider = (function(WCU) {
+const STATE_NORMAL = 0;
+const STATE_QUOTE = 2;
+const STATE_DQUOTE = 3;
+
+const OPEN_BODY = "{[(".split("");
+const CLOSE_BODY = "}])".split("");
+const OPEN_CLOSE_BODY = {
+  "{": "}",
+  "[": "]",
+  "(": ")",
+};
+
+/**
+ * Analyses a given string to find the last statement that is interesting for
+ * later completion.
+ *
+ * @param   string aStr
+ *          A string to analyse.
+ *
+ * @returns object
+ *          If there was an error in the string detected, then a object like
+ *
+ *            { err: "ErrorMesssage" }
+ *
+ *          is returned, otherwise a object like
+ *
+ *            {
+ *              state: STATE_NORMAL|STATE_QUOTE|STATE_DQUOTE,
+ *              startPos: index of where the last statement begins
+ *            }
+ */
+function findCompletionBeginning(aStr)
+{
+  let bodyStack = [];
+
+  let state = STATE_NORMAL;
+  let start = 0;
+  let c;
+  for (let i = 0; i < aStr.length; i++) {
+    c = aStr[i];
+
+    switch (state) {
+      // Normal JS state.
+      case STATE_NORMAL:
+        if (c == '"') {
+          state = STATE_DQUOTE;
+        }
+        else if (c == "'") {
+          state = STATE_QUOTE;
+        }
+        else if (c == ";") {
+          start = i + 1;
+        }
+        else if (c == " ") {
+          start = i + 1;
+        }
+        else if (OPEN_BODY.indexOf(c) != -1) {
+          bodyStack.push({
+            token: c,
+            start: start
+          });
+          start = i + 1;
+        }
+        else if (CLOSE_BODY.indexOf(c) != -1) {
+          var last = bodyStack.pop();
+          if (!last || OPEN_CLOSE_BODY[last.token] != c) {
+            return {
+              err: "syntax error"
+            };
+          }
+          if (c == "}") {
+            start = i + 1;
+          }
+          else {
+            start = last.start;
+          }
+        }
+        break;
+
+      // Double quote state > " <
+      case STATE_DQUOTE:
+        if (c == "\\") {
+          i++;
+        }
+        else if (c == "\n") {
+          return {
+            err: "unterminated string literal"
+          };
+        }
+        else if (c == '"') {
+          state = STATE_NORMAL;
+        }
+        break;
+
+      // Single quoate state > ' <
+      case STATE_QUOTE:
+        if (c == "\\") {
+          i++;
+        }
+        else if (c == "\n") {
+          return {
+            err: "unterminated string literal"
+          };
+          return;
+        }
+        else if (c == "'") {
+          state = STATE_NORMAL;
+        }
+        break;
+    }
+  }
+
+  return {
+    state: state,
+    startPos: start
+  };
+}
+
+/**
+ * Provides a list of properties, that are possible matches based on the passed
+ * scope and inputValue.
+ *
+ * @param object aScope
+ *        Scope to use for the completion.
+ *
+ * @param string aInputValue
+ *        Value that should be completed.
+ *
+ * @returns null or object
+ *          If no completion valued could be computed, null is returned,
+ *          otherwise a object with the following form is returned:
+ *            {
+ *              matches: [ string, string, string ],
+ *              matchProp: Last part of the inputValue that was used to find
+ *                         the matches-strings.
+ *            }
+ */
+function JSPropertyProvider(aScope, aInputValue)
+{
+  let obj = WCU.unwrap(aScope);
+
+  // Analyse the aInputValue and find the beginning of the last part that
+  // should be completed.
+  let beginning = findCompletionBeginning(aInputValue);
+
+  // There was an error analysing the string.
+  if (beginning.err) {
+    return null;
+  }
+
+  // If the current state is not STATE_NORMAL, then we are inside of an string
+  // which means that no completion is possible.
+  if (beginning.state != STATE_NORMAL) {
+    return null;
+  }
+
+  let completionPart = aInputValue.substring(beginning.startPos);
+
+  // Don't complete on just an empty string.
+  if (completionPart.trim() == "") {
+    return null;
+  }
+
+  let properties = completionPart.split(".");
+  let matchProp;
+  if (properties.length > 1) {
+    matchProp = properties.pop().trimLeft();
+    for (let i = 0; i < properties.length; i++) {
+      let prop = properties[i].trim();
+
+      // If obj is undefined or null, then there is no chance to run completion
+      // on it. Exit here.
+      if (typeof obj === "undefined" || obj === null) {
+        return null;
+      }
+
+      // Check if prop is a getter function on obj. Functions can change other
+      // stuff so we can't execute them to get the next object. Stop here.
+      if (WCU.isNonNativeGetter(obj, prop)) {
+        return null;
+      }
+      try {
+        obj = obj[prop];
+      }
+      catch (ex) {
+        return null;
+      }
+    }
+  }
+  else {
+    matchProp = properties[0].trimLeft();
+  }
+
+  // If obj is undefined or null, then there is no chance to run
+  // completion on it. Exit here.
+  if (typeof obj === "undefined" || obj === null) {
+    return null;
+  }
+
+  // Skip Iterators and Generators.
+  if (WCU.isIteratorOrGenerator(obj)) {
+    return null;
+  }
+
+  let matches = [];
+  for (let prop in obj) {
+    if (prop.indexOf(matchProp) == 0) {
+      matches.push(prop);
+    }
+  }
+
+  return {
+    matchProp: matchProp,
+    matches: matches.sort(),
+  };
+}
+
+return JSPropertyProvider;
+})(WebConsoleUtils);
