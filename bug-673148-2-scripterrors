# HG changeset patch
# Parent f5d8354ebb39aecf37a14c898536eea6a5128b51
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1336662097 -10800

Bug 673148 - (async-webconsole) Part 2 - Make script and style errors async

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -2,41 +2,35 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 // This code is appended to the browser content script.
-(function(_global) {
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
+(function _HUDServiceContent() {
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
 
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
+let tempScope = {};
+Cu.import("resource://gre/modules/XPCOMUtils.jsm", tempScope);
+Cu.import("resource://gre/modules/Services.jsm", tempScope);
+Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", tempScope);
+Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
 
-XPCOMUtils.defineLazyGetter(_global, "gConsoleStorage", function () {
-  let obj = {};
-  Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", obj);
-  return obj.ConsoleAPIStorage;
-});
+let XPCOMUtils = tempScope.XPCOMUtils;
+let Services = tempScope.Services;
+let gConsoleStorage = tempScope.ConsoleAPIStorage;
+let WebConsoleUtils = tempScope.WebConsoleUtils;
+let l10n = WebConsoleUtils.l10n;
+tempScope = null;
 
-XPCOMUtils.defineLazyGetter(_global, "WebConsoleUtils", function () {
-  let obj = {};
-  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
-  return obj.WebConsoleUtils;
-});
-
-XPCOMUtils.defineLazyGetter(_global, "l10n", function () {
-  return WebConsoleUtils.l10n;
-});
-
-_global = null;
+let _alive = true; // Track if this content script should still be alive.
 
 /**
  * The Web Console content instance manager.
  */
 let Manager = {
   get window() content,
   get console() this.window.console,
   sandbox: null,
@@ -58,24 +52,48 @@ let Manager = {
   init: function Manager_init()
   {
     this._enabledFeatures = [];
     this._messageHandlers = {};
 
     this._messageListeners.forEach(function(aName) {
       addMessageListener(aName, this);
     }, this);
+
+    // Need to track the owner XUL window to listen to the unload and TabClose
+    // events, to avoid memory leaks.
+    let xulWindow = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                    .getInterface(Ci.nsIWebNavigation)
+                    .QueryInterface(Ci.nsIDocShell)
+                    .chromeEventHandler.ownerDocument.defaultView;
+
+    xulWindow.addEventListener("unload", this._onXULWindowClose, false);
+
+    let tabContainer = xulWindow.gBrowser.tabContainer;
+    tabContainer.addEventListener("TabClose", this._onTabClose, false);
+
+    // Need to track private browsing change and quit application notifications,
+    // again to avoid memory leaks. The Web Console main process cannot notify
+    // this content script when the XUL window close, tab close, private
+    // browsing change and quit application events happen, so we must call
+    // Manager.destroy() on our own.
+    Services.obs.addObserver(this, "private-browsing-change-granted", false);
+    Services.obs.addObserver(this, "quit-application-granted", false);
   },
 
   /**
    * The message handler. This method forwards all the remote messages to the
    * appropriate code.
    */
   receiveMessage: function Manager_receiveMessage(aMessage)
   {
+    if (!_alive) {
+      return;
+    }
+
     if (!aMessage.json || (aMessage.name != "WebConsole:Init" &&
                            aMessage.json.hudId != this.hudId)) {
       Cu.reportError("Web Console content script: received message " +
                      aMessage.name + " from wrong hudId!");
       return;
     }
 
     switch (aMessage.name) {
@@ -95,29 +113,47 @@ let Manager = {
         let handler = this._messageHandlers[aMessage.name];
         handler && handler(aMessage.json);
         break;
       }
     }
   },
 
   /**
+   * Observe notifications from the nsIObserverService.
+   *
+   * @param mixed aSubject
+   * @param string aTopic
+   * @param mixed aData
+   */
+  observe: function Manager_observe(aSubject, aTopic, aData)
+  {
+    if (_alive && (aTopic == "quit-application-granted" ||
+        (aTopic == "private-browsing-change-granted" &&
+         (aData == "enter" || aData == "exit")))) {
+      this.destroy();
+    }
+  },
+
+  /**
    * The manager initialization code. This method is called when the Web Console
    * remote process initializes the content process (this code!).
    *
    * @param object aMessage
    *        The object received from the remote process. The WebConsole:Init
    *        message properties:
    *        - hudId - (required) the remote Web Console instance ID.
    *        - features - (optional) array of features you want to enable from
    *        the start. For each feature you enable you can pass feature-specific
    *        options in a property on the JSON object you send with the same name
-   *        as the feature.
+   *        as the feature. See this.enableFeature() for the list of available
+   *        features.
    *        - cachedMessages - (optional) an array of cached messages you want
-   *        to receive: only "ConsoleAPI" is available for now.
+   *        to receive. See this._sendCachedMessages() for the list of available
+   *        message types.
    *
    *        Example message:
    *        {
    *          hudId: "foo1",
    *          features: ["JSTerm", "ConsoleAPI"],
    *          ConsoleAPI: { ... }, // ConsoleAPI-specific options
    *          cachedMessages: ["ConsoleAPI"],
    *        }
@@ -198,16 +234,18 @@ let Manager = {
    * a set of observers/listeners that are added in the content process. This
    * content script exposes the data via the message manager for the features
    * you enable.
    *
    * Supported features:
    *    - JSTerm - a JavaScript "terminal" which allows code execution.
    *    - ConsoleAPI - support for routing the window.console API to the remote
    *    process.
+   *    - PageError - route all the nsIScriptErrors from the nsIConsoleService
+   *    to the remote process.
    *
    * @param string aFeature
    *        One of the supported features: JSTerm, ConsoleAPI.
    * @param object [aMessage]
    *        Optional JSON message object coming from the remote Web Console
    *        instance. This can be used for feature-specific options.
    */
   enableFeature: function Manager_enableFeature(aFeature, aMessage)
@@ -218,89 +256,141 @@ let Manager = {
 
     switch (aFeature) {
       case "JSTerm":
         JSTerm.init(aMessage);
         break;
       case "ConsoleAPI":
         ConsoleAPIObserver.init(aMessage);
         break;
+      case "PageError":
+        ConsoleListener.init(aMessage);
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
 
     this._enabledFeatures.push(aFeature);
   },
 
   /**
    * Disable a Web Console content script feature.
    *
    * @see this.enableFeature
    * @param string aFeature
-   *        One of the supported features: JSTerm, ConsoleAPI.
+   *        One of the supported features - see this.enableFeature() for the
+   *        list of supported features.
    */
   disableFeature: function Manager_disableFeature(aFeature)
   {
     let index = this._enabledFeatures.indexOf(aFeature);
     if (index == -1) {
       return;
     }
     this._enabledFeatures.splice(index, 1);
 
     switch (aFeature) {
       case "JSTerm":
         JSTerm.destroy();
         break;
       case "ConsoleAPI":
         ConsoleAPIObserver.destroy();
         break;
+      case "PageError":
+        ConsoleListener.destroy();
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
   },
 
   /**
    * Send the cached messages to the remote Web Console instance.
    *
    * @private
    * @param array aMessageTypes
-   *        An array that lists which kinds of messages you want. Currently only
-   *        "ConsoleAPI" messages are supported.
+   *        An array that lists which kinds of messages you want. Supported
+   *        message types: "ConsoleAPI" and "PageError".
    */
   _sendCachedMessages: function Manager__sendCachedMessages(aMessageTypes)
   {
     let messages = [];
 
-    switch (aMessageTypes.shift()) {
-      case "ConsoleAPI":
-        messages.push.apply(messages, ConsoleAPIObserver.getCachedMessages());
-        break;
+    while (aMessageTypes.length > 0) {
+      switch (aMessageTypes.shift()) {
+        case "ConsoleAPI":
+          messages.push.apply(messages, ConsoleAPIObserver.getCachedMessages());
+          break;
+        case "PageError":
+          messages.push.apply(messages, ConsoleListener.getCachedMessages());
+          break;
+      }
     }
 
     messages.sort(function(a, b) { return a.timeStamp - b.timeStamp; });
 
     this.sendMessage("WebConsole:CachedMessages", {messages: messages});
   },
 
   /**
+   * The XUL window "unload" event handler which destroys this content script
+   * instance.
+   * @private
+   */
+  _onXULWindowClose: function Manager__onXULWindowClose()
+  {
+    if (_alive) {
+      Manager.destroy();
+    }
+  },
+
+  /**
+   * The "TabClose" event handler which destroys this content script
+   * instance, if needed.
+   * @private
+   */
+  _onTabClose: function Manager__onTabClose(aEvent)
+  {
+    let tab = aEvent.target;
+    if (_alive && tab.linkedBrowser.contentWindow === Manager.window) {
+      Manager.destroy();
+    }
+  },
+
+  /**
    * Destroy the Web Console content script instance.
    */
   destroy: function Manager_destroy()
   {
+    Services.obs.removeObserver(this, "private-browsing-change-granted");
+    Services.obs.removeObserver(this, "quit-application-granted");
+
+    _alive = false;
+    let xulWindow = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                    .getInterface(Ci.nsIWebNavigation)
+                    .QueryInterface(Ci.nsIDocShell)
+                    .chromeEventHandler.ownerDocument.defaultView;
+
+    xulWindow.removeEventListener("unload", this._onXULWindowClose, false);
+    let tabContainer = xulWindow.gBrowser.tabContainer;
+    tabContainer.removeEventListener("TabClose", this._onTabClose, false);
+
     this._messageListeners.forEach(function(aName) {
       removeMessageListener(aName, this);
     }, this);
 
     this._enabledFeatures.slice().forEach(this.disableFeature, this);
 
     this.hudId = null;
     this._messageHandlers = null;
-    Manager = ConsoleAPIObserver = JSTerm = null;
+    Manager = ConsoleAPIObserver = JSTerm = ConsoleListener = null;
+    Cc = Ci = Cu = XPCOMUtils = Services = gConsoleStorage =
+      WebConsoleUtils = l10n = null;
   },
 };
 
 /**
  * The JavaScript terminal is meant to allow remote code execution for the Web
  * Console.
  */
 let JSTerm = {
@@ -442,17 +532,17 @@ let ConsoleAPIObserver = {
    *
    * @param object aMessage
    *        The message object receives from the observer service.
    * @param string aTopic
    *        The message topic received from the observer service.
    */
   observe: function CAO_observe(aMessage, aTopic)
   {
-    if (!aMessage || aTopic != "console-api-log-event") {
+    if (!_alive || !aMessage || aTopic != "console-api-log-event") {
       return;
     }
 
     let apiMessage = aMessage.wrappedJSObject;
 
     let msgWindow =
       WebConsoleUtils.getWindowByOuterId(apiMessage.ID, Manager.window);
     if (!msgWindow || msgWindow.top != Manager.window) {
@@ -573,21 +663,17 @@ let ConsoleAPIObserver = {
    *         prepared to be sent to the remote Web Console instance.
    */
   getCachedMessages: function CAO_getCachedMessages()
   {
     let innerWindowId = WebConsoleUtils.getInnerWindowId(Manager.window);
     let messages = gConsoleStorage.getEvents(innerWindowId);
 
     let result = messages.map(function(aMessage) {
-      let remoteMessage = {
-        hudId: Manager.hudId,
-        id: Manager.sequenceId,
-        type: "ConsoleAPI",
-      };
+      let remoteMessage = { _type: "ConsoleAPI" };
       this._prepareApiMessageForRemote(aMessage.wrappedJSObject, remoteMessage);
       return remoteMessage;
     }, this);
 
     return result;
   },
 
   /**
@@ -604,10 +690,101 @@ let ConsoleAPIObserver = {
    */
   destroy: function CAO_destroy()
   {
     Manager.removeMessageHandler("ConsoleAPI:ClearCache");
     Services.obs.removeObserver(this, "console-api-log-event");
   },
 };
 
+/**
+ * The nsIConsoleService listener. This is used to send all the page errors
+ * (JavaScript, CSS and more) to the remote Web Console instance.
+ */
+let ConsoleListener = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIConsoleListener]),
+
+  /**
+   * Initialize the nsIConsoleService listener.
+   */
+  init: function CL_init()
+  {
+    Services.console.registerListener(this);
+  },
+
+  /**
+   * The nsIConsoleService observer. This method takes all the script error
+   * messages belonging to the current window and sends them to the remote Web
+   * Console instance.
+   *
+   * @param nsIScriptError aScriptError
+   *        The script error object coming from the nsIConsoleService.
+   */
+  observe: function CL_observe(aScriptError)
+  {
+    if (!_alive || !(aScriptError instanceof Ci.nsIScriptError) ||
+        !aScriptError.outerWindowID) {
+      return;
+    }
+
+    switch (aScriptError.category) {
+      // We ignore chrome-originating errors as we only care about content.
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return;
+    }
+
+    let errorWindow =
+      WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID,
+                                         Manager.window);
+    if (!errorWindow || errorWindow.top != Manager.window) {
+      return;
+    }
+
+    Manager.sendMessage("WebConsole:PageError", { pageError: aScriptError });
+  },
+
+  /**
+   * Get the cached page errors for the current inner window.
+   *
+   * @return array
+   *         The array of cached messages. Each element is an nsIScriptError
+   *         with an added _type property so the remote Web Console instance can
+   *         tell the difference between various types of cached messages.
+   */
+  getCachedMessages: function CL_getCachedMessages()
+  {
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(Manager.window);
+    let result = [];
+    let errors = {};
+    Services.console.getMessageArray(errors, {});
+
+    (errors.value || []).forEach(function(aError) {
+      if (!(aError instanceof Ci.nsIScriptError) ||
+          aError.innerWindowID != innerWindowId) {
+        return;
+      }
+
+      let remoteMessage = WebConsoleUtils.cloneObject(aError);
+      remoteMessage._type = "PageError";
+      result.push(remoteMessage);
+    });
+
+    return result;
+  },
+
+  /**
+   * Remove the nsIConsoleService listener.
+   */
+  destroy: function CL_destroy()
+  {
+    Services.console.unregisterListener(this);
+  },
+};
+
 Manager.init();
-})(this);
+})();
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -1498,18 +1498,19 @@ HUD_SERVICE.prototype =
   deactivateHUDForContext: function HS_deactivateHUDForContext(aContext, aAnimated)
   {
     let browser = aContext.linkedBrowser;
     let window = browser.contentWindow;
     let chromeDocument = aContext.ownerDocument;
     let nBox = chromeDocument.defaultView.getNotificationBox(window);
     let hudId = "hud_" + nBox.id;
     let displayNode = chromeDocument.getElementById(hudId);
-
-    if (hudId in this.hudReferences && displayNode) {
+    let hudFound = (hudId in this.hudReferences) && displayNode;
+
+    if (hudFound) {
       if (!aAnimated) {
         this.storeHeight(hudId);
       }
 
       let hud = this.hudReferences[hudId];
       browser.webProgress.removeProgressListener(hud.progressListener);
       delete hud.progressListener;
 
@@ -1528,18 +1529,20 @@ HUD_SERVICE.prototype =
         return id !== hudId;
       });
       if (procInstr.contexts.length == 0 && procInstr.parentNode) {
         procInstr.parentNode.removeChild(procInstr);
         delete aContext.ownerDocument.gcliCssProcInstr;
       }
     }
 
-    let id = WebConsoleUtils.supportsString(hudId);
-    Services.obs.notifyObservers(id, "web-console-destroyed", null);
+    if (hudFound) {
+      let id = WebConsoleUtils.supportsString(hudId);
+      Services.obs.notifyObservers(id, "web-console-destroyed", null);
+    }
   },
 
   /**
    * get a unique ID from the sequence generator
    *
    * @returns integer
    */
   sequenceId: function HS_sequencerId()
@@ -1849,18 +1852,16 @@ HUD_SERVICE.prototype =
     if (Object.keys(this.hudReferences).length > 0) {
       return;
     }
 
     // begin observing HTTP traffic
     this.startHTTPObservation();
 
     HUDWindowObserver.init();
-    HUDConsoleObserver.init();
-    ConsoleAPIObserver.init();
   },
 
   /**
    * Suspend Web Console activity. This is called when all Web Consoles are
    * closed.
    *
    * @returns void
    */
@@ -1875,18 +1876,16 @@ HUD_SERVICE.prototype =
     this.openRequests = {};
     this.openResponseHeaders = {};
 
     delete this.defaultFilterPrefs;
 
     delete this.lastFinishedRequestCallback;
 
     HUDWindowObserver.uninit();
-    HUDConsoleObserver.uninit();
-    ConsoleAPIObserver.shutdown();
   },
 
   /**
    * Shutdown all HeadsUpDisplays on xpcom-shutdown
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
@@ -1983,83 +1982,16 @@ HUD_SERVICE.prototype =
     let message = stringBundle.GetStringFromName("ConsoleAPIDisabled");
     let node = ConsoleUtils.createMessageNode(chromeDocument, CATEGORY_JS,
                                               SEVERITY_WARNING, message,
                                               aHUDId);
     ConsoleUtils.outputMessageNode(node, aHUDId);
   },
 
   /**
-   * Reports an error in the page source, either JavaScript or CSS.
-   *
-   * @param nsIScriptError aScriptError
-   *        The error message to report.
-   * @return void
-   */
-  reportPageError: function HS_reportPageError(aScriptError)
-  {
-    if (!aScriptError.outerWindowID) {
-      return;
-    }
-
-    let category;
-
-    switch (aScriptError.category) {
-      // We ignore chrome-originating errors as we only care about content.
-      case "XPConnect JavaScript":
-      case "component javascript":
-      case "chrome javascript":
-      case "chrome registration":
-      case "XBL":
-      case "XBL Prototype Handler":
-      case "XBL Content Sink":
-      case "xbl javascript":
-        return;
-
-      case "CSS Parser":
-      case "CSS Loader":
-        category = CATEGORY_CSS;
-        break;
-
-      default:
-        category = CATEGORY_JS;
-        break;
-    }
-
-    // Warnings and legacy strict errors become warnings; other types become
-    // errors.
-    let severity = SEVERITY_ERROR;
-    if ((aScriptError.flags & aScriptError.warningFlag) ||
-        (aScriptError.flags & aScriptError.strictFlag)) {
-      severity = SEVERITY_WARNING;
-    }
-
-    let window = WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID);
-    if (window) {
-      let hudId = HUDService.getHudIdByWindow(window.top);
-      if (hudId) {
-        let outputNode = this.hudReferences[hudId].outputNode;
-        let chromeDocument = outputNode.ownerDocument;
-
-        let node = ConsoleUtils.createMessageNode(chromeDocument,
-                                                  category,
-                                                  severity,
-                                                  aScriptError.errorMessage,
-                                                  hudId,
-                                                  aScriptError.sourceName,
-                                                  aScriptError.lineNumber,
-                                                  null, null,
-                                                  aScriptError.timeStamp);
-
-        ConsoleUtils.outputMessageNode(node, hudId);
-      }
-    }
-  },
-
-  /**
    * Register a Gecko app's specialized ApplicationHooks object
    *
    * @returns void or throws "UNSUPPORTED APPLICATION" error
    */
   registerApplicationHooks:
   function HS_registerApplications(aAppName, aHooksObject)
   {
     switch(aAppName) {
@@ -3025,17 +2957,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Message names that the HUD listens for. These messages come from the remote
    * Web Console content script.
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
-                      "WebConsole:CachedMessages"],
+                      "WebConsole:CachedMessages", "WebConsole:PageError"],
 
   consolePanel: null,
 
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
@@ -3369,52 +3301,40 @@ HeadsUpDisplay.prototype = {
       throw new Error("Unsupported Gecko Application");
     }
   },
 
   /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
+   * @private
    * @param array aRemoteMessages
    *        Array of cached messages coming from the remote Web Console
    *        content instance.
    */
-  displayCachedConsoleMessages:
-  function HUD_displayCachedConsoleMessages(aRemoteMessages)
-  {
-    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.contentWindow);
-
-    let messages = aRemoteMessages;
-
-    let errors = {};
-    Services.console.getMessageArray(errors, {});
-
-    // Filter the errors to find only those we should display.
-    let filteredErrors = (errors.value || []).filter(function(aError) {
-      return aError instanceof Ci.nsIScriptError &&
-             aError.innerWindowID == innerWindowId;
-    }, this);
-
-    messages.push.apply(messages, filteredErrors);
-    messages.sort(function(a, b) { return a.timeStamp - b.timeStamp; });
+  _displayCachedConsoleMessages:
+  function HUD__displayCachedConsoleMessages(aRemoteMessages)
+  {
+    if (!aRemoteMessages.length) {
+      return;
+    }
 
     // Turn off scrolling for the moment.
     ConsoleUtils.scroll = false;
     this.outputNode.hidden = true;
 
-    // Display all messages.
-    messages.forEach(function(aMessage) {
-      if (aMessage instanceof Ci.nsIScriptError) {
-        HUDService.reportPageError(aMessage);
-      }
-      else {
-        // In this case the cached message is a console message generated
-        // by the ConsoleAPI, not an nsIScriptError
-        this.logConsoleAPIMessage(aMessage);
+    aRemoteMessages.forEach(function(aMessage) {
+      switch (aMessage._type) {
+        case "PageError":
+          this.reportPageError(aMessage);
+          break;
+        case "ConsoleAPI":
+          this.logConsoleAPIMessage(aMessage);
+          break;
       }
     }, this);
 
     this.outputNode.hidden = false;
     ConsoleUtils.scroll = true;
 
     // Scroll to bottom.
     let numChildren = this.outputNode.childNodes.length;
@@ -4068,16 +3988,74 @@ HeadsUpDisplay.prototype = {
       tree.view = node.propertyTreeView;
 
       // Make sure the cached evaluated object will be purged when the node is
       // removed.
       node._evalCacheId = aMessage.objectsCacheId;
     }
   },
 
+  /**
+   * Reports an error in the page source, either JavaScript or CSS.
+   *
+   * @param nsIScriptError aScriptError
+   *        The error message to report.
+   */
+  reportPageError: function HUD_reportPageError(aScriptError)
+  {
+    if (!aScriptError.outerWindowID) {
+      return;
+    }
+
+    let category;
+
+    switch (aScriptError.category) {
+      // We ignore chrome-originating errors as we only care about content.
+      case "XPConnect JavaScript":
+      case "component javascript":
+      case "chrome javascript":
+      case "chrome registration":
+      case "XBL":
+      case "XBL Prototype Handler":
+      case "XBL Content Sink":
+      case "xbl javascript":
+        return;
+
+      case "CSS Parser":
+      case "CSS Loader":
+        category = CATEGORY_CSS;
+        break;
+
+      default:
+        category = CATEGORY_JS;
+        break;
+    }
+
+    // Warnings and legacy strict errors become warnings; other types become
+    // errors.
+    let severity = SEVERITY_ERROR;
+    if ((aScriptError.flags & aScriptError.warningFlag) ||
+        (aScriptError.flags & aScriptError.strictFlag)) {
+      severity = SEVERITY_WARNING;
+    }
+
+    let node = ConsoleUtils.createMessageNode(this.chromeDocument,
+                                              category,
+                                              severity,
+                                              aScriptError.errorMessage,
+                                              this.hudId,
+                                              aScriptError.sourceName,
+                                              aScriptError.lineNumber,
+                                              null,
+                                              null,
+                                              aScriptError.timeStamp);
+
+    ConsoleUtils.outputMessageNode(node, this.hudId);
+  },
+
   ERRORS: {
     HUD_BOX_DOES_NOT_EXIST: "Heads Up Display does not exist",
     TAB_ID_REQUIRED: "Tab DOM ID is required",
     PARENTNODE_NOT_FOUND: "parentNode element not found"
   },
 
   /**
    * Setup the message manager used to communicate with the Web Console content
@@ -4091,18 +4069,18 @@ HeadsUpDisplay.prototype = {
     this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.addMessageListener(aName, this);
     }, this);
 
     let message = {
       hudId: this.hudId,
-      features: ["ConsoleAPI", "JSTerm"],
-      cachedMessages: ["ConsoleAPI"],
+      features: ["ConsoleAPI", "JSTerm", "PageError"],
+      cachedMessages: ["ConsoleAPI", "PageError"],
     };
     this.sendMessageToContent("WebConsole:Init", message);
   },
 
   /**
    * Handler for all of the messages coming from the Web Console content script.
    *
    * @private
@@ -4119,18 +4097,21 @@ HeadsUpDisplay.prototype = {
 
     switch (aMessage.name) {
       case "JSTerm:EvalObject":
         this._receiveMessageWithCallback(aMessage.json);
         break;
       case "WebConsole:ConsoleAPI":
         this.logConsoleAPIMessage(aMessage.json);
         break;
+      case "WebConsole:PageError":
+        this.reportPageError(aMessage.json.pageError);
+        break;
       case "WebConsole:CachedMessages":
-        this.displayCachedConsoleMessages(aMessage.json.messages);
+        this._displayCachedConsoleMessages(aMessage.json.messages);
         this._onInitComplete();
         break;
     }
   },
 
   /**
    * Callback method for when the Web Console initialization is complete. For
    * now this method sends the web-console-created notification using the
@@ -4272,43 +4253,16 @@ HeadsUpDisplay.prototype = {
     this.positionMenuitems.window.removeEventListener("command",
       this._positionConsoleWindow, false);
 
     this.closeButton.removeEventListener("command",
       this.closeButtonOnCommand, false);
   },
 };
 
-
-//////////////////////////////////////////////////////////////////////////////
-// ConsoleAPIObserver
-//////////////////////////////////////////////////////////////////////////////
-
-let ConsoleAPIObserver = {
-
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-
-  init: function CAO_init()
-  {
-    Services.obs.addObserver(this, "quit-application-granted", false);
-  },
-
-  observe: function CAO_observe(aMessage, aTopic, aData)
-  {
-    if (aTopic == "quit-application-granted") {
-      HUDService.shutdown();
-    }
-  },
-
-  shutdown: function CAO_shutdown()
-  {
-    Services.obs.removeObserver(this, "quit-application-granted");
-  }
-};
-
 /**
  * Creates a DOM Node factory for XUL nodes - as well as textNodes
  * @param aFactoryType "xul" or "text"
  * @param ignored This parameter is currently ignored, and will be removed
  * See bug 594304
  * @param aDocument The document, the factory is to generate nodes from
  * @return DOM Node Factory function
  */
@@ -4848,16 +4802,17 @@ function JSTerm(aContext, aParentNode, a
   this.setTimeout = aParentNode.ownerDocument.defaultView.setTimeout;
 
   let node = aParentNode;
   while (!node.hasAttribute("id")) {
     node = node.parentNode;
   }
   this.hudId = node.getAttribute("id");
 
+  this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
   this.log = LogFactory("*** JSTerm:");
   this.autocompletePopup = new AutocompletePopup(aParentNode.ownerDocument);
   this.autocompletePopup.onSelect = this.onAutocompleteSelect.bind(this);
   this.autocompletePopup.onClick = this.acceptProposedCompletion.bind(this);
   this.init();
 }
@@ -5469,17 +5424,17 @@ JSTerm.prototype = {
       return false;
     }
 
     let multiline = /[\r\n]/.test(node.value);
     return node.selectionStart == node.value.length ? true :
            node.selectionStart == 0 && !multiline;
   },
 
-  history: [],
+  history: null,
 
   // Stores the data for the last completion.
   lastCompletion: null,
 
   /**
    * Completes the current typed text in the inputNode. Completion is performed
    * only if the selection/cursor is at the end of the string. If no completion
    * is found, the current inputNode value and cursor/selection stay.
@@ -6480,41 +6435,38 @@ ConsoleEntry.prototype = {
   }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HUDWindowObserver
 //////////////////////////////////////////////////////////////////////////
 
 HUDWindowObserver = {
-  QueryInterface: XPCOMUtils.generateQI(
-    [Ci.nsIObserver,]
-  ),
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   init: function HWO_init()
   {
-    Services.obs.addObserver(this, "xpcom-shutdown", false);
     Services.obs.addObserver(this, "content-document-global-created", false);
+    Services.obs.addObserver(this, "quit-application-granted", false);
   },
 
   observe: function HWO_observe(aSubject, aTopic, aData)
   {
     if (aTopic == "content-document-global-created") {
       HUDService.windowInitializer(aSubject);
     }
-    else if (aTopic == "xpcom-shutdown") {
-      this.uninit();
+    else if (aTopic == "quit-application-granted") {
+      HUDService.shutdown();
     }
   },
 
   uninit: function HWO_uninit()
   {
     Services.obs.removeObserver(this, "content-document-global-created");
-    Services.obs.removeObserver(this, "xpcom-shutdown");
-    this.initialConsoleCreated = false;
+    Services.obs.removeObserver(this, "quit-application-granted");
   },
 
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -6599,54 +6551,16 @@ CommandController.prototype = {
         break;
       case "cmd_selectAll":
         this.selectAll(outputNode);
         break;
     }
   }
 };
 
-///////////////////////////////////////////////////////////////////////////////
-// HUDConsoleObserver
-///////////////////////////////////////////////////////////////////////////////
-
-/**
- * HUDConsoleObserver: Observes nsIConsoleService for global consoleMessages,
- * if a message originates inside a contentWindow we are tracking,
- * then route that message to the HUDService for logging.
- */
-
-HUDConsoleObserver = {
-  QueryInterface: XPCOMUtils.generateQI(
-    [Ci.nsIObserver]
-  ),
-
-  init: function HCO_init()
-  {
-    Services.console.registerListener(this);
-    Services.obs.addObserver(this, "quit-application-granted", false);
-  },
-
-  uninit: function HCO_uninit()
-  {
-    Services.console.unregisterListener(this);
-    Services.obs.removeObserver(this, "quit-application-granted");
-  },
-
-  observe: function HCO_observe(aSubject, aTopic, aData)
-  {
-    if (aTopic == "quit-application-granted") {
-      this.uninit();
-    }
-    else if (aSubject instanceof Ci.nsIScriptError) {
-      HUDService.reportPageError(aSubject);
-    }
-  }
-};
-
 /**
  * A WebProgressListener that listens for location changes, to update HUDService
  * state information on page navigation.
  *
  * @constructor
  * @param string aHudId
  *        The HeadsUpDisplay ID.
  */
diff --git a/browser/devtools/webconsole/test/browser_cached_messages.js b/browser/devtools/webconsole/test/browser_cached_messages.js
--- a/browser/devtools/webconsole/test/browser_cached_messages.js
+++ b/browser/devtools/webconsole/test/browser_cached_messages.js
@@ -51,17 +51,17 @@ function test()
   }, true);
 }
 
 function testOpenUI(aTestReopen)
 {
   // test to see if the messages are
   // displayed when the console UI is opened
 
-  openConsole(function(hud) {
+  openConsole(null, function(hud) {
     testLogEntry(hud.outputNode, "log Bazzle",
                  "Find a console log entry from before console UI is opened",
                  false, null);
 
     testLogEntry(hud.outputNode, "error Bazzle",
                  "Find a console error entry from before console UI is opened",
                  false, null);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580030_errors_after_page_reload.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580030_errors_after_page_reload.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580030_errors_after_page_reload.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580030_errors_after_page_reload.js
@@ -46,43 +46,36 @@ function test() {
   expectUncaughtException();
   addTab(TEST_URI);
   browser.addEventListener("load", onLoad, true);
 }
 
 // see bug 580030: the error handler fails silently after page reload.
 // https://bugzilla.mozilla.org/show_bug.cgi?id=580030
 function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, onLoad, true);
 
-  openConsole();
-
-  browser.addEventListener("load", testErrorsAfterPageReload, true);
-  executeSoon(function() {
+  openConsole(null, function(hud) {
+    hud.jsterm.clearOutput();
+    browser.addEventListener("load", testErrorsAfterPageReload, true);
     content.location.reload();
   });
 }
 
 function testErrorsAfterPageReload(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, testErrorsAfterPageReload, true);
 
   // dispatch a click event to the button in the test page and listen for
   // errors.
 
   Services.console.registerListener(consoleObserver);
 
-  var button = content.document.querySelector("button").wrappedJSObject;
-  var clickEvent = content.document.createEvent("MouseEvents");
-  clickEvent.initMouseEvent("click", true, true,
-    content, 0, 0, 0, 0, 0, false, false,
-    false, false, 0, null);
-
-  executeSoon(function() {
-    button.dispatchEvent(clickEvent);
-  });
+  let button = content.document.querySelector("button").wrappedJSObject;
+  ok(button, "button found");
+  EventUtils.sendMouseEvent({type: "click"}, button, content);
 }
 
 var consoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   observe: function test_observe(aMessage)
   {
     // Ignore errors we don't care about.
@@ -90,16 +83,20 @@ var consoleObserver = {
       aMessage.category != "content javascript") {
       return;
     }
 
     Services.console.unregisterListener(this);
 
     let outputNode = HUDService.getHudByWindow(content).outputNode;
 
-    executeSoon(function() {
-      let msg = "Found the error message after page reload";
-      testLogEntry(outputNode, "fooBazBaz", msg);
-      finishTest();
+    waitForSuccess({
+      name: "error message after page reload",
+      validatorFn: function()
+      {
+        return outputNode.textContent.indexOf("fooBazBaz") > -1;
+      },
+      successFn: finishTest,
+      failureFn: finishTest,
     });
   }
 };
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js b/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
@@ -47,17 +47,17 @@ function test() {
   expectUncaughtException();
   addTab(TEST_DUPLICATE_ERROR_URI);
   browser.addEventListener("DOMContentLoaded", testDuplicateErrors, false);
 }
 
 function testDuplicateErrors() {
   browser.removeEventListener("DOMContentLoaded", testDuplicateErrors,
                               false);
-  openConsole(function(hud) {
+  openConsole(null, function(hud) {
     hud.jsterm.clearOutput();
 
     Services.console.registerListener(consoleObserver);
 
     expectUncaughtException();
     content.location.reload();
   });
 }
@@ -72,23 +72,32 @@ var consoleObserver = {
       aMessage.category != "content javascript") {
       return;
     }
 
     Services.console.unregisterListener(this);
 
     outputNode = HUDService.getHudByWindow(content).outputNode;
 
-    executeSoon(function () {
-      var text = outputNode.textContent;
-      var error1pos = text.indexOf("fooDuplicateError1");
-      ok(error1pos > -1, "found fooDuplicateError1");
-      if (error1pos > -1) {
-        ok(text.indexOf("fooDuplicateError1", error1pos + 1) == -1,
-          "no duplicate for fooDuplicateError1");
-      }
+    waitForSuccess({
+      name: "fooDuplicateError1 error displayed",
+      validatorFn: function()
+      {
+        return outputNode.textContent.indexOf("fooDuplicateError1") > -1;
+      },
+      successFn: function()
+      {
+        let text = outputNode.textContent;
+        let error1pos = text.indexOf("fooDuplicateError1");
+        ok(error1pos > -1, "found fooDuplicateError1");
+        if (error1pos > -1) {
+          ok(text.indexOf("fooDuplicateError1", error1pos + 1) == -1,
+            "no duplicate for fooDuplicateError1");
+        }
 
-      findLogEntry("test-duplicate-error.html");
+        findLogEntry("test-duplicate-error.html");
 
-      finishTest();
+        finishTest();
+      },
+      failureFn: finishTest,
     });
   }
 };
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
@@ -14,17 +14,17 @@
 
 const TEST_URI = "data:text/html;charset=utf8,test for bug 585237";
 let hud, testDriver;
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       hud = aHud;
       testDriver = testGen();
       testNext();
     });
   }, true);
 }
 
 function testNext() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
@@ -41,17 +41,17 @@ const TEST_URI = "http://example.com/bro
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
 
 function tabLoaded() {
   browser.removeEventListener("load", tabLoaded, true);
 
-  openConsole(function() {
+  openConsole(null, function() {
     browser.addEventListener("load", tabReloaded, true);
     content.location.reload();
   });
 }
 
 function tabReloaded() {
   browser.removeEventListener("load", tabReloaded, true);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
@@ -9,17 +9,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(HUD) {
   // See bugs 574036, 586386 and 587617.
   outputNode = HUD.outputNode;
   let selection = getSelection();
   let jstermInput = HUD.jsterm.inputNode;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
@@ -41,17 +41,17 @@
 // Tests that adding text to one of the output labels doesn't cause errors.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(testTextNodeInsertion);
+    openConsole(null, testTextNodeInsertion);
   }, true);
 }
 
 // Test for bug 588730: Adding a text node to an existing label element causes
 // warnings
 function testTextNodeInsertion(hud) {
   let outputNode = hud.outputNode;
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js b/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_593003_iframe_wrong_hud.js
@@ -45,68 +45,51 @@ const TEST_DUMMY_URI = "http://example.c
 let tab1, tab2;
 
 function test() {
   addTab(TEST_URI);
   tab1 = tab;
   browser.addEventListener("load", tab1Loaded, true);
 }
 
-/**
- * Check if a log entry exists in the HUD output node.
- *
- * @param {Element} aOutputNode the HUD output node.
- * @param {string} aMatchString the string you want to check if it exists in the
- * output node.
- * @param {boolean} [aOnlyVisible=false] find only messages that are visible,
- * not hidden by the filter.
- * @param {boolean} [aFailIfFound=false] fail the test if the string is found in
- * the output node.
- */
-
 function tab1Loaded(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-  browser.contentWindow.wrappedJSObject.console.log("FOO");
-  try {
-    openConsole();
-  }
-  catch (ex) {
-    log(ex);
-    log(ex.stack);
-  }
-
-  tab2 = gBrowser.addTab(TEST_DUMMY_URI);
-  gBrowser.selectedTab = tab2;
-  gBrowser.selectedBrowser.addEventListener("load", tab2Loaded, true);
+  browser.removeEventListener(aEvent.type, tab1Loaded, true);
+  content.console.log("FOO");
+  openConsole(null, function() {
+    tab2 = gBrowser.addTab(TEST_DUMMY_URI);
+    gBrowser.selectedTab = tab2;
+    gBrowser.selectedBrowser.addEventListener("load", tab2Loaded, true);
+  });
 }
 
 function tab2Loaded(aEvent) {
-  tab2.linkedBrowser.removeEventListener(aEvent.type, arguments.callee, true);
+  tab2.linkedBrowser.removeEventListener(aEvent.type, tab2Loaded, true);
 
-  HUDService.activateHUDForContext(gBrowser.selectedTab);
-
-  tab1.linkedBrowser.addEventListener("load", tab1Reloaded, true);
-  tab1.linkedBrowser.contentWindow.location.reload();
+  openConsole(gBrowser.selectedTab, function() {
+    tab1.linkedBrowser.addEventListener("load", tab1Reloaded, true);
+    tab1.linkedBrowser.contentWindow.location.reload();
+  });
 }
 
 function tab1Reloaded(aEvent) {
-  tab1.linkedBrowser.removeEventListener(aEvent.type, arguments.callee, true);
+  tab1.linkedBrowser.removeEventListener(aEvent.type, tab1Reloaded, true);
 
   let hud1 = HUDService.getHudByWindow(tab1.linkedBrowser.contentWindow);
   let outputNode1 = hud1.outputNode;
 
   let msg = "Found the iframe network request in tab1";
   testLogEntry(outputNode1, TEST_IFRAME_URI, msg, true);
 
   let hud2 = HUDService.getHudByWindow(tab2.linkedBrowser.contentWindow);
   let outputNode2 = hud2.outputNode;
 
   isnot(outputNode1, outputNode2,
         "the two HUD outputNodes must be different");
 
   msg = "Didn't find the iframe network request in tab2";
   testLogEntry(outputNode2, TEST_IFRAME_URI, msg, true, true);
 
-  HUDService.deactivateHUDForContext(tab2);
-  gBrowser.removeTab(tab2);
-
-  finishTest();
+  closeConsole(tab2, function() {
+    gBrowser.removeTab(tab2);
+    tab1 = tab2 = null;
+    executeSoon(finishTest);
+  });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
@@ -23,64 +23,87 @@ function test() {
   addTabs(win1);
 
   // Open a new window.
   win2 = OpenBrowserWindow();
   win2.addEventListener("load", onWindowLoad, true);
 }
 
 function onWindowLoad(aEvent) {
-  win2.removeEventListener(aEvent.type, arguments.callee, true);
+  win2.removeEventListener(aEvent.type, onWindowLoad, true);
 
   // Add two tabs in the new window.
   addTabs(win2);
 }
 
 function addTabs(aWindow) {
   for (let i = 0; i < 2; i++) {
     let tab = aWindow.gBrowser.addTab(TEST_URI);
     openTabs.push(tab);
 
-    tab.linkedBrowser.addEventListener("load", function(aEvent) {
-      tab.linkedBrowser.removeEventListener(aEvent.type, arguments.callee,
-        true);
+    tab.linkedBrowser.addEventListener("load", function onLoad(aEvent) {
+      tab.linkedBrowser.removeEventListener(aEvent.type, onLoad, true);
 
       loadedTabCount++;
       if (loadedTabCount >= 4) {
-        executeSoon(performTest);
+        executeSoon(openConsoles);
       }
     }, true);
   }
 }
 
-function performTest() {
+function openConsoles() {
   // open the Web Console for each of the four tabs and log a message.
+  let consolesOpen = 0;
   for (let i = 0; i < openTabs.length; i++) {
     let tab = openTabs[i];
-    HUDService.activateHUDForContext(tab);
-    let hudId = HUDService.getHudIdByWindow(tab.linkedBrowser.contentWindow);
-    ok(hudId, "HUD is open for tab " + i);
-    let HUD = HUDService.hudReferences[hudId];
-    HUD.console.log("message for tab " + i);
+    openConsole(tab, function(index, hud) {
+      ok(hud, "HUD is open for tab " + index);
+      hud.console.log("message for tab " + index);
+      consolesOpen++;
+    }.bind(null, i));
   }
 
-  let displays = Object.keys(HUDService.hudReferences);
-  is(displays.length, 4, "four displays found");
+  waitForSuccess({
+    name: "4 web consoles opened",
+    validatorFn: function()
+    {
+      return consolesOpen == 4;
+    },
+    successFn: closeConsoles,
+    failureFn: closeConsoles,
+  });
+}
+
+function closeConsoles() {
+  let consolesClosed = 0;
+
+  function onWebConsoleClose(aSubject, aTopic) {
+    if (aTopic == "web-console-destroyed") {
+      consolesClosed++;
+    }
+  }
+
+  Services.obs.addObserver(onWebConsoleClose, "web-console-destroyed", false);
 
   win2.close();
 
-  executeSoon(function() {
-    win1.gBrowser.removeTab(openTabs[0]);
-    win1.gBrowser.removeTab(openTabs[1]);
+  win1.gBrowser.removeTab(openTabs[0]);
+  win1.gBrowser.removeTab(openTabs[1]);
 
-    executeSoon(function() {
-      displays = Object.keys(HUDService.hudReferences);
-      is(displays.length, 0, "no displays found");
-      ok(!HUDService.storage, "no storage found");
-      ok(!HUDService.httpObserver, "no httpObserver found");
+  openTabs = win1 = win2 = null;
 
-      displays = openTabs = win1 = win2 = null;
+  function onTimeout() {
+    Services.obs.removeObserver(onWebConsoleClose, "web-console-destroyed");
+    executeSoon(finishTest);
+  }
 
-      finishTest();
-    });
+  waitForSuccess({
+    name: "4 web consoles closed",
+    validatorFn: function()
+    {
+      return consolesClosed == 4;
+    },
+    successFn: onTimeout,
+    failureFn: onTimeout,
   });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595934_message_categories.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595934_message_categories.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595934_message_categories.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595934_message_categories.js
@@ -84,116 +84,119 @@ const TESTS = [
     category: "CSS Parser",
     matchString: "foobarCanvasCssParser",
   },
   { // #14
     file: "test-bug-595934-image.html",
     category: "Image",
     matchString: "corrupt",
   },
-  /* Disabled until bug 675221 lands.
-  { // #7
+  { // #15
     file: "test-bug-595934-workers.html",
     category: "Web Worker",
     matchString: "fooBarWorker",
-  },*/
+    expectError: true,
+  },
 ];
 
 let pos = -1;
 
 let foundCategory = false;
 let foundText = false;
 let output = null;
 let jsterm = null;
+let testEnded = false;
 
 let TestObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   observe: function test_observe(aSubject)
   {
-    if (!(aSubject instanceof Ci.nsIScriptError)) {
+    if (testEnded || !(aSubject instanceof Ci.nsIScriptError)) {
       return;
     }
 
     is(aSubject.category, TESTS[pos].category,
       "test #" + pos + ": error category '" + TESTS[pos].category + "'");
 
     if (aSubject.category == TESTS[pos].category) {
       foundCategory = true;
       if (foundText) {
         executeSoon(testNext);
       }
     }
     else {
       ok(false, aSubject.sourceName + ':' + aSubject.lineNumber + '; ' +
                 aSubject.errorMessage);
-      executeSoon(finish);
+      testEnded = true;
+      executeSoon(finishTest);
     }
   }
 };
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+function consoleOpened(hud) {
   output = hud.outputNode;
   output.addEventListener("DOMNodeInserted", onDOMNodeInserted, false);
   jsterm = hud.jsterm;
 
   Services.console.registerListener(TestObserver);
 
+  registerCleanupFunction(testEnd);
+
   executeSoon(testNext);
 }
 
 function testNext() {
   jsterm.clearOutput();
   foundCategory = false;
   foundText = false;
 
   pos++;
   if (pos < TESTS.length) {
     let test = TESTS[pos];
     let testLocation = TESTS_PATH + test.file;
     if (test.onload) {
-      browser.addEventListener("load", function(aEvent) {
+      browser.addEventListener("load", function onLoad(aEvent) {
         if (content.location.href == testLocation) {
-          browser.removeEventListener(aEvent.type, arguments.callee, true);
+          browser.removeEventListener(aEvent.type, onLoad, true);
           test.onload(aEvent);
         }
       }, true);
     }
 
+    if (test.expectError) {
+      expectUncaughtException();
+    }
+
     content.location = testLocation;
   }
   else {
-    executeSoon(finish);
+    testEnded = true;
+    executeSoon(finishTest);
   }
 }
 
 function testEnd() {
   Services.console.unregisterListener(TestObserver);
   output.removeEventListener("DOMNodeInserted", onDOMNodeInserted, false);
-  output = jsterm = null;
-  finishTest();
+  TestObserver = output = jsterm = null;
 }
 
 function onDOMNodeInserted(aEvent) {
   let textContent = output.textContent;
   foundText = textContent.indexOf(TESTS[pos].matchString) > -1;
   if (foundText) {
     ok(foundText, "test #" + pos + ": message found '" + TESTS[pos].matchString + "'");
   }
 
   if (foundCategory) {
     executeSoon(testNext);
   }
 }
 
 function test() {
-  registerCleanupFunction(testEnd);
-
   addTab("data:text/html;charset=utf-8,Web Console test for bug 595934 - message categories coverage.");
-  browser.addEventListener("load", tabLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597136_external_script_errors.js
@@ -16,30 +16,24 @@ function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
 
 function tabLoaded(aEvent) {
   browser.removeEventListener("load", tabLoaded, true);
   openConsole();
 
-  browser.addEventListener("load", contentLoaded, true);
-  content.location.reload();
-}
+  let button = content.document.querySelector("button");
+  let outputNode = HUDService.getHudByWindow(content).outputNode;
 
-function contentLoaded(aEvent) {
-  browser.removeEventListener("load", contentLoaded, true);
-
-  let button = content.document.querySelector("button");
   expectUncaughtException();
   EventUtils.sendMouseEvent({ type: "click" }, button, content);
-  executeSoon(buttonClicked);
+
+  waitForSuccess({
+    name: "external script error message",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf("bogus is not defined") > -1;
+    },
+    successFn: finishTest,
+    failureFn: finishTest,
+  });
 }
-
-function buttonClicked() {
-  let outputNode = HUDService.getHudByWindow(content).outputNode;
-
-  let msg = "the error from the external script was logged";
-  testLogEntry(outputNode, "bogus", msg);
-
-  finishTest();
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
@@ -8,55 +8,53 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-597756-reopen-closed-tab.html";
 
 let newTabIsOpen = false;
 
 function tabLoaded(aEvent) {
-  gBrowser.selectedBrowser.removeEventListener(aEvent.type, arguments.callee, true);
+  gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabLoaded, true);
 
-  HUDService.activateHUDForContext(gBrowser.selectedTab);
-
-  gBrowser.selectedBrowser.addEventListener("load", tabReloaded, true);
-  expectUncaughtException();
-  content.location.reload();
+  openConsole(gBrowser.selectedTab, function() {
+    gBrowser.selectedBrowser.addEventListener("load", tabReloaded, true);
+    expectUncaughtException();
+    content.location.reload();
+  });
 }
 
 function tabReloaded(aEvent) {
-  gBrowser.selectedBrowser.removeEventListener(aEvent.type, arguments.callee, true);
+  gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabReloaded, true);
 
   let hudId = HUDService.getHudIdByWindow(content);
   let HUD = HUDService.hudReferences[hudId];
   ok(HUD, "Web Console is open");
 
   isnot(HUD.outputNode.textContent.indexOf("fooBug597756_error"), -1,
     "error message must be in console output");
 
   executeSoon(function() {
     if (newTabIsOpen) {
-      testEnd();
+      executeSoon(finishTest);
       return;
     }
 
-    let newTab = gBrowser.addTab();
-    gBrowser.removeCurrentTab();
-    gBrowser.selectedTab = newTab;
+    closeConsole(gBrowser.selectedTab, function() {
+      gBrowser.removeCurrentTab();
 
-    newTabIsOpen = true;
-    gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
-    expectUncaughtException();
-    content.location = TEST_URI;
+      let newTab = gBrowser.addTab();
+      gBrowser.selectedTab = newTab;
+
+      newTabIsOpen = true;
+      gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+      expectUncaughtException();
+      content.location = TEST_URI;
+    });
   });
 }
 
-function testEnd() {
-  gBrowser.removeCurrentTab();
-  executeSoon(finishTest);
-}
-
 function test() {
   expectUncaughtException();
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoaded, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
@@ -93,17 +93,17 @@ let eventHandlers = [];
 let popupShown = [];
 let HUD;
 let testDriver;
 
 function tabLoad(aEvent) {
   browser.removeEventListener(aEvent.type, tabLoad, true);
 
   waitForFocus(function () {
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       HUD = aHud;
       testNext();
     });
   }, content);
 }
 
 function subtestNext() {
   testDriver.next();
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
@@ -61,12 +61,12 @@ function consoleOpened(HUD) {
     failureFn: finishTest,
   });
 }
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 601352");
   browser.addEventListener("load", function tabLoad(aEvent) {
     browser.removeEventListener(aEvent.type, tabLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -11,31 +11,30 @@
 let menuitems = [], menupopups = [], huds = [], tabs = [];
 
 function test()
 {
   // open tab 1
   addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 1");
   tabs.push(tab);
 
-  browser.addEventListener("load", function(aEvent) {
-    browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.addEventListener("load", function onLoad1(aEvent) {
+    browser.removeEventListener(aEvent.type, onLoad1, true);
 
-    openConsole();
+    openConsole(null, function() {
+      // open tab 2
+      addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 2");
+      tabs.push(tab);
 
-    // open tab 2
-    addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 2");
-    tabs.push(tab);
+      browser.addEventListener("load", function onLoad2(aEvent) {
+        browser.removeEventListener(aEvent.type, onLoad2, true);
 
-    browser.addEventListener("load", function(aEvent) {
-      browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-      openConsole();
-      executeSoon(startTest);
-    }, true);
+        openConsole(null, startTest);
+      }, true);
+    });
   }, true);
 }
 
 function startTest()
 {
   // Find the relevant elements in the Web Console of tab 2.
   let win2 = tabs[1].linkedBrowser.contentWindow;
   let hudId2 = HUDService.getHudIdByWindow(win2);
@@ -47,44 +46,44 @@ function startTest()
 
   // Open the context menu from tab 2.
   menupopups[1].addEventListener("popupshown", onpopupshown2, false);
   menupopups[1].openPopup(huds[1].outputNode, "overlap", 10, 10, true, false);
 }
 
 function onpopupshown2(aEvent)
 {
-  menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].removeEventListener(aEvent.type, onpopupshown2, false);
 
   // By default bodies are not logged.
   isnot(menuitems[1].getAttribute("checked"), "true",
         "menuitems[1] is not checked");
 
   ok(!HUDService.saveRequestAndResponseBodies, "bodies are not logged");
 
   // Enable body logging.
   HUDService.saveRequestAndResponseBodies = true;
 
-  menupopups[1].addEventListener("popuphidden", function(aEvent) {
-    menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].addEventListener("popuphidden", function _onhidden(aEvent) {
+    menupopups[1].removeEventListener(aEvent.type, _onhidden, false);
 
     // Reopen the context menu.
     menupopups[1].addEventListener("popupshown", onpopupshown2b, false);
     menupopups[1].openPopup(huds[1].outputNode, "overlap", 11, 11, true, false);
   }, false);
   menupopups[1].hidePopup();
 }
 
 function onpopupshown2b(aEvent)
 {
-  menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].removeEventListener(aEvent.type, onpopupshown2b, false);
   is(menuitems[1].getAttribute("checked"), "true", "menuitems[1] is checked");
 
-  menupopups[1].addEventListener("popuphidden", function(aEvent) {
-    menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].addEventListener("popuphidden", function _onhidden(aEvent) {
+    menupopups[1].removeEventListener(aEvent.type, _onhidden, false);
 
     // Switch to tab 1 and open the Web Console context menu from there.
     gBrowser.selectedTab = tabs[0];
     waitForFocus(function() {
       // Find the relevant elements in the Web Console of tab 1.
       let win1 = tabs[0].linkedBrowser.contentWindow;
       let hudId1 = HUDService.getHudIdByWindow(win1);
       huds[0] = HUDService.hudReferences[hudId1];
@@ -97,48 +96,49 @@ function onpopupshown2b(aEvent)
       menupopups[0].openPopup(huds[0].outputNode, "overlap", 12, 12, true, false);
     }, tabs[0].linkedBrowser.contentWindow);
   }, false);
   menupopups[1].hidePopup();
 }
 
 function onpopupshown1(aEvent)
 {
-  menupopups[0].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[0].removeEventListener(aEvent.type, onpopupshown1, false);
 
   // The menuitem checkbox must be in sync with the other tabs.
   is(menuitems[0].getAttribute("checked"), "true", "menuitems[0] is checked");
 
   // Disable body logging.
   HUDService.saveRequestAndResponseBodies = false;
 
   // Close the menu, and switch back to tab 2.
-  menupopups[0].addEventListener("popuphidden", function(aEvent) {
-    menupopups[0].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[0].addEventListener("popuphidden", function _onhidden(aEvent) {
+    menupopups[0].removeEventListener(aEvent.type, _onhidden, false);
 
     gBrowser.selectedTab = tabs[1];
     waitForFocus(function() {
       // Reopen the context menu from tab 2.
       menupopups[1].addEventListener("popupshown", onpopupshown2c, false);
       menupopups[1].openPopup(huds[1].outputNode, "overlap", 13, 13, true, false);
     }, tabs[1].linkedBrowser.contentWindow);
   }, false);
   menupopups[0].hidePopup();
 }
 
 function onpopupshown2c(aEvent)
 {
-  menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].removeEventListener(aEvent.type, onpopupshown2c, false);
 
   isnot(menuitems[1].getAttribute("checked"), "true",
         "menuitems[1] is not checked");
 
-  menupopups[1].addEventListener("popuphidden", function(aEvent) {
-    menupopups[1].removeEventListener(aEvent.type, arguments.callee, false);
+  menupopups[1].addEventListener("popuphidden", function _onhidden(aEvent) {
+    menupopups[1].removeEventListener(aEvent.type, _onhidden, false);
 
     // Done!
     huds = menuitems = menupopups = tabs = null;
-    HUDService.deactivateHUDForContext(gBrowser.selectedTab);
-    gBrowser.removeCurrentTab();
-    executeSoon(finishTest);
+    closeConsole(gBrowser.selectedTab, function() {
+      gBrowser.removeCurrentTab();
+      executeSoon(finishTest);
+    });
   }, false);
   menupopups[1].hidePopup();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js b/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
@@ -34,38 +34,43 @@ let TestObserver = {
     }
     else {
       lastWindowId = aSubject.outerWindowID;
     }
   }
 };
 
 function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tabLoad, true);
 
   openConsole();
 
   let hudId = HUDService.getHudIdByWindow(content);
   hud = HUDService.hudReferences[hudId];
 
   Services.console.registerListener(TestObserver);
 
   content.location = TEST_URI;
 }
 
 function performTest() {
-  let textContent = hud.outputNode.textContent;
-  isnot(textContent.indexOf("ws://0.0.0.0:81"), -1,
-        "first error message found");
-  isnot(textContent.indexOf("ws://0.0.0.0:82"), -1,
-        "second error message found");
-
   Services.console.unregisterListener(TestObserver);
   Services.prefs.setBoolPref(pref_ws, oldPref_ws);
-  finishTest();
+
+  waitForSuccess({
+    name: "websocket error messages displayed",
+    validatorFn: function()
+    {
+      let textContent = hud.outputNode.textContent;
+      return textContent.indexOf("ws://0.0.0.0:81") > -1 &&
+             textContent.indexOf("ws://0.0.0.0:82") > -1;
+    },
+    successFn: finishTest,
+    failureFn: finishTest,
+  });
 }
 
 function test() {
   oldPref_ws = Services.prefs.getBoolPref(pref_ws);
 
   Services.prefs.setBoolPref(pref_ws, true);
 
   addTab("data:text/html;charset=utf-8,Web Console test for bug 603750: Web Socket errors");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js b/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
@@ -2,27 +2,49 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = 'data:text/html;charset=utf-8,<div style="-moz-opacity:0;">test repeated' +
                  ' css warnings</div><p style="-moz-opacity:0">hi</p>';
 
 function onContentLoaded()
 {
-  browser.removeEventListener("load", arguments.callee, true);
+  browser.removeEventListener("load", onContentLoaded, true);
 
   let HUD = HUDService.getHudByWindow(content);
   let jsterm = HUD.jsterm;
   let outputNode = HUD.outputNode;
 
-  let msg = "The unknown CSS property warning is displayed only once";
-  let node = outputNode.firstChild;
+  let cssWarning = "Unknown property '-moz-opacity'.  Declaration dropped.";
 
-  is(node.childNodes[2].textContent, "Unknown property '-moz-opacity'.  Declaration dropped.", "correct node")
-  is(node.childNodes[3].firstChild.getAttribute("value"), 2, msg);
+  waitForSuccess({
+    name: "2 repeated CSS warnings",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf(cssWarning) > -1;
+    },
+    successFn: function()
+    {
+      let msg = "The unknown CSS property warning is displayed only once";
+      let node = outputNode.firstChild;
+
+      is(node.childNodes[2].textContent, cssWarning, "correct node");
+      is(node.childNodes[3].firstChild.getAttribute("value"), 2, msg);
+
+      testConsoleLogRepeats();
+    },
+    failureFn: finishTest,
+  });
+}
+
+function testConsoleLogRepeats()
+{
+  let HUD = HUDService.getHudByWindow(content);
+  let jsterm = HUD.jsterm;
+  let outputNode = HUD.outputNode;
 
   jsterm.clearOutput();
 
   jsterm.setInputValue("for (let i = 0; i < 10; ++i) console.log('this is a line of reasonably long text that I will use to verify that the repeated text node is of an appropriate size.');");
   jsterm.execute();
 
   waitForSuccess({
     name: "10 repeated console.log messages",
@@ -40,16 +62,16 @@ function onContentLoaded()
  * Unit test for bug 611795:
  * Repeated CSS messages get collapsed into one.
  */
 function test()
 {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       // Clear cached messages that are shown once the Web Console opens.
       aHud.jsterm.clearOutput(true);
       browser.addEventListener("load", onContentLoaded, true);
       content.location.reload();
     });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
@@ -90,15 +90,15 @@ function testGen() {
   
   yield;
 }
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 613642: remember scroll location");
   browser.addEventListener("load", function tabLoad(aEvent) {
     browser.removeEventListener(aEvent.type, tabLoad, true);
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       hud = aHud;
       testDriver = testGen();
       testDriver.next();
     });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
@@ -87,15 +87,15 @@ function testGen() {
   yield;
 }
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 613642: maintain scroll with pruning of old messages");
   browser.addEventListener("load", function tabLoad(aEvent) {
     browser.removeEventListener(aEvent.type, tabLoad, true);
 
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       hud = aHud;
       testDriver = testGen();
       testDriver.next();
     });
   }, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
@@ -42,12 +42,12 @@ function consoleOpened(hud) {
     failureFn: finishTest,
   });
 }
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 614793: jsterm result scroll");
   browser.addEventListener("load", function onLoad(aEvent) {
     browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
@@ -48,63 +48,56 @@ let TestObserver = {
   observe: function test_observe(aSubject)
   {
     if (testEnded || !(aSubject instanceof Ci.nsIScriptError)) {
       return;
     }
 
     is(aSubject.category, "content javascript", "error category");
 
+    testEnded = true;
     if (aSubject.category == "content javascript") {
       executeSoon(checkOutput);
     }
     else {
-      testEnd();
+      executeSoon(finishTest);
     }
   }
 };
 
 function checkOutput()
 {
-  if (testEnded) {
-    return;
-  }
-
-  let textContent = hud.outputNode.textContent;
-  isnot(textContent.indexOf("bug618078exception"), -1,
-        "exception message");
-
-  testEnd();
+  waitForSuccess({
+    name: "exception message",
+    validatorFn: function()
+    {
+      return hud.outputNode.textContent.indexOf("bug618078exception") > -1;
+    },
+    successFn: finishTest,
+    failureFn: finishTest,
+  });
 }
 
 function testEnd()
 {
-  if (testEnded) {
-    return;
-  }
-
-  testEnded = true;
   Services.console.unregisterListener(TestObserver);
-  finishTest();
 }
 
 function test()
 {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 618078");
 
-  browser.addEventListener("load", function() {
-    browser.removeEventListener("load", arguments.callee, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
-    openConsole();
+    openConsole(null, function(aHud) {
+      hud = aHud;
+      Services.console.registerListener(TestObserver);
+      registerCleanupFunction(testEnd);
 
-    let hudId = HUDService.getHudIdByWindow(content);
-    hud = HUDService.hudReferences[hudId];
-
-    Services.console.registerListener(TestObserver);
-    registerCleanupFunction(testEnd);
-
-    executeSoon(function() {
-      expectUncaughtException();
-      content.location = TEST_URI;
+      executeSoon(function() {
+        expectUncaughtException();
+        content.location = TEST_URI;
+      });
     });
   }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_private_browsing.js
@@ -39,32 +39,33 @@
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let pb = Cc["@mozilla.org/privatebrowsing;1"].
          getService(Ci.nsIPrivateBrowsingService);
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 618311 (private browsing)");
 
-  browser.addEventListener("load", function() {
-    browser.removeEventListener("load", arguments.callee, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
 
     registerCleanupFunction(function() {
       pb.privateBrowsingEnabled = false;
       pb = null;
     });
 
     ok(!pb.privateBrowsingEnabled, "private browsing is not enabled");
 
     togglePBAndThen(function() {
       ok(pb.privateBrowsingEnabled, "private browsing is enabled");
 
-      HUDService.activateHUDForContext(gBrowser.selectedTab);
-      content.location = TEST_URI;
-      gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+      openConsole(gBrowser.selectedTab, function() {
+        content.location = TEST_URI;
+        gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
+      });
     });
   }, true);
 }
 
 function tabLoaded() {
   gBrowser.selectedBrowser.removeEventListener("load", tabLoaded, true);
 
   let hudId = HUDService.getHudIdByWindow(content);
@@ -123,16 +124,17 @@ function tabLoaded() {
       document.removeEventListener("popuphidden", onpopuphidden, false);
 
       executeSoon(function() {
         let popups = popupset.querySelectorAll("panel[hudId=" + hudId + "]");
         is(popups.length, 0, "no popups found");
 
         ok(!pb.privateBrowsingEnabled, "private browsing is not enabled");
 
+        gBrowser.removeCurrentTab();
         executeSoon(finishTest);
       });
     }
   };
 
   document.addEventListener("popupshown", onpopupshown, false);
 
   registerCleanupFunction(function() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
@@ -5,24 +5,19 @@
  *
  * Contributor(s):
  *   Mihai Sucan <mihai.sucan@gmail.com>
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-621644-jsterm-dollar.html";
 
 function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tabLoad, true);
 
-  waitForFocus(function () {
-    openConsole();
-
-    let hudId = HUDService.getHudIdByWindow(content);
-    let HUD = HUDService.hudReferences[hudId];
-
+  openConsole(null, function(HUD) {
     HUD.jsterm.clearOutput();
 
     HUD.jsterm.setInputValue("$(document.body)");
     HUD.jsterm.execute();
 
     let outputItem = HUD.outputNode.
                      querySelector(".webconsole-msg-output:last-child");
     ok(outputItem.textContent.indexOf("<p>") > -1,
@@ -34,15 +29,15 @@ function tabLoad(aEvent) {
     HUD.jsterm.execute();
 
     outputItem = HUD.outputNode.
                      querySelector(".webconsole-msg-output:last-child");
     ok(outputItem.textContent.indexOf("621644") > -1,
        "jsterm output is correct for $$()");
 
     executeSoon(finishTest);
-  }, content);
+  });
 }
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", tabLoad, true);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js b/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_626484_output_copy_order.js
@@ -1,17 +1,17 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
-let itemsSet, HUD;
+let itemsSet, HUD, outputNode;
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 626484");
   browser.addEventListener("load", function tabLoaded(aEvent) {
     browser.removeEventListener(aEvent.type, tabLoaded, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 
 function consoleOpened(aHud) {
   HUD = aHud;
   outputNode = HUD.outputNode;
   HUD.jsterm.clearOutput();
@@ -25,26 +25,26 @@ function consoleOpened(aHud) {
 
   waitForSuccess({
     name: "console.log messages displayed",
     validatorFn: function()
     {
       return outputNode.querySelectorAll(".hud-log").length == 3;
     },
     successFn: nextTest,
-    failureFn: finish,
+    failureFn: finishTest,
   });
 }
 
 function nextTest() {
   if (itemsSet.length === 0) {
     outputNode.clearSelection();
     HUD.jsterm.clearOutput();
-    HUD = null;
-    finish();
+    HUD = outputNode = null;
+    executeSoon(finishTest);
   }
   else {
     outputNode.clearSelection();
     let items = itemsSet.shift();
     items.forEach(function (index) {
       outputNode.addItemToSelection(outputNode.getItemAtIndex(index));
     });
     outputNode.focus();
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
@@ -5,48 +5,56 @@
  */
 
 // Tests that the Web Console limits the number of lines displayed according to
 // the limit set for each category.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/" +
                  "webconsole/test/test-bug-644419-log-limits.html";
 
-var gOldPref, gHudId;
+var gOldPref;
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 644419: Console should " +
          "have user-settable log limits for each message category");
   browser.addEventListener("load", onLoad, true);
 }
 
 function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, onLoad, true);
 
-  openConsole(function(aHud) {
-    gHudId = aHud.hudId;
+  openConsole(null, function(aHud) {
     aHud.jsterm.clearOutput();
+    hud = aHud;
+    outputNode = aHud.outputNode;
 
     browser.addEventListener("load", testWebDevLimits, true);
     expectUncaughtException();
     content.location = TEST_URI;
   });
 }
 
 function testWebDevLimits(aEvent) {
   browser.removeEventListener(aEvent.type, testWebDevLimits, true);
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.console");
   Services.prefs.setIntPref("devtools.hud.loglimit.console", 10);
 
-  let hud = HUDService.hudReferences[gHudId];
-  outputNode = hud.outputNode;
+  // Find the sentinel entry.
+  waitForSuccess({
+    name: "bar is not defined",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf("bar is not defined") > -1;
+    },
+    successFn: testWebDevLimits2,
+    failureFn: testWebDevLimits2,
+  });
+}
 
-  // Find the sentinel entry.
-  findLogEntry("bar is not defined");
-
+function testWebDevLimits2() {
   // Fill the log with Web Developer errors.
   for (let i = 0; i < 11; i++) {
     hud.console.log("test message " + i);
   }
 
   waitForSuccess({
     name: "11 console.log messages displayed",
     validatorFn: function()
@@ -66,19 +74,17 @@ function testWebDevLimits(aEvent) {
     failureFn: testJsLimits,
   });
 }
 
 function testJsLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.exception");
   Services.prefs.setIntPref("devtools.hud.loglimit.exception", 10);
 
-  let hud = HUDService.hudReferences[gHudId];
   hud.jsterm.clearOutput();
-  outputNode = hud.outputNode;
   hud.console.log("testing JS limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing JS limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing JS limits") > -1;
@@ -93,36 +99,43 @@ function testJsLimits2() {
   let head = content.document.getElementsByTagName("head")[0];
   for (let i = 0; i < 11; i++) {
     var script = content.document.createElement("script");
     script.text = "fubar" + i + ".bogus(6);";
     expectUncaughtException();
     head.insertBefore(script, head.firstChild);
   }
 
-  executeSoon(function() {
-    testLogEntry(outputNode, "fubar0 is not defined", "first message is pruned", false, true);
-    findLogEntry("fubar1 is not defined");
-    // Check if the sentinel entry is still there.
-    findLogEntry("testing JS limits");
+  waitForSuccess({
+    name: "10 JS errors shown",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf("fubar10 is not defined") > -1;
+    },
+    successFn: function()
+    {
+      testLogEntry(outputNode, "fubar0 is not defined", "first message is pruned", false, true);
+      findLogEntry("fubar1 is not defined");
+      // Check if the sentinel entry is still there.
+      findLogEntry("testing JS limits");
 
-    Services.prefs.setIntPref("devtools.hud.loglimit.exception", gOldPref);
-    testNetLimits();
+      Services.prefs.setIntPref("devtools.hud.loglimit.exception", gOldPref);
+      testNetLimits();
+    },
+    failureFn: testNetLimits,
   });
 }
 
 var gCounter, gImage;
 
 function testNetLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.network");
   Services.prefs.setIntPref("devtools.hud.loglimit.network", 10);
 
-  let hud = HUDService.hudReferences[gHudId];
   hud.jsterm.clearOutput();
-  outputNode = hud.outputNode;
   hud.console.log("testing Net limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing Net limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing Net limits") > -1;
@@ -157,19 +170,17 @@ function loadImage() {
   Services.prefs.setIntPref("devtools.hud.loglimit.network", gOldPref);
   testCssLimits();
 }
 
 function testCssLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.cssparser");
   Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", 10);
 
-  let hud = HUDService.hudReferences[gHudId];
   hud.jsterm.clearOutput();
-  outputNode = hud.outputNode;
   hud.console.log("testing CSS limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing CSS limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing CSS limits") > -1;
@@ -182,18 +193,29 @@ function testCssLimits() {
 function testCssLimits2() {
   // Fill the log with CSS errors.
   let body = content.document.getElementsByTagName("body")[0];
   for (let i = 0; i < 11; i++) {
     var div = content.document.createElement("div");
     div.setAttribute("style", "-moz-foobar" + i + ": 42;");
     body.insertBefore(div, body.firstChild);
   }
-  executeSoon(function() {
-    testLogEntry(outputNode, "Unknown property '-moz-foobar0'", "first message is pruned", false, true);
-    findLogEntry("Unknown property '-moz-foobar1'");
-    // Check if the sentinel entry is still there.
-    findLogEntry("testing CSS limits");
 
-    Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", gOldPref);
-    finishTest();
+  waitForSuccess({
+    name: "10 CSS errors shown",
+    validatorFn: function()
+    {
+      return outputNode.textContent.indexOf("-moz-foobar10") > -1;
+    },
+    successFn: function()
+    {
+      testLogEntry(outputNode, "Unknown property '-moz-foobar0'",
+                   "first message is pruned", false, true);
+      findLogEntry("Unknown property '-moz-foobar1'");
+      // Check if the sentinel entry is still there.
+      findLogEntry("testing CSS limits");
+
+      Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", gOldPref);
+      finishTest();
+    },
+    failureFn: finishTest,
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_653531_highlighter_console_helper.js
@@ -92,27 +92,29 @@ function runSelectionTests()
     InspectorUI.INSPECTOR_NOTIFICATIONS.OPENED, false);
 
   executeSoon(function() {
     InspectorUI.highlighter.addListener("nodeselected", performTestComparisons);
     EventUtils.synthesizeMouse(h1, 2, 2, {type: "mousemove"}, content);
   });
 }
 
-function performTestComparisons(evt)
+function performTestComparisons()
 {
   InspectorUI.highlighter.removeListener("nodeselected", performTestComparisons);
 
   InspectorUI.stopInspecting();
   is(InspectorUI.highlighter.node, h1, "node selected");
   is(InspectorUI.selection, h1, "selection matches node");
 
-  HUDService.activateHUDForContext(gBrowser.selectedTab);
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+  openConsole(gBrowser.selectedTab, performWebConsoleTests);
+}
+
+function performWebConsoleTests(hud)
+{
   let jsterm = hud.jsterm;
   outputNode = hud.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("$0");
   findLogEntry("[object HTMLHeadingElement");
 
   jsterm.clearOutput();
@@ -122,18 +124,17 @@ function performTestComparisons(evt)
   is(InspectorUI.selection.textContent, msg, "node successfully updated");
 
   doc = h1 = null;
   executeSoon(finishUp);
 }
 
 function finishUp() {
   InspectorUI.closeInspectorUI();
-  gBrowser.removeCurrentTab();
-  finish();
+  finishTest();
 }
 
 function test()
 {
   waitForExplicitFinish();
   gBrowser.selectedTab = gBrowser.addTab();
   gBrowser.selectedBrowser.addEventListener("load", function() {
     gBrowser.selectedBrowser.removeEventListener("load", arguments.callee, true);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
@@ -4,84 +4,85 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that the Console API implements the time() and timeEnd() methods.
 
 function test() {
   addTab("http://example.com/browser/browser/devtools/webconsole/" +
          "test/test-bug-658368-time-methods.html");
-  openConsole();
-  browser.addEventListener("load", onLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
-function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, onLoad, true);
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+function consoleOpened(hud) {
   outputNode = hud.outputNode;
 
   executeSoon(function() {
     findLogEntry("aTimer: timer started");
     findLogEntry("ms");
 
     // The next test makes sure that timers with the same name but in separate
     // tabs, do not contain the same value.
     addTab("data:text/html;charset=utf-8,<script type='text/javascript'>" +
            "console.timeEnd('bTimer');</script>");
-    openConsole();
-    browser.addEventListener("load", testTimerIndependenceInTabs, true);
+    browser.addEventListener("load", function onLoad() {
+      browser.removeEventListener("load", onLoad, true);
+      openConsole(null, testTimerIndependenceInTabs);
+    }, true);
   });
 }
 
-function testTimerIndependenceInTabs(aEvent) {
-  browser.removeEventListener(aEvent.type, testTimerIndependenceInTabs, true);
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hud = HUDService.hudReferences[hudId];
+function testTimerIndependenceInTabs(hud) {
   outputNode = hud.outputNode;
 
   executeSoon(function() {
     testLogEntry(outputNode, "bTimer: timer started", "bTimer was not started",
                  false, true);
 
     // The next test makes sure that timers with the same name but in separate
     // pages, do not contain the same value.
-    browser.addEventListener("load", testTimerIndependenceInSameTab, true);
+    browser.addEventListener("load", function onLoad() {
+      browser.removeEventListener("load", onLoad, true);
+      executeSoon(testTimerIndependenceInSameTab);
+    }, true);
     content.location = "data:text/html;charset=utf-8,<script type='text/javascript'>" +
            "console.time('bTimer');</script>";
   });
 }
 
-function testTimerIndependenceInSameTab(aEvent) {
-  browser.removeEventListener(aEvent.type, testTimerIndependenceInSameTab, true);
-
+function testTimerIndependenceInSameTab() {
   let hudId = HUDService.getHudIdByWindow(content);
   let hud = HUDService.hudReferences[hudId];
   outputNode = hud.outputNode;
 
   executeSoon(function() {
     findLogEntry("bTimer: timer started");
     hud.jsterm.clearOutput();
 
     // Now the following console.timeEnd() call shouldn't display anything,
     // if the timers in different pages are not related.
-    browser.addEventListener("load", testTimerIndependenceInSameTabAgain, true);
+    browser.addEventListener("load", function onLoad() {
+      browser.removeEventListener("load", onLoad, true);
+      executeSoon(testTimerIndependenceInSameTabAgain);
+    }, true);
     content.location = "data:text/html;charset=utf-8,<script type='text/javascript'>" +
            "console.timeEnd('bTimer');</script>";
   });
 }
 
-function testTimerIndependenceInSameTabAgain(aEvent) {
-  browser.removeEventListener(aEvent.type, testTimerIndependenceInSameTabAgain, true);
-
+function testTimerIndependenceInSameTabAgain(hud) {
   let hudId = HUDService.getHudIdByWindow(content);
   let hud = HUDService.hudReferences[hudId];
   outputNode = hud.outputNode;
 
   executeSoon(function() {
     testLogEntry(outputNode, "bTimer: timer started", "bTimer was not started",
                  false, true);
 
-    finishTest();
+    closeConsole(gBrowser.selectedTab, function() {
+      gBrowser.removeCurrentTab();
+      executeSoon(finishTest);
+    });
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
@@ -6,17 +6,17 @@
 
 // Tests that console.dir works as intended.
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 659907: Expand console " +
          "object with a dir method");
   browser.addEventListener("load", function onLoad(aEvent) {
     browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(hud) {
   outputNode = hud.outputNode;
   content.console.dir(content.document);
   waitForSuccess({
     name: "console.dir displayed",
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
@@ -9,17 +9,17 @@ const GROUP_INDENT = 12;
 
 let testDriver, hud;
 
 function test() {
   addTab("data:text/html;charset=utf-8,Web Console test for bug 664131: Expand console " +
          "object with group methods");
   browser.addEventListener("load", function onLoad(aEvent) {
     browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(function(aHud) {
+    openConsole(null, function(aHud) {
       hud = aHud;
       testDriver = testGen();
       testNext();
     });
   }, true);
 }
 
 function testNext() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -37,36 +37,36 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that code completion works properly.
 
 function test() {
   addTab(getBrowserURL());
-  browser.addEventListener("DOMContentLoaded", testChrome, false);
+  browser.addEventListener("DOMContentLoaded", function onLoad() {
+    browser.removeEventListener("DOMContentLoaded", onLoad, true);
+    openConsole();
+    testChrome(HUDService.getHudByWindow(content));
+  }, true);
 }
 
-function testChrome() {
-  browser.removeEventListener("DOMContentLoaded", testChrome, false);
-
-  openConsole();
-
-  let hud = HUDService.getHudByWindow(content);
+function testChrome(hud) {
   ok(hud, "we have a console");
   
   ok(hud.HUDBox, "we have the console display");
 
   let jsterm = hud.jsterm;
   ok(jsterm, "we have a jsterm");
 
   let input = jsterm.inputNode;
   ok(hud.outputNode, "we have an output node");
 
   // Test typing 'docu'.
   input.value = "docu";
   input.setSelectionRange(4, 4);
   jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
 
-  finish();
+  gBrowser.removeCurrentTab();
+  executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_extras.js b/browser/devtools/webconsole/test/browser_webconsole_console_extras.js
--- a/browser/devtools/webconsole/test/browser_webconsole_console_extras.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_extras.js
@@ -38,17 +38,17 @@
 // Tests that the basic console.log()-style APIs and filtering work.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-extras.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(hud) {
   waitForSuccess({
     name: "two nodes displayed",
     validatorFn: function()
     {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
--- a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
@@ -49,17 +49,17 @@ function test() {
   addTab(TEST_URI);
 
   browser.addEventListener("DOMContentLoaded", onLoad, false);
 }
 
 function onLoad() {
   browser.removeEventListener("DOMContentLoaded", onLoad, false);
 
-  openConsole(function(aHud) {
+  openConsole(null, function(aHud) {
     hud = aHud;
     hudId = hud.hudId;
     outputNode = hud.outputNode;
     testDriver = testGen();
     testDriver.next();
   });
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js b/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
--- a/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js
@@ -15,17 +15,17 @@ const TEST_URI = "data:text/html;charset
 function test()
 {
   addTab(TEST_URI);
   browser.addEventListener("DOMContentLoaded", onLoad, false);
 }
 
 function onLoad() {
   browser.removeEventListener("DOMContentLoaded", onLoad, false);
-  openConsole(testNewlines);
+  openConsole(null, testNewlines);
 }
 
 function testNewlines(aHud) {
   hud = aHud;
   hud.jsterm.clearOutput();
 
   for (let i = 0; i < 20; i++) {
     content.console.log("Hello world #" + i);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
--- a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
@@ -39,37 +39,32 @@
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that commands run by the user are executed in content space.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testExecutionScope, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testExecutionScope);
+  }, true);
 }
 
-function testExecutionScope() {
-  browser.removeEventListener("DOMContentLoaded", testExecutionScope,
-                              false);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testExecutionScope(hud) {
+  let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("location;");
 
   let nodes = jsterm.outputNode.querySelectorAll(".hud-msg-node");
   is(nodes.length, 2, "Two children in output");
 
   is(/location;/.test(nodes[0].textContent), true,
      "'location;' written to output");
 
   ok(nodes[0].textContent.indexOf(TEST_URI),
     "command was executed in the window scope");
 
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-
-  finishTest();
+  executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_history.js b/browser/devtools/webconsole/test/browser_webconsole_history.js
--- a/browser/devtools/webconsole/test/browser_webconsole_history.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_history.js
@@ -43,25 +43,24 @@
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 // Constants used for defining the direction of JSTerm input history navigation.
 const HISTORY_BACK = -1;
 const HISTORY_FORWARD = 1;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testHistory, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testHistory);
+  }, true);
 }
 
-function testHistory() {
-  browser.removeEventListener("DOMContentLoaded", testHistory, false);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testHistory(hud) {
+  let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   let executeList = ["document", "window", "window.location"];
 
   for each (var item in executeList) {
     input.value = item;
     jsterm.execute();
   }
@@ -72,17 +71,16 @@ function testHistory() {
   }
 
   jsterm.historyPeruse(HISTORY_BACK);
   is (input.value, executeList[0], "test that item is still index 0");
 
   jsterm.historyPeruse(HISTORY_BACK);
   is (input.value, executeList[0], "test that item is still still index 0");
 
-
   for (var i = 1; i < executeList.length; i++) {
     jsterm.historyPeruse(HISTORY_FORWARD);
     is (input.value, executeList[i], "check history next idx:" + i);
   }
 
   jsterm.historyPeruse(HISTORY_FORWARD);
   is (input.value, "", "check input is empty again");
 
@@ -93,14 +91,11 @@ function testHistory() {
   jsterm.historyPeruse(HISTORY_FORWARD);
 
   is (input.value, "", "check input is still empty");
 
   let idxLast = executeList.length - 1;
   jsterm.historyPeruse(HISTORY_BACK);
   is (input.value, executeList[idxLast], "check history next idx:" + idxLast);
 
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-
-  finishTest();
+  executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
--- a/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_jsterm.js
@@ -40,33 +40,32 @@
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let jsterm;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testJSTerm, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testJSTerm);
+  }, true);
 }
 
 function checkResult(msg, desc, lines) {
   let labels = jsterm.outputNode.querySelectorAll(".webconsole-msg-output");
   is(labels.length, lines, "correct number of results shown for " + desc);
   is(labels[lines-1].textContent.trim(), msg, "correct message shown for " +
     desc);
 }
 
-function testJSTerm()
+function testJSTerm(hud)
 {
-  browser.removeEventListener("DOMContentLoaded", testJSTerm, false);
-
-  openConsole();
-
-  jsterm = HUDService.getHudByWindow(content).jsterm;
+  jsterm = hud.jsterm;
 
   jsterm.clearOutput();
   jsterm.execute("'id=' + $('header').getAttribute('id')");
   checkResult('"id=header"', "$() worked", 1);
 
   jsterm.clearOutput();
   jsterm.execute("headerQuery = $$('h1')");
   jsterm.execute("'length=' + headerQuery.length");
@@ -150,10 +149,10 @@ function testJSTerm()
         "pprint(function) shows function source");
 
   // check that an evaluated null produces "null", bug 650780
   jsterm.clearOutput();
   jsterm.execute("null");
   checkResult("null", "null is null", 1);
 
   jsterm = null;
-  finishTest();
+  executeSoon(finishTest);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
@@ -41,17 +41,17 @@
 // Tests that the message type filter checkboxes work.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(aHud) {
   hud = aHud;
   hud.jsterm.clearOutput();
 
   let console = content.console;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
@@ -43,17 +43,17 @@
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let hud;
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(aHud) {
   hud = aHud;
   hud.jsterm.clearOutput();
   let console = content.console;
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_log_node_classes.js b/browser/devtools/webconsole/test/browser_webconsole_log_node_classes.js
--- a/browser/devtools/webconsole/test/browser_webconsole_log_node_classes.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_log_node_classes.js
@@ -42,17 +42,17 @@
 // CSS classes.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(consoleOpened);
+    openConsole(null, consoleOpened);
   }, true);
 }
 
 function consoleOpened(aHud) {
   let console = content.console;
   outputNode = aHud.outputNode;
 
   ok(console, "console exists");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
--- a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
@@ -39,17 +39,17 @@ const TEST_URI = "http://example.com/bro
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("DOMContentLoaded", onLoad, false);
 }
 
 function onLoad() {
   browser.removeEventListener("DOMContentLoaded", onLoad, false);
-  openConsole(function(hud) {
+  openConsole(null, function(hud) {
     content.console.log("a log message");
 
     waitForSuccess({
       name: "console.log message shown with an ID attribute",
       validatorFn: function()
       {
         let node = hud.outputNode.querySelector(".hud-msg-node");
         return node && node.getAttribute("id");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
@@ -44,24 +44,23 @@
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 const TEST_IMG = "http://example.com/browser/browser/devtools/webconsole/test/test-image.png";
 const TEST_ENCODING_ISO_8859_1 = "http://example.com/browser/browser/devtools/webconsole/test/test-encoding-ISO-8859-1.html";
 
 let testDriver;
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testNetworkPanel, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testNetworkPanel);
+  }, true);
 }
 
 function testNetworkPanel() {
-  browser.removeEventListener("DOMContentLoaded", testNetworkPanel,
-                              false);
-  openConsole();
-
   testDriver = testGen();
   testDriver.next();
 }
 
 function checkIsVisible(aPanel, aList) {
   for (let id in aList) {
     let node = aPanel.document.getElementById(id);
     let isVisible = aList[id];
@@ -95,21 +94,20 @@ function checkNodeKeyValue(aPanel, aId, 
   }
 
   ok(false, "content check failed for " + aId + ", key " + aKey);
 }
 
 function testGen() {
   let filterBox = HUDService.getHudByWindow(content).filterBox;
 
-  XPCOMUtils.defineLazyGetter(this, "l10n", function () {
-    let obj = {};
-    Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
-    return obj.WebConsoleUtils.l10n;
-  });
+  let tempScope  = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", tempScope);
+  let l10n = tempScope.WebConsoleUtils.l10n;
+  tempScope = null;
 
   var httpActivity = {
     url: "http://www.testpage.com",
     method: "GET",
 
     panels: [],
     request: {
       header: {
@@ -484,10 +482,11 @@ function testGen() {
   if (networkPanel.document.getElementById("responseBodyUnknownTypeContent").textContent !== "")
     checkNodeContent(networkPanel, "responseBodyUnknownTypeContent", responseString);
   else
     ok(true, "Flash not installed");
 
   networkPanel.panel.hidePopup(); */
 
   // All done!
-  finish();
+  testDriver = null;
+  executeSoon(finishTest);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js b/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_null_and_undefined_output.js
@@ -40,41 +40,35 @@
 
 // Test that JavaScript expressions that evaluate to null or undefined produce
 // meaningful output.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testNullAndUndefinedOutput,
-                           false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testNullAndUndefinedOutput);
+  }, true);
 }
 
-function testNullAndUndefinedOutput() {
-  browser.removeEventListener("DOMContentLoaded",
-                              testNullAndUndefinedOutput, false);
-
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testNullAndUndefinedOutput(hud) {
+  let jsterm = hud.jsterm;
   let outputNode = jsterm.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("null;");
 
   let nodes = outputNode.querySelectorAll(".hud-msg-node");
   is(nodes.length, 2, "2 nodes in output");
   ok(nodes[1].textContent.indexOf("null") > -1, "'null' printed to output");
 
   jsterm.clearOutput();
   jsterm.execute("undefined;");
 
   nodes = outputNode.querySelectorAll(".hud-msg-node");
   is(nodes.length, 2, "2 nodes in output");
   ok(nodes[1].textContent.indexOf("undefined") > -1, "'undefined' printed to output");
 
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-
-  finishTest();
+  executeSoon(finishTest);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_order.js b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
@@ -42,17 +42,17 @@
 // echoed JavaScript.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    openConsole(testOutputOrder);
+    openConsole(null, testOutputOrder);
   }, true);
 }
 
 function testOutputOrder(hud) {
   let jsterm = hud.jsterm;
   let outputNode = jsterm.outputNode;
 
   jsterm.clearOutput();
diff --git a/browser/devtools/webconsole/test/browser_webconsole_view_source.js b/browser/devtools/webconsole/test/browser_webconsole_view_source.js
--- a/browser/devtools/webconsole/test/browser_webconsole_view_source.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_view_source.js
@@ -2,61 +2,61 @@
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that source URLs in the Web Console can be clicked to display the
 // standard View Source window.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-error.html";
 
 function test() {
-  expectUncaughtException();
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testViewSource, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testViewSource);
+  }, true);
 }
 
-function testViewSource() {
-  browser.removeEventListener("DOMContentLoaded", testViewSource, false);
-
-  openConsole();
-
+function testViewSource(hud) {
   let button = content.document.querySelector("button");
   button = XPCNativeWrapper.unwrap(button);
   ok(button, "we have the button on the page");
 
-  button.addEventListener("click", buttonClicked, false);
+  expectUncaughtException();
   EventUtils.sendMouseEvent({ type: "click" }, button, content);
-}
 
-function buttonClicked(aEvent) {
-  aEvent.target.removeEventListener("click", buttonClicked, false);
-  executeSoon(findLocationNode);
+  waitForSuccess({
+    name: "find the location node",
+    validatorFn: function()
+    {
+      return hud.outputNode.querySelector(".webconsole-location");
+    },
+    successFn: function()
+    {
+      let locationNode = hud.outputNode.querySelector(".webconsole-location");
+
+      Services.ww.registerNotification(observer);
+
+      EventUtils.sendMouseEvent({ type: "click" }, locationNode);
+    },
+    failureFn: finishTest,
+  });
 }
 
 let observer = {
   observe: function(aSubject, aTopic, aData) {
     if (aTopic != "domwindowopened") {
       return;
     }
 
     ok(true, "the view source window was opened in response to clicking " +
        "the location node");
 
-    Services.ww.unregisterNotification(this);
-
     // executeSoon() is necessary to avoid crashing Firefox. See bug 611543.
     executeSoon(function() {
       aSubject.close();
       finishTest();
     });
   }
 };
 
-function findLocationNode() {
-  outputNode = HUDService.getHudByWindow(content).outputNode;
-
-  let locationNode = outputNode.querySelector(".webconsole-location");
-  ok(locationNode, "we have the location node");
-
-  Services.ww.registerNotification(observer);
-
-  EventUtils.sendMouseEvent({ type: "click" }, locationNode);
-}
-
+registerCleanupFunction(function() {
+  Services.ww.unregisterNotification(observer);
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_window_zombie.js b/browser/devtools/webconsole/test/browser_webconsole_window_zombie.js
--- a/browser/devtools/webconsole/test/browser_webconsole_window_zombie.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_window_zombie.js
@@ -3,42 +3,39 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>test for bug 577721";
 
 const POSITION_PREF = "devtools.webconsole.position";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", onLoad, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
   registerCleanupFunction(testEnd);
 }
 
 function testEnd() {
   Services.prefs.clearUserPref(POSITION_PREF);
 }
 
-function onLoad() {
-  browser.removeEventListener("DOMContentLoaded", onLoad, false);
-
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  let hudRef = HUDService.hudReferences[hudId];
+function consoleOpened(hudRef) {
   let hudBox = hudRef.HUDBox;
 
   // listen for the panel popupshown event.
   document.addEventListener("popupshown", function popupShown() {
     document.removeEventListener("popupshown", popupShown, false);
 
     ok(hudRef.consolePanel, "console is in a panel");
 
     document.addEventListener("popuphidden", function popupHidden() {
       document.removeEventListener("popuphidden", popupHidden, false);
-      finishTest();
+      executeSoon(finishTest);
     }, false);
 
     // Close the window console via the menu item
     let menu = document.getElementById("webConsole");
     menu.click();
   }, false);
 
   hudRef.positionConsole("window");
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -151,67 +151,86 @@ function testLogEntry(aOutputNode, aMatc
  *        The string to find.
  */
 function findLogEntry(aString)
 {
   testLogEntry(outputNode, aString, "found " + aString);
 }
 
 /**
- * Open the Web Console for the current tab.
+ * Open the Web Console for the given tab.
  *
+ * @param nsIDOMElement [aTab]
+ *        Optional tab element for which you want open the Web Console. The
+ *        default tab is taken from the global variable |tab|.
  * @param function [aCallback]
  *        Optional function to invoke after the Web Console completes
- *        initialization.
+ *        initialization (web-console-created).
  */
-function openConsole(aCallback)
+function openConsole(aTab, aCallback)
 {
   function onWebConsoleOpen(aSubject, aTopic)
   {
     if (aTopic == "web-console-created") {
       Services.obs.removeObserver(onWebConsoleOpen, "web-console-created");
       aSubject.QueryInterface(Ci.nsISupportsString);
       let hud = HUDService.getHudReferenceById(aSubject.data);
       executeSoon(aCallback.bind(null, hud));
     }
   }
 
   if (aCallback) {
     Services.obs.addObserver(onWebConsoleOpen, "web-console-created", false);
   }
 
-  HUDService.activateHUDForContext(tab);
+  HUDService.activateHUDForContext(aTab || tab);
 }
 
-function closeConsole()
+/**
+ * Close the Web Console for the given tab.
+ *
+ * @param nsIDOMElement [aTab]
+ *        Optional tab element for which you want close the Web Console. The
+ *        default tab is taken from the global variable |tab|.
+ * @param function [aCallback]
+ *        Optional function to invoke after the Web Console completes
+ *        closing (web-console-destroyed).
+ */
+function closeConsole(aTab, aCallback)
 {
-  HUDService.deactivateHUDForContext(tab);
+  function onWebConsoleClose(aSubject, aTopic)
+  {
+    if (aTopic == "web-console-destroyed") {
+      Services.obs.removeObserver(onWebConsoleClose, "web-console-destroyed");
+      aSubject.QueryInterface(Ci.nsISupportsString);
+      let hudId = aSubject.data;
+      executeSoon(aCallback.bind(null, hudId));
+    }
+  }
+
+  if (aCallback) {
+    Services.obs.addObserver(onWebConsoleClose, "web-console-destroyed", false);
+  }
+
+  HUDService.deactivateHUDForContext(aTab || tab);
 }
 
 function finishTest()
 {
   browser = hudId = hud = filterBox = outputNode = cs = null;
 
-  function onWebConsoleClose(aSubject, aTopic)
-  {
-    if (aTopic == "web-console-destroyed") {
-      Services.obs.removeObserver(onWebConsoleClose, "web-console-destroyed");
-      executeSoon(finish);
-    }
-  }
-
-  Services.obs.addObserver(onWebConsoleClose, "web-console-destroyed", false);
-
   let hud = HUDService.getHudByWindow(content);
   if (!hud) {
     finish();
     return;
   }
   hud.jsterm.clearOutput(true);
-  HUDService.deactivateHUDForContext(hud.tab);
+
+  closeConsole(hud.tab, finish);
+
   hud = null;
 }
 
 function tearDown()
 {
   HUDService.deactivateHUDForContext(gBrowser.selectedTab);
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
