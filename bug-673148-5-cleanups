# HG changeset patch
# Parent 97bb5d2f3b8d77c73e598b15831f20255ff16138
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1337626420 -10800

Bug 673148 - (async-webconsole) Part 5 - HUDService.jsm cleanup

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -256,16 +256,18 @@ let Manager = {
    * Supported features:
    *    - JSTerm - a JavaScript "terminal" which allows code execution.
    *    - ConsoleAPI - support for routing the window.console API to the remote
    *    process.
    *    - PageError - route all the nsIScriptErrors from the nsIConsoleService
    *    to the remote process.
    *    - NetworkMonitor - log all the network activity and send HAR-like
    *    messages to the remote Web Console process.
+   *    - LocationChange - log page location changes. See
+   *    ConsoleProgressListener.
    *
    * @param string aFeature
    *        One of the supported features.
    * @param object [aMessage]
    *        Optional JSON message object coming from the remote Web Console
    *        instance. This can be used for feature-specific options.
    */
   enableFeature: function Manager_enableFeature(aFeature, aMessage)
@@ -282,16 +284,21 @@ let Manager = {
         ConsoleAPIObserver.init(aMessage);
         break;
       case "PageError":
         ConsoleListener.init(aMessage);
         break;
       case "NetworkMonitor":
         NetworkMonitor.init(aMessage);
         break;
+      case "LocationChange":
+        ConsoleProgressListener.startMonitor(ConsoleProgressListener
+                                             .MONITOR_LOCATION_CHANGE);
+        ConsoleProgressListener.sendNewLocation();
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
 
     this._enabledFeatures.push(aFeature);
   },
 
@@ -319,16 +326,20 @@ let Manager = {
         ConsoleAPIObserver.destroy();
         break;
       case "PageError":
         ConsoleListener.destroy();
         break;
       case "NetworkMonitor":
         NetworkMonitor.destroy();
         break;
+      case "LocationChange":
+        ConsoleProgressListener.stopMonitor(ConsoleProgressListener
+                                            .MONITOR_LOCATION_CHANGE);
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
   },
 
   /**
    * Handle the "WebConsole:GetPreferences" messages from the remote Web Console
@@ -1647,20 +1658,18 @@ let NetworkMonitor = {
 
     activityDistributor.addObserver(this);
 
     Services.obs.addObserver(this.httpResponseExaminer,
                              "http-on-examine-response", false);
 
     // Monitor file:// activity as well.
     if (aMessage && aMessage.monitorFileActivity) {
-      let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
-      this.progressListener = new ConsoleProgressListener();
-      webProgress.addProgressListener(this.progressListener,
-        Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+      ConsoleProgressListener.startMonitor(ConsoleProgressListener
+                                           .MONITOR_FILE_ACTIVITY);
     }
   },
 
   /**
    * Observe notifications for the http-on-examine-response topic, coming from
    * the nsIObserverService.
    *
    * @param nsIHttpChannel aSubject
@@ -2197,45 +2206,127 @@ let NetworkMonitor = {
    */
   destroy: function NM_destroy()
   {
     Services.obs.removeObserver(this.httpResponseExaminer,
                                 "http-on-examine-response");
 
     activityDistributor.removeObserver(this);
 
-    if (this.progressListener) {
-      let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
-      webProgress.removeProgressListener(this.progressListener);
-      delete this.progressListener;
-    }
+    ConsoleProgressListener.stopMonitor(ConsoleProgressListener
+                                        .MONITOR_FILE_ACTIVITY);
 
     delete this.openRequests;
     delete this.openResponses;
   },
 };
 
 /**
- * A WebProgressListener that listens for location changes. This progress
- * listener is used to track file loads. When a file:// URI is loaded
- * a "WebConsole:FileActivity" message is sent to the remote Web Console
- * instance. The message JSON holds only one property: uri (the file URI).
+ * A WebProgressListener that listens for location changes.
  *
- * @constructor
+ * This progress listener is used to track file loads and other kinds of
+ * location changes.
+ *
+ * When a file:// URI is loaded a "WebConsole:FileActivity" message is sent to
+ * the remote Web Console instance. The message JSON holds only one property:
+ * uri (the file URI).
+ *
+ * When the current page location changes a "WebConsole:LocationChange" message
+ * is sent. The object holds two properties: location (full URL of the new
+ * document that loaded) and title (document title).
  */
-function ConsoleProgressListener() { }
+let ConsoleProgressListener = {
+  MONITOR_FILE_ACTIVITY: 1,
+  MONITOR_LOCATION_CHANGE: 2,
 
-ConsoleProgressListener.prototype = {
+  /**
+   * Tells if you want to monitor file activity.
+   * @private
+   * @type boolean
+   */
+  _fileActivity: false,
+
+  /**
+   * Tells if you want to monitor location changes.
+   * @private
+   * @type boolean
+   */
+  _locationChange: false,
+
+  _initialized: false,
+
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
                                          Ci.nsISupportsWeakReference]),
 
-  onStateChange: function CPL_onStateChange(aProgress, aRequest, aState,
-                                            aStatus)
+  _init: function CPL__init()
   {
-    if (!_alive || !(aState & Ci.nsIWebProgressListener.STATE_START)) {
+    if (this._initialized) {
+      return;
+    }
+
+    this._initialized = true;
+    let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.addProgressListener(this, Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+  },
+
+  startMonitor: function CPL_startMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = true;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = true;
+        break;
+      default:
+        throw new Error("HUDService-content: unknown monitor type " +
+                        aMonitor + " for the ConsoleProgressListener!");
+    }
+    this._init();
+  },
+
+  stopMonitor: function CPL_stopMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = false;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = false;
+        break;
+      default:
+        throw new Error("HUDService-content: unknown monitor type " +
+                        aMonitor + " for the ConsoleProgressListener!");
+    }
+
+    if (!this._fileActivity && !this._locationChange) {
+      this.destroy();
+    }
+  },
+
+  onStateChange:
+  function CPL_onStateChange(aProgress, aRequest, aState, aStatus)
+  {
+    if (!_alive) {
+      return;
+    }
+
+    if (this._fileActivity) {
+      this._checkFileActivity(aProgress, aRequest, aState, aStatus);
+    }
+
+    if (this._locationChange) {
+      this._checkLocationChange(aProgress, aRequest, aState, aStatus);
+    }
+  },
+
+  _checkFileActivity:
+  function CPL__checkFileActivity(aProgress, aRequest, aState, aStatus)
+  {
+    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
       return;
     }
 
     let uri = null;
     if (aRequest instanceof Ci.imgIRequest) {
       let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
       uri = imgIRequest.URI;
     }
@@ -2246,16 +2337,54 @@ ConsoleProgressListener.prototype = {
 
     if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
       return;
     }
 
     Manager.sendMessage("WebConsole:FileActivity", {uri: uri.spec});
   },
 
+  _checkLocationChange:
+  function CPL__checkLocationChange(aProgress, aRequest, aState, aStatus)
+  {
+    let isStop = aState & Ci.nsIWebProgressListener.STATE_STOP;
+    let isNetwork = aState & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
+    let isWindow = aState & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
+
+    // Skip non-interesting states.
+    if (!isStop || !isNetwork || !isWindow ||
+        aProgress.DOMWindow != Manager.window) {
+      return;
+    }
+
+    this.sendNewLocation();
+  },
+
   onLocationChange: function() {},
   onStatusChange: function() {},
   onProgressChange: function() {},
   onSecurityChange: function() {},
+
+  sendNewLocation: function CPL_sendNewLocation()
+  {
+    let message = {
+      "location": Manager.window.location.href,
+      "title": Manager.window.document.title,
+    };
+    Manager.sendMessage("WebConsole:LocationChange", message);
+  },
+
+  destroy: function CPL_destroy()
+  {
+    if (!this._initialized) {
+      return;
+    }
+
+    this._initialized = false;
+    this._fileActivity = false;
+    this._locationChange = false;
+    let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.removeProgressListener(this);
+  },
 };
 
 Manager.init();
 })();
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -14,48 +14,25 @@ Cu.import("resource://gre/modules/XPCOMU
 Cu.import("resource://gre/modules/Services.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
-XPCOMUtils.defineLazyGetter(this, "gcli", function () {
-  var obj = {};
-  Cu.import("resource:///modules/gcli.jsm", obj);
-  return obj.gcli;
-});
-
-XPCOMUtils.defineLazyGetter(this, "template", function () {
-  var obj = {};
-  Cu.import("resource:///modules/devtools/Templater.jsm", obj);
-  return obj.template;
-});
-
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
                                   "resource:///modules/AutocompletePopup.jsm");
 
-XPCOMUtils.defineLazyGetter(this, "ScratchpadManager", function () {
-  var obj = {};
-  try {
-    Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", obj);
-  }
-  catch (err) {
-    Cu.reportError(err);
-  }
-  return obj.ScratchpadManager;
-});
-
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkPanel",
                                   "resource:///modules/NetworkPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource:///modules/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "l10n", function() {
   return WebConsoleUtils.l10n;
@@ -295,46 +272,25 @@ function pruneConsoleOutputIfNecessary(a
   return logLimit;
 }
 
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
 function HUD_SERVICE()
 {
-  // TODO: provide mixins for FENNEC: bug 568621
-  if (appName() == "FIREFOX") {
-    var mixins = new FirefoxApplicationHooks();
-  }
-  else {
-    throw new Error("Unsupported Application");
-  }
-
-  this.mixins = mixins;
-
   // These methods access the "this" object, but they're registered as
   // event listeners. So we hammer in the "this" binding.
   this.onTabClose = this.onTabClose.bind(this);
   this.onWindowUnload = this.onWindowUnload.bind(this);
 
   // Remembers the last console height, in pixels.
   this.lastConsoleHeight = Services.prefs.getIntPref("devtools.hud.height");
 
   /**
-   * Collection of HUDIds that map to the tabs/windows/contexts
-   * that a HeadsUpDisplay can be activated for.
-   */
-  this.activatedContexts = [];
-
-  /**
-   * Collection of outer window IDs mapping to HUD IDs.
-   */
-  this.windowIds = {};
-
-  /**
    * Each HeadsUpDisplay has a set of filter preferences
    */
   this.filterPrefs = {};
 
   /**
    * Keeps a reference for each HeadsUpDisplay that is created
    */
   this.hudReferences = {};
@@ -353,158 +309,98 @@ HUD_SERVICE.prototype =
 
   /**
    * The sequencer is a generator (after initialization) that returns unique
    * integers
    */
   sequencer: null,
 
   /**
-   * Tell the HUDService that a HeadsUpDisplay can be activated
-   * for the window or context that has 'aContextDOMId' node id
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  registerActiveContext: function HS_registerActiveContext(aContextDOMId)
-  {
-    this.activatedContexts.push(aContextDOMId);
-  },
-
-  /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
-    return this.mixins.getCurrentContext();
-  },
-
-  /**
-   * Tell the HUDService that a HeadsUpDisplay should be deactivated
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  unregisterActiveContext: function HS_deregisterActiveContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    var idx = this.activatedContexts.indexOf(domId);
-    if (idx > -1) {
-      this.activatedContexts.splice(idx, 1);
-    }
-  },
-
-  /**
-   * Tells callers that a HeadsUpDisplay can be activated for the context
-   *
-   * @param string aContextDOMId
-   * @return boolean
-   */
-  canActivateContext: function HS_canActivateContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    for (var idx in this.activatedContexts) {
-      if (this.activatedContexts[idx] == domId){
-        return true;
-      }
-    }
-    return false;
+    return Services.wm.getMostRecentWindow("navigator:browser");
   },
 
   /**
    * Activate a HeadsUpDisplay for the given tab context.
    *
-   * @param Element aContext the tab element.
-   * @param boolean aAnimated animate opening the Web Console?
-   * @returns void
+   * @param nsIDOMElement aTab
+   *        The xul:tab element.
+   * @param boolean aAnimated
+   *        True if you want to animate the opening of the Web console.
+   * @return object
+   *         The new HeadsUpDisplay instance.
    */
-  activateHUDForContext: function HS_activateHUDForContext(aContext, aAnimated)
+  activateHUDForContext: function HS_activateHUDForContext(aTab, aAnimated)
   {
     this.wakeup();
 
-    let window = aContext.linkedBrowser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    this.registerActiveContext(nBox.id);
-    this.windowInitializer(window);
-
-    let hudId = "hud_" + nBox.id;
+    let hudId = "hud_" + aTab.linkedPanel;
     let hudRef = this.hudReferences[hudId];
-
-    if (!aAnimated || hudRef.consolePanel) {
+    let window = aTab.ownerDocument.defaultView;
+    let gBrowser = window.gBrowser;
+
+    // TODO: check that this works as intended
+    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
+    window.addEventListener("unload", this.onWindowUnload, false);
+
+    this.registerDisplay(hudId);
+
+    let hud = new HeadsUpDisplay(aTab);
+    this.hudReferences[hudId] = hud;
+
+    // FIXME: Need to detect that the console component has been paved over.
+    //let consoleObject = WebConsoleUtils.unwrap(aContentWindow).console;
+    //if (!("__mozillaConsole__" in consoleObject))
+    //  this.logWarningAboutReplacedAPI(hudId);
+
+    // register the controller to handle "select all" properly
+    this.createController(window);
+
+    if (!aAnimated || hud.consolePanel) {
       this.disableAnimation(hudId);
     }
 
-    // Create a processing instruction for GCLIs CSS stylesheet, but only if
-    // we don't have one for this document. Also record the context we're
-    // adding this for so we know when to remove it.
-    let procInstr = aContext.ownerDocument.gcliCssProcInstr;
-    if (!procInstr) {
-      procInstr = aContext.ownerDocument.createProcessingInstruction(
-              "xml-stylesheet",
-              "href='chrome://browser/skin/devtools/gcli.css' type='text/css'");
-      procInstr.contexts = [];
-
-      let root = aContext.ownerDocument.getElementsByTagName('window')[0];
-      root.parentNode.insertBefore(procInstr, root);
-      aContext.ownerDocument.gcliCssProcInstr = procInstr;
-    }
-    if (procInstr.contexts.indexOf(hudId) == -1) {
-      procInstr.contexts.push(hudId);
-    }
     HeadsUpDisplayUICommands.refreshCommand();
+
+    return hud;
   },
 
   /**
    * Deactivate a HeadsUpDisplay for the given tab context.
    *
-   * @param nsIDOMWindow aContext
-   * @param aAnimated animate closing the web console?
-   * @returns void
+   * @param nsIDOMElement aTab
+   *        The xul:tab element you want to enable the Web Console for.
+   * @param boolean aAnimated
+   *        True if you want to animate the closing of the Web console.
+   * @return void
    */
-  deactivateHUDForContext: function HS_deactivateHUDForContext(aContext, aAnimated)
+  deactivateHUDForContext: function HS_deactivateHUDForContext(aTab, aAnimated)
   {
-    let browser = aContext.linkedBrowser;
-    let window = browser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    let hudId = "hud_" + nBox.id;
-    let displayNode = chromeDocument.getElementById(hudId);
-    let hudFound = (hudId in this.hudReferences) && displayNode;
-
-    if (hudFound) {
-      if (!aAnimated) {
-        this.storeHeight(hudId);
-      }
-
-      this.unregisterDisplay(hudId);
-
-      window.focus();
-      HeadsUpDisplayUICommands.refreshCommand();
+    let hudId = "hud_" + aTab.linkedPanel;
+    if (!(hudId in this.hudReferences)) {
+      return;
     }
 
-    // Remove this context from the list of contexts that need the GCLI CSS
-    // processing instruction and then remove the processing instruction if it
-    // isn't needed any more.
-    let procInstr = aContext.ownerDocument.gcliCssProcInstr;
-    if (procInstr) {
-      procInstr.contexts = procInstr.contexts.filter(function(id) {
-        return id !== hudId;
-      });
-      if (procInstr.contexts.length == 0 && procInstr.parentNode) {
-        procInstr.parentNode.removeChild(procInstr);
-        delete aContext.ownerDocument.gcliCssProcInstr;
-      }
+    if (!aAnimated) {
+      this.storeHeight(hudId);
     }
 
-    if (hudFound) {
-      let id = WebConsoleUtils.supportsString(hudId);
-      Services.obs.notifyObservers(id, "web-console-destroyed", null);
-    }
+    this.unregisterDisplay(hudId);
+
+    let contentWindow = aTab.linkedBrowser.contentWindow;
+    contentWindow.focus();
+
+    HeadsUpDisplayUICommands.refreshCommand();
+
+    let id = WebConsoleUtils.supportsString(hudId);
+    Services.obs.notifyObservers(id, "web-console-destroyed", null);
   },
 
   /**
    * get a unique ID from the sequence generator
    *
    * @returns integer
    */
   sequenceId: function HS_sequencerId()
@@ -693,25 +589,16 @@ HUD_SERVICE.prototype =
         node.classList.add("hud-filtered-by-string");
       }
     }
 
     this.regroupOutput(outputNode);
   },
 
   /**
-   * Register a reference of each HeadsUpDisplay that is created
-   */
-  registerHUDReference:
-  function HS_registerHUDReference(aHUD)
-  {
-    this.hudReferences[aHUD.hudId] = aHUD;
-  },
-
-  /**
    * Register a new Heads Up Display
    *
    * @returns void
    */
   registerDisplay: function HS_registerDisplay(aHUDId)
   {
     // register a display DOM node Id with the service.
     if (!aHUDId){
@@ -740,19 +627,16 @@ HUD_SERVICE.prototype =
    */
   unregisterDisplay: function HS_unregisterDisplay(aHUDId)
   {
     let hud = this.getHudReferenceById(aHUDId);
 
     // Remove children from the output. If the output is not cleared, there can
     // be leaks as some nodes has node.onclick = function; set and GC can't
     // remove the nodes then.
-    if (hud.gcliterm) {
-      hud.gcliterm.clearOutput();
-    }
 
     let document = hud.chromeDocument;
 
     let popupset = document.getElementById("mainPopupSet");
     let panels = popupset.querySelectorAll("panel[hudId=" + aHUDId + "]");
     for (let i = 0; i < panels.length; i++) {
       panels[i].hidePopup();
     }
@@ -774,24 +658,16 @@ HUD_SERVICE.prototype =
     hud.HUDBox.parentNode.removeChild(hud.HUDBox);
 
     if (hud.splitter.parentNode) {
       hud.splitter.parentNode.removeChild(hud.splitter);
     }
 
     delete this.hudReferences[aHUDId];
 
-    for (let windowID in this.windowIds) {
-      if (this.windowIds[windowID] == aHUDId) {
-        delete this.windowIds[windowID];
-      }
-    }
-
-    this.unregisterActiveContext(aHUDId);
-
     if (Object.keys(this.hudReferences).length == 0) {
       let autocompletePopup = document.
                               getElementById("webConsole_autocompletePopup");
       if (autocompletePopup) {
         autocompletePopup.parentNode.removeChild(autocompletePopup);
       }
 
       this.suspend();
@@ -823,24 +699,24 @@ HUD_SERVICE.prototype =
   {
     delete this.defaultFilterPrefs;
     delete this.lastFinishedRequestCallback;
 
     WebConsoleObserver.uninit();
   },
 
   /**
-   * Shutdown all HeadsUpDisplays on xpcom-shutdown
+   * Shutdown all HeadsUpDisplays on quit-application-granted.
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
   {
-    for (let hudId in this.hudReferences) {
-      this.deactivateHUDForContext(this.hudReferences[hudId].tab, false);
+    for (let hud of this.hudReferences) {
+      this.deactivateHUDForContext(hud.tab, false);
     }
   },
 
   /**
    * Returns the HeadsUpDisplay object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
@@ -855,44 +731,40 @@ HUD_SERVICE.prototype =
    * Returns the hudId that is corresponding to the hud activated for the
    * passed aContentWindow. If there is no matching hudId null is returned.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns string or null
    */
   getHudIdByWindow: function HS_getHudIdByWindow(aContentWindow)
   {
-    let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow);
-    return this.getHudIdByWindowId(windowId);
+    let window = this.currentContext();
+    let index =
+      window.gBrowser.getBrowserIndexForDocument(aContentWindow.document);
+    if (index == -1) {
+      return null;
+    }
+
+    let tab = window.gBrowser.tabs[index];
+    let hudId = "hud_" + tab.linkedPanel;
+    return hudId in this.hudReferences ? hudId : null;
   },
 
   /**
    * Returns the hudReference for a given id.
    *
    * @param string aId
    * @returns Object
    */
   getHudReferenceById: function HS_getHudReferenceById(aId)
   {
     return aId in this.hudReferences ? this.hudReferences[aId] : null;
   },
 
   /**
-   * Returns the hudId that is corresponding to the given outer window ID.
-   *
-   * @param number aWindowId
-   *        the outer window ID
-   * @returns string the hudId
-   */
-  getHudIdByWindowId: function HS_getHudIdByWindowId(aWindowId)
-  {
-    return this.windowIds[aWindowId];
-  },
-
-  /**
    * Get the current filter string for the HeadsUpDisplay
    *
    * @param string aHUDId
    * @returns string
    */
   getFilterStringByHUDId: function HS_getFilterStringbyHUDId(aHUDId) {
     return this.getHudReferenceById(aHUDId).filterBox.value;
   },
@@ -1055,123 +927,25 @@ HUD_SERVICE.prototype =
 
     if (window.webConsoleCommandController) {
       window.controllers.removeController(window.webConsoleCommandController);
       window.webConsoleCommandController = null;
     }
   },
 
   /**
-   * windowInitializer - checks what Gecko app is running and inits the HUD
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  windowInitializer: function HS_WindowInitalizer(aContentWindow)
-  {
-    var xulWindow = aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-      .getInterface(Ci.nsIWebNavigation)
-                      .QueryInterface(Ci.nsIDocShell)
-                      .chromeEventHandler.ownerDocument.defaultView;
-
-    let xulWindow = WebConsoleUtils.unwrap(xulWindow);
-
-    let docElem = xulWindow.document.documentElement;
-    if (!docElem || docElem.getAttribute("windowtype") != "navigator:browser" ||
-        !xulWindow.gBrowser) {
-      // Do not do anything unless we have a browser window.
-      // This may be a view-source window or other type of non-browser window.
-      return;
-    }
-
-    let gBrowser = xulWindow.gBrowser;
-
-    let _browser = gBrowser.
-      getBrowserForDocument(aContentWindow.top.document);
-
-    // ignore newly created documents that don't belong to a tab's browser
-    if (!_browser) {
-      return;
-    }
-
-    let nBox = gBrowser.getNotificationBox(_browser);
-    let nBoxId = nBox.getAttribute("id");
-    let hudId = "hud_" + nBoxId;
-    let windowUI = nBox.ownerDocument.getElementById("console_window_" + hudId);
-    if (windowUI) {
-      // The Web Console popup is already open, no need to continue.
-      if (aContentWindow == aContentWindow.top) {
-        let hud = this.hudReferences[hudId];
-        hud.reattachConsole(aContentWindow);
-      }
-      return;
-    }
-
-    if (!this.canActivateContext(hudId)) {
-      return;
-    }
-
-    xulWindow.addEventListener("unload", this.onWindowUnload, false);
-    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
-
-    this.registerDisplay(hudId);
-
-    let hudNode;
-    let childNodes = nBox.childNodes;
-
-    for (let i = 0; i < childNodes.length; i++) {
-      let id = childNodes[i].getAttribute("id");
-      // `id` is a string with the format "hud_<number>".
-      if (id.split("_")[0] == "hud") {
-        hudNode = childNodes[i];
-        break;
-      }
-    }
-
-    let hud;
-    // If there is no HUD for this tab create a new one.
-    if (!hudNode) {
-      // get nBox object and call new HUD
-      let config = { parentNode: nBox,
-                     contentWindow: aContentWindow.top
-                   };
-
-      hud = new HeadsUpDisplay(config);
-
-      HUDService.registerHUDReference(hud);
-      let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow.top);
-      this.windowIds[windowId] = hudId;
-    }
-    else {
-      hud = this.hudReferences[hudId];
-      if (aContentWindow == aContentWindow.top) {
-        // TODO: name change?? doesn't actually re-attach the console
-        hud.reattachConsole(aContentWindow);
-      }
-    }
-
-    // Need to detect that the console component has been paved over.
-    let consoleObject = WebConsoleUtils.unwrap(aContentWindow).console;
-    if (!("__mozillaConsole__" in consoleObject))
-      this.logWarningAboutReplacedAPI(hudId);
-
-    // register the controller to handle "select all" properly
-    this.createController(xulWindow);
-  },
-
-  /**
    * Adds the command controller to the XUL window if it's not already present.
    *
    * @param nsIDOMWindow aWindow
    *        The browser XUL window.
    * @returns void
    */
-  createController: function HUD_createController(aWindow)
+  createController: function HS_createController(aWindow)
   {
-    if (aWindow.webConsoleCommandController == null) {
+    if (!aWindow.webConsoleCommandController) {
       aWindow.webConsoleCommandController = new CommandController(aWindow);
       aWindow.controllers.insertControllerAt(0,
         aWindow.webConsoleCommandController);
     }
   },
 
   /**
    * Animates the Console appropriately.
@@ -1226,18 +1000,18 @@ HUD_SERVICE.prototype =
   /**
    * Reset the height of the Web Console.
    *
    * @param string aHUDId The ID of the Web Console.
    */
   resetHeight: function HS_resetHeight(aHUDId)
   {
     let HUD = this.hudReferences[aHUDId];
-    let innerHeight = HUD.contentWindow.innerHeight;
-    let chromeWindow = HUD.chromeDocument.defaultView;
+    let innerHeight = HUD.browser.clientHeight;
+    let chromeWindow = HUD.chromeWindow;
     if (!HUD.consolePanel) {
       let splitterStyle = chromeWindow.getComputedStyle(HUD.splitter, null);
       innerHeight += parseInt(splitterStyle.height) +
                      parseInt(splitterStyle.borderTopWidth) +
                      parseInt(splitterStyle.borderBottomWidth);
     }
 
     let boxStyle = chromeWindow.getComputedStyle(HUD.HUDBox, null);
@@ -1246,17 +1020,18 @@ HUD_SERVICE.prototype =
                    parseInt(boxStyle.borderBottomWidth);
 
     let height = this.lastConsoleHeight > 0 ? this.lastConsoleHeight :
       Math.ceil(innerHeight * DEFAULT_CONSOLE_HEIGHT);
 
     if ((innerHeight - height) < MINIMUM_PAGE_HEIGHT) {
       height = innerHeight - MINIMUM_PAGE_HEIGHT;
     }
-    else if (height < MINIMUM_CONSOLE_HEIGHT) {
+
+    if (isNaN(height) || height < MINIMUM_CONSOLE_HEIGHT) {
       height = MINIMUM_CONSOLE_HEIGHT;
     }
 
     HUD.HUDBox.style.height = height + "px";
   },
 
   /**
    * Remember the height of the given Web Console, such that it can later be
@@ -1322,129 +1097,44 @@ HUD_SERVICE.prototype =
     clipboardHelper.copyString(strings.join("\n"));
   }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplay
 //////////////////////////////////////////////////////////////////////////
 
-/*
+/**
  * HeadsUpDisplay is an interactive console initialized *per tab*  that
  * displays console log data as well as provides an interactive terminal to
  * manipulate the current tab's document content.
- * */
-function HeadsUpDisplay(aConfig)
+ *
+ * @param nsIDOMElement aTab
+ *        The xul:tab for which you want the HeadsUpDisplay object.
+ */
+function HeadsUpDisplay(aTab)
 {
-  // sample config: { parentNode: aDOMNode,
-  //                  // or
-  //                  parentNodeId: "myHUDParent123",
-  //
-  //                  placement: "appendChild"
-  //                  // or
-  //                  placement: "insertBefore",
-  //                  placementChildNodeIndex: 0,
-  //                }
-
-  this.HUDBox = null;
-
-  if (aConfig.parentNode) {
-    // TODO: need to replace these DOM calls with internal functions
-    // that operate on each application's node structure
-    // better yet, we keep these functions in a "bridgeModule" or the HUDService
-    // to keep a registry of nodeGetters for each application
-    // see bug 568647
-    this.parentNode = aConfig.parentNode;
-    this.notificationBox = aConfig.parentNode;
-    this.chromeDocument = aConfig.parentNode.ownerDocument;
-    this.contentWindow = aConfig.contentWindow;
-    this.uriSpec = aConfig.contentWindow.location.href;
-    this.hudId = "hud_" + aConfig.parentNode.getAttribute("id");
-  }
-  else {
-    // parentNodeId is the node's id where we attach the HUD
-    // TODO: is the "navigator:browser" below used in all Gecko Apps?
-    // see bug 568647
-    let windowEnum = Services.wm.getEnumerator("navigator:browser");
-    let parentNode;
-    let contentDocument;
-    let contentWindow;
-    let chromeDocument;
-
-    // TODO: the following  part is still very Firefox specific
-    // see bug 568647
-
-    while (windowEnum.hasMoreElements()) {
-      let window = windowEnum.getNext();
-      try {
-        let gBrowser = window.gBrowser;
-        let _browsers = gBrowser.browsers;
-        let browserLen = _browsers.length;
-
-        for (var i = 0; i < browserLen; i++) {
-          var _notificationBox = gBrowser.getNotificationBox(_browsers[i]);
-          this.notificationBox = _notificationBox;
-
-          if (_notificationBox.getAttribute("id") == aConfig.parentNodeId) {
-            this.parentNodeId = _notificationBox.getAttribute("id");
-            this.hudId = "hud_" + this.parentNodeId;
-
-            parentNode = _notificationBox;
-
-            this.contentDocument =
-              _notificationBox.childNodes[0].contentDocument;
-            this.contentWindow =
-              _notificationBox.childNodes[0].contentWindow;
-            this.uriSpec = aConfig.contentWindow.location.href;
-
-            this.chromeDocument =
-              _notificationBox.ownerDocument;
-
-            break;
-          }
-        }
-      }
-      catch (ex) {
-        Cu.reportError(ex);
-      }
-
-      if (parentNode) {
-        break;
-      }
-    }
-    if (!parentNode) {
-      throw new Error(this.ERRORS.PARENTNODE_NOT_FOUND);
-    }
-    this.parentNode = parentNode;
-    this.notificationBox = parentNode;
-  }
-
-  // create textNode Factory:
-  this.textFactory = NodeFactory("text", "xul", this.chromeDocument);
-
+  this.tab = aTab;
+  this.hudId = "hud_" + this.tab.linkedPanel;
+  this.chromeDocument = this.tab.ownerDocument;
   this.chromeWindow = this.chromeDocument.defaultView;
+  this.notificationBox = this.chromeDocument.getElementById(this.tab.linkedPanel);
   this.browser = this.tab.linkedBrowser;
   this.messageManager = this.browser.messageManager;
 
   // Track callback functions registered for specific async requests sent to the
   // content process.
   this.asyncRequests = {};
 
   // create a panel dynamically and attach to the parentNode
   this.createHUD();
-  this.HUDBox.lastTimestamp = 0;
 
   // create the JSTerm input element
-  this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-  if (this.jsterm) {
-    this.jsterm.inputNode.focus();
-  }
-  else if (this.gcliterm) {
-    this.gcliterm.inputNode.focus();
-  }
+  this.jsterm = new JSTerm(this);
+  this.jsterm.inputNode.focus();
 
   // A cache for tracking repeated CSS Nodes.
   this.cssNodes = {};
 
   this._setupMessageManager();
 }
 
 HeadsUpDisplay.prototype = {
@@ -1454,20 +1144,22 @@ HeadsUpDisplay.prototype = {
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
     "WebConsole:CachedMessages", "WebConsole:PageError", "JSTerm:EvalResult",
     "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
     "JSTerm:InspectObject", "WebConsole:NetworkActivity",
-    "WebConsole:FileActivity"],
+    "WebConsole:FileActivity", "WebConsole:LocationChange"],
 
   consolePanel: null,
 
+  contentLocation: "",
+
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   _saveRequestAndResponseBodies: false,
 
   /**
@@ -1497,54 +1189,33 @@ HeadsUpDisplay.prototype = {
   },
 
   get mainPopupSet()
   {
     return this.chromeDocument.getElementById("mainPopupSet");
   },
 
   /**
-   * Get the tab associated to the HeadsUpDisplay object.
-   */
-  get tab()
-  {
-    // TODO: we should only keep a reference to the tab object and use
-    // getters to determine the rest of objects we need - the chrome window,
-    // document, etc. We should simplify the entire code to use only a single
-    // tab object ref. See bug 656231.
-    let tab = null;
-    let id = this.notificationBox.id;
-    Array.some(this.chromeDocument.defaultView.gBrowser.tabs, function(aTab) {
-      if (aTab.linkedPanel == id) {
-        tab = aTab;
-        return true;
-      }
-    });
-
-    return tab;
-  },
-
-  /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    */
   createOwnWindowPanel: function HUD_createOwnWindowPanel()
   {
     if (this.uiInOwnWindow) {
       return this.consolePanel;
     }
 
     let width = 0;
     try {
       width = Services.prefs.getIntPref("devtools.webconsole.width");
     }
     catch (ex) {}
 
     if (width < 1) {
-      width = this.HUDBox.clientWidth || this.contentWindow.innerWidth;
+      width = this.HUDBox.clientWidth || this.chromeWindow.innerWidth;
     }
 
     let height = this.HUDBox.clientHeight;
 
     let top = 0;
     try {
       top = Services.prefs.getIntPref("devtools.webconsole.top");
     }
@@ -1590,22 +1261,17 @@ HeadsUpDisplay.prototype = {
 
       panel.setAttribute("height", height);
 
       // Scroll the outputNode back to the last location.
       if (lastIndex > -1 && lastIndex < this.outputNode.getRowCount()) {
         this.outputNode.ensureIndexIsVisible(lastIndex);
       }
 
-      if (this.jsterm) {
-        this.jsterm.inputNode.focus();
-      }
-      if (this.gcliterm) {
-        this.gcliterm.inputNode.focus();
-      }
+      this.jsterm.inputNode.focus();
     }).bind(this);
 
     panel.addEventListener("popupshown", onPopupShown,false);
 
     let onPopupHidden = (function HUD_onPopupHidden(aEvent) {
       if (aEvent.target != panel) {
         return;
       }
@@ -1674,17 +1340,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function HUD_getPanelTitle()
   {
-    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.contentLocation]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -1773,64 +1439,25 @@ HeadsUpDisplay.prototype = {
       this.HUDBox.removeAttribute("flex");
       this.HUDBox.removeAttribute("height");
       this.HUDBox.style.height = height + "px";
     }
 
     if (this.jsterm) {
       this.jsterm.inputNode.focus();
     }
-    if (this.gcliterm) {
-      this.gcliterm.inputNode.focus();
-    }
   },
 
   /**
    * The JSTerm object that contains the console's inputNode
    *
    */
   jsterm: null,
 
   /**
-   * The GcliTerm object that contains the console's GCLI
-   */
-  gcliterm: null,
-
-  /**
-   * creates and attaches the console input node
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns void
-   */
-  createConsoleInput:
-  function HUD_createConsoleInput(aWindow, aParentNode, aExistingConsole)
-  {
-    let usegcli = false;
-    try {
-      // usegcli = Services.prefs.getBoolPref("devtools.gcli.enable");
-    }
-    catch (ex) {}
-
-    if (appName() == "FIREFOX") {
-      if (!usegcli) {
-        let mixin = new JSTermFirefoxMixin(aParentNode, aExistingConsole);
-        this.jsterm = new JSTerm(this, mixin);
-      }
-      else {
-        this.gcliterm = new GcliTerm(aWindow, this.hudId, this.chromeDocument,
-                                     this.console, this.hintNode, this.consoleWrap);
-        aParentNode.appendChild(this.gcliterm.element);
-      }
-    }
-    else {
-      throw new Error("Unsupported Gecko Application");
-    }
-  },
-
-  /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
    * @private
    * @param array aRemoteMessages
    *        Array of cached messages coming from the remote Web Console
    *        content instance.
    */
@@ -1864,40 +1491,16 @@ HeadsUpDisplay.prototype = {
     if (numChildren && this.outputNode.clientHeight) {
       // We also check the clientHeight to force a reflow, otherwise
       // ensureIndexIsVisible() does not work after outputNode.hidden = false.
       this.outputNode.ensureIndexIsVisible(numChildren - 1);
     }
   },
 
   /**
-   * Re-attaches a console when the contentWindow is recreated
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  reattachConsole: function HUD_reattachConsole(aContentWindow)
-  {
-    this.contentWindow = aContentWindow;
-    this.contentDocument = this.contentWindow.document;
-    this.uriSpec = this.contentWindow.location.href;
-
-    if (this.consolePanel) {
-      this.consolePanel.label = this.getPanelTitle();
-    }
-
-    if (this.gcliterm) {
-      this.gcliterm.reattachConsole(this.contentWindow, this.console);
-    }
-    else if (!this.jsterm) {
-      this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    }
-  },
-
-  /**
    * Shortcut to make XUL nodes
    *
    * @param string aTag
    * @returns nsIDOMNode
    */
   makeXULNode:
   function HUD_makeXULNode(aTag)
   {
@@ -1906,25 +1509,24 @@ HeadsUpDisplay.prototype = {
 
   /**
    * Build the UI of each HeadsUpDisplay
    *
    * @returns nsIDOMNode
    */
   makeHUDNodes: function HUD_makeHUDNodes()
   {
-    let self = this;
-
     this.splitter = this.makeXULNode("splitter");
     this.splitter.setAttribute("class", "hud-splitter");
 
     this.HUDBox = this.makeXULNode("vbox");
     this.HUDBox.setAttribute("id", this.hudId);
     this.HUDBox.setAttribute("class", "hud-box animated");
     this.HUDBox.style.height = 0;
+    this.HUDBox.lastTimestamp = 0;
 
     let outerWrap = this.makeXULNode("vbox");
     outerWrap.setAttribute("class", "hud-outer-wrapper");
     outerWrap.setAttribute("flex", "1");
 
     let consoleCommandSet = this.makeXULNode("commandset");
     outerWrap.appendChild(consoleCommandSet);
 
@@ -1979,17 +1581,17 @@ HeadsUpDisplay.prototype = {
 
     consoleWrap.appendChild(consoleFilterToolbar);
     consoleWrap.appendChild(hbox);
 
     outerWrap.appendChild(consoleWrap);
 
     this.HUDBox.lastTimestamp = 0;
 
-    this.jsTermParentNode = outerWrap;
+    this.jsTermParentNode = this.consoleWrap;
     this.HUDBox.appendChild(outerWrap);
 
     return this.HUDBox;
   },
 
   /**
    * sets the click events for all binary toggle filter buttons
    *
@@ -2289,22 +1891,17 @@ HeadsUpDisplay.prototype = {
    *        The ID of the console.
    * @return void
    */
   makeClearConsoleButton: function HUD_makeClearConsoleButton(aToolbar)
   {
     let hudId = this.hudId;
     function HUD_clearButton_onCommand() {
       let hud = HUDService.getHudReferenceById(hudId);
-      if (hud.jsterm) {
-        hud.jsterm.clearOutput(true);
-      }
-      if (hud.gcliterm) {
-        hud.gcliterm.clearOutput();
-      }
+      hud.jsterm.clearOutput(true);
     }
 
     let clearButton = this.makeXULNode("toolbarbutton");
     clearButton.setAttribute("label", l10n.getStr("btnClear"));
     clearButton.classList.add("webconsole-clear-console-button");
     clearButton.addEventListener("command", HUD_clearButton_onCommand, false);
 
     aToolbar.appendChild(clearButton);
@@ -2343,18 +1940,16 @@ HeadsUpDisplay.prototype = {
       let positionPref = Services.prefs.getCharPref("devtools.webconsole.position");
       this.positionConsole(positionPref);
     }
     return this.HUDBox;
   },
 
   uiInOwnWindow: false,
 
-  get console() { return this.contentWindow.wrappedJSObject.console; },
-
   /**
    * Logs a message to the Web Console that originates from the remote Web
    * Console instance.
    *
    * @param object aMessage
    *        The message received from the remote Web Console instance.
    *        console service. This object needs to hold:
    *          - hudId - the Web Console ID.
@@ -2686,17 +2281,18 @@ HeadsUpDisplay.prototype = {
   {
     this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.addMessageListener(aName, this);
     }, this);
 
     let message = {
-      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor"],
+      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor",
+                 "LocationChange"],
       cachedMessages: ["ConsoleAPI", "PageError"],
       NetworkMonitor: { monitorFileActivity: true },
       preferences: {
         "NetworkMonitor.saveRequestAndResponseBodies":
           this.saveRequestAndResponseBodies,
       },
     };
     this.sendMessageToContent("WebConsole:Init", message);
@@ -2740,16 +2336,19 @@ HeadsUpDisplay.prototype = {
         this._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
         this.logFileActivity(aMessage.json.uri);
         break;
+      case "WebConsole:LocationChange":
+        this.onLocationChange(aMessage.json);
+        break;
     }
   },
 
   /**
    * Callback method for when the Web Console initialization is complete. For
    * now this method sends the web-console-created notification using the
    * nsIObserverService.
    *
@@ -2885,16 +2484,24 @@ HeadsUpDisplay.prototype = {
     // once requests complete.
     if (HUDService.lastFinishedRequestCallback &&
         aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
         aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
       HUDService.lastFinishedRequestCallback(aMessage);
     }
   },
 
+  onLocationChange: function HUD_onLocationChange(aMessage)
+  {
+    this.contentLocation = aMessage.location;
+    if (this.consolePanel) {
+      this.consolePanel.label = this.getPanelTitle();
+    }
+  },
+
   /**
    * Make a link given an output element.
    *
    * @param nsIDOMNode aNode
    *        The message element you want to make a link for.
    * @param function aCallback
    *        The function you want invoked when the user clicks on the message
    *        element.
@@ -2938,19 +2545,16 @@ HeadsUpDisplay.prototype = {
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.removeMessageListener(aName, this);
     }, this);
 
     if (this.jsterm) {
       this.jsterm.destroy();
     }
-    if (this.gcliterm) {
-      this.gcliterm.destroy();
-    }
 
     delete this.asyncRequests;
     delete this.messageManager;
     delete this.browser;
     delete this.chromeDocument;
 
     this.positionMenuitems.above.removeEventListener("command",
       this._positionConsoleAbove, false);
@@ -3002,27 +2606,22 @@ function NodeFactory(aFactoryType, ignor
 
 /**
  * Create a JSTerminal or attach a JSTerm input node to an existing output node,
  * given by the parent node.
  *
  * @constructor
  * @param object aHud
  *        The HeadsUpDisplay object that owns this JSTerm instance.
- * @param object aMixin
- *        Gecko-app (or Jetpack) specific utility object
  */
-function JSTerm(aHud, aMixin)
+function JSTerm(aHud)
 {
-  // attach the UI by appending to aParentNode
-
-  this.application = appName();
   this.hud = aHud;
-  this.mixins = aMixin;
   this.document = this.hud.chromeDocument;
+  this.parentNode = this.hud.jsTermParentNode;
 
   this.hudId = this.hud.hudId;
 
   this.lastCompletion = {};
   this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
   this.autocompletePopup = new AutocompletePopup(this.document);
@@ -3034,46 +2633,54 @@ function JSTerm(aHud, aMixin)
 JSTerm.prototype = {
   lastInputValue: "",
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   init: function JST_init()
   {
-    this.inputNode = this.mixins.inputNode;
-    this.outputNode = this.mixins.outputNode;
-    this.completeNode = this.mixins.completeNode;
+    this._generateUI();
 
     this._keyPress = this.keyPress.bind(this);
     this._inputEventHandler = this.inputEventHandler.bind(this);
 
-    this.inputNode.addEventListener("keypress",
-      this._keyPress, false);
-    this.inputNode.addEventListener("input",
-      this._inputEventHandler, false);
-    this.inputNode.addEventListener("keyup",
-      this._inputEventHandler, false);
+    this.inputNode.addEventListener("keypress", this._keyPress, false);
+    this.inputNode.addEventListener("input", this._inputEventHandler, false);
+    this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
   },
 
-  get codeInputString()
+  _generateUI: function JST__generateUI()
   {
-    return this.inputNode.value;
+    this.completeNode = this.hud.makeXULNode("textbox");
+    this.completeNode.setAttribute("class", "jsterm-complete-node");
+    this.completeNode.setAttribute("multiline", "true");
+    this.completeNode.setAttribute("rows", "1");
+    this.completeNode.setAttribute("tabindex", "-1");
+
+    this.inputNode = this.hud.makeXULNode("textbox");
+    this.inputNode.setAttribute("class", "jsterm-input-node");
+    this.inputNode.setAttribute("multiline", "true");
+    this.inputNode.setAttribute("rows", "1");
+
+    let inputStack = this.hud.makeXULNode("stack");
+    inputStack.setAttribute("class", "jsterm-stack-node");
+    inputStack.setAttribute("flex", "1");
+    inputStack.appendChild(this.completeNode);
+    inputStack.appendChild(this.inputNode);
+
+    let term = this.hud.makeXULNode("hbox");
+    term.setAttribute("class", "jsterm-input-container");
+    term.setAttribute("style", "direction: ltr;");
+    term.appendChild(inputStack);
+
+    this.parentNode.appendChild(term);
   },
 
-  generateUI: function JST_generateUI()
-  {
-    this.mixins.generateUI();
-  },
-
-  attachUI: function JST_attachUI()
-  {
-    this.mixins.attachUI();
-  },
-
+  get outputNode() this.hud.outputNode,
 
   /**
    * Asynchronously evaluate a string in the content process sandbox.
    *
    * @param string aString
    *        String to evaluate in the content process JavaScript sandbox.
    * @param function [aCallback]
    *        Optional function to be invoked when the evaluation result is
@@ -3291,17 +2898,17 @@ JSTerm.prototype = {
    * Clear the Web Console output.
    *
    * @param boolean aClearStorage
    *        True if you want to clear the console messages storage associated to
    *        this Web Console.
    */
   clearOutput: function JST_clearOutput(aClearStorage)
   {
-    let hud = HUDService.getHudReferenceById(this.hudId);
+    let hud = this.hud;
     hud.cssNodes = {};
 
     let outputNode = hud.outputNode;
     let node;
     while ((node = outputNode.firstChild)) {
       if (node._evalCacheId && !node._panelOpen) {
         this.clearObjectCache(node._evalCacheId);
       }
@@ -3990,129 +3597,27 @@ JSTerm.prototype = {
     this.inputNode.removeEventListener("keypress", this._keyPress, false);
     this.inputNode.removeEventListener("input", this._inputEventHandler, false);
     this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
 
     delete this.history;
     delete this.hud;
     delete this.autocompletePopup;
     delete this.document;
-    delete this.mixins;
-  },
-};
-
-/**
- * Generates and attaches the JS Terminal part of the Web Console, which
- * essentially consists of the interactive JavaScript input facility.
- *
- * @param nsIDOMNode aParentNode
- *        The Web Console wrapper node.
- * @param nsIDOMNode aExistingConsole
- *        The Web Console output node.
- * @return void
- */
-function JSTermFirefoxMixin(aParentNode, aExistingConsole)
-{
-  // aExisting Console is the existing outputNode to use in favor of
-  // creating a new outputNode - this is so we can just attach the inputNode to
-  // a normal HeadsUpDisplay console output, and re-use code.
-  this.parentNode = aParentNode;
-  this.existingConsoleNode = aExistingConsole;
-
-  if (aParentNode.ownerDocument) {
-    this.xulElementFactory =
-      NodeFactory("xul", "xul", aParentNode.ownerDocument);
-
-    this.textFactory = NodeFactory("text", "xul", aParentNode.ownerDocument);
-    this.generateUI();
-    this.attachUI();
-  }
-  else {
-    throw new Error("aParentNode should be a DOM node with an ownerDocument property ");
-  }
-}
-
-JSTermFirefoxMixin.prototype = {
-  /**
-   * Generates and attaches the UI for an entire JS Workspace or
-   * just the input node used under the console output
-   *
-   * @returns void
-   */
-  generateUI: function JSTF_generateUI()
-  {
-    this.completeNode = this.xulElementFactory("textbox");
-    this.completeNode.setAttribute("class", "jsterm-complete-node");
-    this.completeNode.setAttribute("multiline", "true");
-    this.completeNode.setAttribute("rows", "1");
-    this.completeNode.setAttribute("tabindex", "-1");
-
-    this.inputNode = this.xulElementFactory("textbox");
-    this.inputNode.setAttribute("class", "jsterm-input-node");
-    this.inputNode.setAttribute("multiline", "true");
-    this.inputNode.setAttribute("rows", "1");
-
-    let inputStack = this.xulElementFactory("stack");
-    inputStack.setAttribute("class", "jsterm-stack-node");
-    inputStack.setAttribute("flex", "1");
-    inputStack.appendChild(this.completeNode);
-    inputStack.appendChild(this.inputNode);
-
-    if (this.existingConsoleNode == undefined) {
-      throw new Error("This can't happen");
-    }
-
-    this.outputNode = this.existingConsoleNode;
-
-    this.term = this.xulElementFactory("hbox");
-    this.term.setAttribute("class", "jsterm-input-container");
-    this.term.setAttribute("style", "direction: ltr;");
-    this.term.appendChild(inputStack);
-  },
-
-  get inputValue()
-  {
-    return this.inputNode.value;
-  },
-
-  attachUI: function JSTF_attachUI()
-  {
-    this.parentNode.appendChild(this.term);
-  }
-};
-
-/**
- * Firefox-specific Application Hooks.
- * Each Gecko-based application will need an object like this in
- * order to use the Heads Up Display
- */
-function FirefoxApplicationHooks()
-{ }
-
-FirefoxApplicationHooks.prototype = {
-  /**
-   * gets the current contentWindow (Firefox-specific)
-   *
-   * @returns nsIDOMWindow
-   */
-  getCurrentContext: function FAH_getCurrentContext()
-  {
-    return Services.wm.getMostRecentWindow("navigator:browser");
   },
 };
 
 //////////////////////////////////////////////////////////////////////////////
 // Utility functions used by multiple callers
 //////////////////////////////////////////////////////////////////////////////
 
 /**
  * ConsoleUtils: a collection of globally used functions
  *
  */
-
 ConsoleUtils = {
   /**
    * Flag to turn on and off scrolling.
    */
   scroll: true,
 
   /**
    * Scrolls a node so that it's visible in its containing XUL "scrollbox"
@@ -4648,18 +4153,18 @@ HeadsUpDisplayUICommands = {
   /**
    * Find the hudId for the active chrome window.
    * @return string|null
    *         The hudId or null if the active chrome window has no open Web
    *         Console.
    */
   getOpenHUD: function UIC_getOpenHUD() {
     let chromeWindow = HUDService.currentContext();
-    let contentWindow = chromeWindow.gBrowser.selectedBrowser.contentWindow;
-    return HUDService.getHudIdByWindow(contentWindow);
+    let hudId = "hud_" + chromeWindow.gBrowser.selectedTab.linkedPanel;
+    return hudId in HUDService.hudReferences ? hudId : null;
   },
 
   /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @param nsIDOMEvent aEvent
    *        The event that triggered the filter change.
@@ -4756,33 +4261,28 @@ HeadsUpDisplayUICommands = {
 // WebConsoleObserver
 //////////////////////////////////////////////////////////////////////////
 
 let WebConsoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   init: function WCO_init()
   {
-    Services.obs.addObserver(this, "content-document-global-created", false);
     Services.obs.addObserver(this, "quit-application-granted", false);
   },
 
   observe: function WCO_observe(aSubject, aTopic)
   {
-    if (aTopic == "content-document-global-created") {
-      HUDService.windowInitializer(aSubject);
-    }
-    else if (aTopic == "quit-application-granted") {
+    if (aTopic == "quit-application-granted") {
       HUDService.shutdown();
     }
   },
 
   uninit: function WCO_uninit()
   {
-    Services.obs.removeObserver(this, "content-document-global-created");
     Services.obs.removeObserver(this, "quit-application-granted");
   },
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -4867,412 +4367,31 @@ CommandController.prototype = {
         break;
       case "cmd_selectAll":
         this.selectAll(outputNode);
         break;
     }
   }
 };
 
-///////////////////////////////////////////////////////////////////////////
-// appName
-///////////////////////////////////////////////////////////////////////////
-
 /**
  * Get the app's name so we can properly dispatch app-specific
  * methods per API call
  * @returns Gecko application name
  */
 function appName()
 {
   let APP_ID = Services.appinfo.QueryInterface(Ci.nsIXULRuntime).ID;
 
   let APP_ID_TABLE = {
     "{ec8030f7-c20a-464f-9b0e-13a3a9e97384}": "FIREFOX" ,
     "{3550f703-e582-4d05-9a08-453d09bdfdc6}": "THUNDERBIRD",
     "{a23983c0-fd0e-11dc-95ff-0800200c9a66}": "FENNEC" ,
     "{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}": "SEAMONKEY",
   };
 
-  let name = APP_ID_TABLE[APP_ID];
-
-  if (name){
-    return name;
-  }
-  throw new Error("appName: UNSUPPORTED APPLICATION UUID");
+  return APP_ID_TABLE[APP_ID];
 }
 
 XPCOMUtils.defineLazyGetter(this, "HUDService", function () {
-  try {
-    return new HUD_SERVICE();
-  }
-  catch (ex) {
-    Cu.reportError(ex);
-  }
+  return new HUD_SERVICE();
 });
 
-///////////////////////////////////////////////////////////////////////////
-// GcliTerm
-///////////////////////////////////////////////////////////////////////////
-
-/**
- * Some commands need customization - this is how we get at them.
- */
-let commandExports = undefined;
-
-/**
- * GcliTerm
- *
- * Initialize GCLI by creating a set of startup options from the available
- * properties.
- *
- * @param nsIDOMWindow aContentWindow
- *        The content window that we're providing as the context to commands
- * @param string aHudId
- *        The HUD to which we should send console messages.
- * @param nsIDOMDocument aDocument
- *        The DOM document from which to create nodes.
- * @param object aConsole
- *        Console object to use within the GcliTerm.
- * @param nsIDOMElement aHintNode
- *        The node to which we add GCLI's hints.
- * @constructor
- */
-function GcliTerm(aContentWindow, aHudId, aDocument, aConsole, aHintNode, aConsoleWrap)
-{
-  this.context = Cu.getWeakReference(aContentWindow);
-  this.hudId = aHudId;
-  this.document = aDocument;
-  this.console = aConsole;
-  this.hintNode = aHintNode;
-  this._window = this.context.get().QueryInterface(Ci.nsIDOMWindow);
-
-  this.createUI();
-  this.createSandbox();
-
-  this.gcliConsole = gcli._internal.createDisplay({
-    contentDocument: aContentWindow.document,
-    chromeDocument: this.document,
-    outputDocument: this.document,
-    chromeWindow: this.document.defaultView,
-
-    hintElement: this.hintNode,
-    inputElement: this.inputNode,
-    completeElement: this.completeNode,
-    backgroundElement: this.inputStack,
-    consoleWrap: aConsoleWrap,
-
-    eval: this.evalInSandbox.bind(this),
-
-    environment: {
-      chromeDocument: this.document,
-      contentDocument: aContentWindow.document
-    },
-
-    tooltipClass: 'gcliterm-tooltip',
-
-    // Allow GCLI:Inputter to decide how and when to open a scratchpad window
-    scratchpad: {
-      shouldActivate: function Scratchpad_shouldActivate(aEvent) {
-        return aEvent.shiftKey &&
-            aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
-      },
-      activate: function Scratchpad_activate(aValue) {
-        aValue = aValue.replace(/^\s*{\s*/, '');
-        ScratchpadManager.openScratchpad({ text: aValue });
-        return true;
-      },
-      linkText: stringBundle.GetStringFromName('scratchpad.linkText')
-    },
-  });
-
-  this.gcliConsole.onVisibilityChange.add(this.onVisibilityChange, this);
-  this.gcliConsole.onOutput.add(this.onOutput, this);
-}
-
-GcliTerm.prototype = {
-  /**
-   * Show or remove the hint column from the display.
-   */
-  onVisibilityChange: function GcliTerm_onVisibilityChange(ev)
-  {
-    if (ev.visible) {
-      this.hintNode.parentNode.hidden = false;
-    }
-    else {
-      let permaHint = false;
-      try {
-        permaHint = Services.prefs.getBoolPref("devtools.gcli.permaHint");
-      }
-      catch (ex) {}
-
-      if (!permaHint) {
-        this.hintNode.parentNode.hidden = true;
-      }
-    }
-  },
-
-  /**
-   * Destroy the GcliTerm object. Call this method to avoid memory leaks.
-   */
-  destroy: function Gcli_destroy()
-  {
-    this.gcliConsole.onVisibilityChange.remove(this.onVisibilityChange, this);
-    this.gcliConsole.onOutput.remove(this.onOutput, this);
-    this.gcliConsole.destroy();
-
-    delete this.context;
-    delete this.document;
-    delete this.console;
-    delete this.hintNode;
-    delete this._window;
-
-    delete this.sandbox;
-    delete this.element;
-    delete this.inputStack;
-    delete this.completeNode;
-    delete this.inputNode;
-  },
-
-  /**
-   * Re-attaches a console when the contentWindow is recreated.
-   *
-   * @param nsIDOMWindow aContentWindow
-   *        The content window that we're providing as the context to commands
-   * @param object aConsole
-   *        Console object to use within the GcliTerm.
-   */
-  reattachConsole: function Gcli_reattachConsole(aContentWindow, aConsole)
-  {
-    this.context = Cu.getWeakReference(aContentWindow);
-    this.console = aConsole;
-    this.createSandbox();
-
-    this.gcliConsole.reattach({
-      contentDocument: aContentWindow.document,
-      environment: {
-        chromeDocument: this.document,
-        contentDocument: aContentWindow.document
-      },
-    });
-  },
-
-  /**
-   * Generates and attaches the GCLI Terminal part of the Web Console, which
-   * essentially consists of the interactive JavaScript input facility.
-   */
-  createUI: function Gcli_createUI()
-  {
-    this.element = this.document.createElement("vbox");
-    this.element.setAttribute("class", "gcliterm-input-container");
-    this.element.setAttribute("flex", "0");
-
-    this.inputStack = this.document.createElement("stack");
-    this.inputStack.setAttribute("class", "gcliterm-stack-node");
-    this.element.appendChild(this.inputStack);
-
-    this.completeNode = this.document.createElementNS(HTML_NS, "div");
-    this.completeNode.setAttribute("class", "gcliterm-complete-node");
-    this.completeNode.setAttribute("aria-live", "polite");
-    this.inputStack.appendChild(this.completeNode);
-
-    this.inputNode = this.document.createElement("textbox");
-    this.inputNode.setAttribute("class", "gcliterm-input-node");
-    this.inputNode.setAttribute("rows", "1");
-    this.inputStack.appendChild(this.inputNode);
-  },
-
-  /**
-   * Called by GCLI/canon when command line output changes.
-   */
-  onOutput: function Gcli_onOutput(aEvent)
-  {
-    // When we can update the history of the console, then we should stop
-    // filtering incomplete reports.
-    if (!aEvent.output.completed) {
-      return;
-    }
-
-    this.writeOutput(aEvent.output.typed, CATEGORY_INPUT);
-
-    // This is an experiment to see how much people yell when we stop reporting
-    // undefined replies.
-    if (aEvent.output.output === undefined) {
-      return;
-    }
-
-    let output = aEvent.output.output;
-    let declaredType = aEvent.output.command.returnType || "";
-
-    if (declaredType == "object") {
-      let actualType = typeof output;
-      if (output === null) {
-        output = "null";
-      }
-      else if (actualType == "string") {
-        output = "\"" + output + "\"";
-      }
-      else if (actualType == "object" || actualType == "function") {
-        let formatOpts = [ nameObject(output) ];
-        output = stringBundle.formatStringFromName('gcliterm.instanceLabel',
-                formatOpts, formatOpts.length);
-        let linkNode = this.document.createElementNS(HTML_NS, 'html:span');
-        linkNode.appendChild(this.document.createTextNode(output));
-        linkNode.classList.add("hud-clickable");
-        linkNode.setAttribute("aria-haspopup", "true");
-
-        // Make the object bring up the property panel.
-        linkNode.addEventListener("mousedown", function(aEv) {
-          this._startX = aEv.clientX;
-          this._startY = aEv.clientY;
-        }.bind(this), false);
-
-        linkNode.addEventListener("click", function(aEv) {
-          if (aEv.detail != 1 || aEv.button != 0 ||
-              (this._startX != aEv.clientX && this._startY != aEv.clientY)) {
-            return;
-          }
-
-          if (!this._panelOpen) {
-            let propPanel = this.openPropertyPanel(aEvent.output.typed, aEvent.output.output, this);
-            propPanel.panel.setAttribute("hudId", this.hudId);
-            this._panelOpen = true;
-          }
-        }.bind(this), false);
-
-        output = linkNode;
-      }
-      // else if (actualType == number/boolean/undefined) do nothing
-    }
-
-    if (declaredType == "html" && typeof output == "string") {
-      output = this.document.createRange().createContextualFragment(
-          '<div xmlns="' + HTML_NS + '" xmlns:xul="' + XUL_NS + '">' +
-          output + '</div>');
-    }
-
-    // See https://github.com/mozilla/domtemplate/blob/master/README.md
-    // for docs on the template() function
-    let element = this.document.createRange().createContextualFragment(
-      '<richlistitem xmlns="' + XUL_NS + '" _clipboardText="${clipboardText}"' +
-      '    _timestamp="${timestamp}" _id="${id}" class="hud-msg-node">' +
-      '  <label class="webconsole-timestamp" _value="${timestampString}"/>' +
-      '  <vbox class="webconsole-msg-icon-container" _style="${iconContainerStyle}">' +
-      '    <image class="webconsole-msg-icon"/>' +
-      '    <spacer flex="1"/>' +
-      '  </vbox>' +
-      '  <hbox flex="1" class="gcliterm-msg-body">${output}</hbox>' +
-      '  <hbox align="start"><label value="1" class="webconsole-msg-repeat"/></hbox>' +
-      '</richlistitem>').firstChild;
-
-    let hud = HUDService.getHudReferenceById(this.hudId);
-    let timestamp = Date.now();
-    template(element, {
-      iconContainerStyle: "margin-left=" + (hud.groupDepth * GROUP_INDENT) + "px",
-      output: output,
-      timestamp: timestamp,
-      timestampString: l10n.timestampString(timestamp),
-      clipboardText: output.innerText,
-      id: "console-msg-" + HUDService.sequenceId()
-    });
-
-    ConsoleUtils.setMessageType(element, CATEGORY_OUTPUT, SEVERITY_LOG);
-    ConsoleUtils.outputMessageNode(element, this.hudId);
-  },
-
-  /**
-   * Setup the eval sandbox, should be called whenever we are attached.
-   */
-  createSandbox: function Gcli_createSandbox()
-  {
-    // create a JS Sandbox out of this.context
-    this.sandbox = new Cu.Sandbox(this._window, {
-      sandboxPrototype: this._window,
-      wantXrays: false
-    });
-    this.sandbox.console = this.console;
-
-    JSTermHelper(this);
-  },
-
-  /**
-   * Evaluates a string in the sandbox.
-   *
-   * @param string aString
-   *        String to evaluate in the sandbox
-   * @return The result of the evaluation
-   */
-  evalInSandbox: function Gcli_evalInSandbox(aString)
-  {
-    let window = WebConsoleUtils.unwrap(this.sandbox.window);
-    let temp$ = null;
-    let temp$$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      temp$ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      temp$$ = this.sandbox.$$;
-      delete this.sandbox.$$;
-    }
-
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
-
-    if (temp$) {
-      this.sandbox.$ = temp$;
-    }
-    if (temp$$) {
-      this.sandbox.$$ = temp$$;
-    }
-
-    return result;
-  },
-
-  /**
-   * Writes a message to the HUD that originates from the interactive
-   * JavaScript console.
-   *
-   * @param string aOutputMessage
-   *        The message to display.
-   * @param number aCategory
-   *        One of the CATEGORY_ constants.
-   * @param number aSeverity
-   *        One of the SEVERITY_ constants.
-   */
-  writeOutput: function Gcli_writeOutput(aOutputMessage, aCategory, aSeverity, aOptions)
-  {
-    aOptions = aOptions || {};
-
-    let node = ConsoleUtils.createMessageNode(
-                    this.document,
-                    aCategory || CATEGORY_OUTPUT,
-                    aSeverity || SEVERITY_LOG,
-                    aOutputMessage,
-                    this.hudId,
-                    aOptions.sourceUrl || undefined,
-                    aOptions.sourceLine || undefined,
-                    aOptions.clipboardText || undefined);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
-  },
-
-  clearOutput: JSTerm.prototype.clearOutput,
-  openPropertyPanel: JSTerm.prototype.openPropertyPanel,
-
-  formatResult: WebConsoleUtils.formatResult,
-  getResultType: WebConsoleUtils.getResultType,
-  formatString: WebConsoleUtils.formatResultString,
-};
-
-/**
- * A fancy version of toString()
- */
-function nameObject(aObj) {
-  if (aObj.constructor && aObj.constructor.name) {
-    return aObj.constructor.name;
-  }
-  // If that fails, use Objects toString which sometimes gives something
-  // better than 'Object', and at least defaults to Object if nothing better
-  return Object.prototype.toString.call(aObj).slice(8, -1);
-}
diff --git a/browser/devtools/webconsole/test/Makefile.in b/browser/devtools/webconsole/test/Makefile.in
--- a/browser/devtools/webconsole/test/Makefile.in
+++ b/browser/devtools/webconsole/test/Makefile.in
@@ -20,38 +20,35 @@ include $(topsrcdir)/config/rules.mk
 	browser_webconsole_bug_580001_closing_after_completion.js \
 	browser_webconsole_bug_580400_groups.js \
 	browser_webconsole_bug_588730_text_node_insertion.js \
 	browser_webconsole_bug_601667_filter_buttons.js \
 	browser_webconsole_bug_597136_external_script_errors.js \
 	browser_webconsole_bug_597136_network_requests_from_chrome.js \
 	browser_webconsole_completion.js \
 	browser_webconsole_console_logging_api.js \
-	browser_webconsole_consoleonpage.js \
 	browser_webconsole_chrome.js \
 	browser_webconsole_execution_scope.js \
 	browser_webconsole_for_of.js \
 	browser_webconsole_history.js \
-	browser_webconsole_hud_getters.js \
 	browser_webconsole_js_input_and_output_styling.js \
 	browser_webconsole_js_input_expansion.js \
 	browser_webconsole_live_filtering_of_message_types.js \
 	browser_webconsole_live_filtering_on_search_strings.js \
 	browser_warn_user_about_replaced_api.js \
 	browser_webconsole_copying_multiple_messages_inserts_newlines_in_between.js \
 	browser_webconsole_bug_586388_select_all.js  \
 	browser_webconsole_bug_588967_input_expansion.js \
 	browser_webconsole_log_node_classes.js \
 	browser_webconsole_network_panel.js \
 	browser_webconsole_jsterm.js \
 	browser_webconsole_null_and_undefined_output.js \
 	browser_webconsole_output_order.js \
 	browser_webconsole_property_panel.js \
 	browser_webconsole_property_provider.js \
-	browser_webconsole_registries.js \
 	browser_webconsole_bug_587617_output_copy.js \
 	browser_webconsole_bug_585237_line_limit.js \
 	browser_webconsole_bug_581231_close_button.js \
 	browser_webconsole_bug_582201_duplicate_errors.js \
 	browser_webconsole_bug_580454_timestamp_l10n.js \
 	browser_webconsole_netlogging.js \
 	browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js \
 	browser_webconsole_bug_594477_clickable_output.js \
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580400_groups.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580400_groups.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580400_groups.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580400_groups.js
@@ -4,27 +4,25 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that console groups behave properly.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testGroups, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testGroups);
+  }, true);
 }
 
-function testGroups() {
-  browser.removeEventListener("DOMContentLoaded", testGroups, false);
-
-  openConsole();
-
-  let HUD = HUDService.getHudByWindow(content);
+function testGroups(HUD) {
   let jsterm = HUD.jsterm;
-  let outputNode = jsterm.outputNode;
+  let outputNode = HUD.outputNode;
 
   // We test for one group by testing for zero "new" groups. The
   // "webconsole-new-group" class creates a divider. Thus one group is
   // indicated by zero new groups, two groups are indicated by one new group,
   // and so on.
 
   let timestamp0 = Date.now();
   jsterm.execute("0");
@@ -41,14 +39,11 @@ function testGroups() {
   for (let i = 0; i < outputNode.itemCount; i++) {
     outputNode.getItemAtIndex(i).timestamp = 0;   // a "far past" value
   }
 
   jsterm.execute("2");
   is(outputNode.querySelectorAll(".webconsole-new-group").length, 1,
      "one group divider exists after the third console message");
 
-  jsterm.clearOutput();
-  jsterm.history.splice(0, jsterm.history.length);   // workaround for bug 592552
-
   finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -7,34 +7,32 @@
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/";
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded",
-                           testSelectionWhenMovingBetweenBoxes, false);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, testSelectionWhenMovingBetweenBoxes);
+  }, true);
 }
 
-function testSelectionWhenMovingBetweenBoxes() {
-  browser.removeEventListener("DOMContentLoaded",
-                              testSelectionWhenMovingBetweenBoxes, false);
-  openConsole();
-
-  let jsterm = HUDService.getHudByWindow(content).jsterm;
+function testSelectionWhenMovingBetweenBoxes(hud) {
+  let jsterm = hud.jsterm;
 
   // Fill the console with some output.
   jsterm.clearOutput();
   jsterm.execute("1 + 2");
   jsterm.execute("3 + 4");
   jsterm.execute("5 + 6");
 
-  outputNode = jsterm.outputNode;
+  let outputNode = hud.outputNode;
 
   ok(outputNode.childNodes.length >= 3, "the output node has children after " +
      "executing some JavaScript");
 
   // Test that the global Firefox "Select All" functionality (e.g. Edit >
   // Select All) works properly in the Web Console.
   let commandController = window.webConsoleCommandController;
   ok(commandController != null, "the window has a command controller object");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595350_multiple_windows_and_tabs.js
@@ -52,17 +52,17 @@ function addTabs(aWindow) {
 
 function openConsoles() {
   // open the Web Console for each of the four tabs and log a message.
   let consolesOpen = 0;
   for (let i = 0; i < openTabs.length; i++) {
     let tab = openTabs[i];
     openConsole(tab, function(index, hud) {
       ok(hud, "HUD is open for tab " + index);
-      hud.console.log("message for tab " + index);
+      hud.browser.contentWindow.console.log("message for tab " + index);
       consolesOpen++;
     }.bind(null, i));
   }
 
   waitForSuccess({
     name: "4 web consoles opened",
     validatorFn: function()
     {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
@@ -5,43 +5,38 @@
  *
  * Contributor(s):
  *  Mihai Șucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-network.html";
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
-
-  openConsole();
-
-  let hudId = HUDService.getHudIdByWindow(content);
-  hud = HUDService.hudReferences[hudId];
+function consoleOpened(aHud) {
+  hud = aHud;
 
   for (let i = 0; i < 200; i++) {
-    hud.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
-  HUDService.setFilterState(hudId, "network", false);
-  HUDService.setFilterState(hudId, "networkinfo", false);
+  HUDService.setFilterState(hud.hudId, "network", false);
+  HUDService.setFilterState(hud.hudId, "networkinfo", false);
 
   hud.filterBox.value = "test message";
   HUDService.updateFilterText(hud.filterBox);
 
   browser.addEventListener("load", tabReload, true);
 
   executeSoon(function() {
     content.location.reload();
   });
 }
 
 function tabReload(aEvent) {
-  browser.removeEventListener(aEvent.type, arguments.callee, true);
+  browser.removeEventListener(aEvent.type, tabReload, true);
 
   let msgNode = hud.outputNode.querySelector(".webconsole-msg-network");
   ok(msgNode, "found network message");
   ok(msgNode.classList.contains("hud-filtered-by-type"),
     "network message is filtered by type");
   ok(msgNode.classList.contains("hud-filtered-by-string"),
     "network message is filtered by string");
 
@@ -57,11 +52,14 @@ function tabReload(aEvent) {
   HUDService.setFilterState(hud.hudId, "network", true);
   HUDService.setFilterState(hud.hudId, "networkinfo", true);
 
   executeSoon(finishTest);
 }
 
 function test() {
   addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad, true);
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    openConsole(null, consoleOpened);
+  }, true);
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_598357_jsterm_output.js
@@ -136,17 +136,17 @@ function testGen() {
   let consoleTest = inputValues[cpos][5] || inputValue;
 
   HUD.jsterm.clearOutput();
 
   // Test the console.log() output.
 
   // Ugly but it does the job.
   with (content) {
-    eval("HUD.console.log(" + consoleTest + ")");
+    eval("content.console.log(" + consoleTest + ")");
   }
 
   waitForSuccess({
     name: "console.log message for test #" + cpos,
     validatorFn: function()
     {
       return HUD.outputNode.querySelector(".hud-log");
     },
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601352_scroll.js
@@ -12,23 +12,23 @@ function consoleOpened(HUD) {
   HUD.jsterm.clearOutput();
 
   let longMessage = "";
   for (let i = 0; i < 50; i++) {
     longMessage += "LongNonwrappingMessage";
   }
 
   for (let i = 0; i < 50; i++) {
-    HUD.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
-  HUD.console.log(longMessage);
+  content.console.log(longMessage);
 
   for (let i = 0; i < 50; i++) {
-    HUD.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
   HUD.jsterm.execute("1+1");
 
   function performTest() {
     let scrollBox = HUD.outputNode.scrollBoxObject.element;
     isnot(scrollBox.scrollTop, 0, "scroll location is not at the top");
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
@@ -14,17 +14,17 @@ function testNext() {
 }
 
 function testGen() {
   hud.jsterm.clearOutput();
   let outputNode = hud.outputNode;
   let scrollBox = outputNode.scrollBoxObject.element;
 
   for (let i = 0; i < 150; i++) {
-    hud.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
   waitForSuccess({
     name: "150 console.log messages displayed",
     validatorFn: function()
     {
       return outputNode.querySelectorAll(".hud-log").length == 150;
     },
@@ -41,17 +41,17 @@ function testGen() {
   outputNode.focus();
 
   EventUtils.synthesizeKey("VK_HOME", {});
 
   let topPosition = scrollBox.scrollTop;
   isnot(topPosition, oldScrollTop, "scroll location updated (moved to top)");
 
   // add a message and make sure scroll doesn't change
-  hud.console.log("test message 150");
+  content.console.log("test message 150");
 
   waitForSuccess({
     name: "console.log message no. 151 displayed",
     validatorFn: function()
     {
       return outputNode.querySelectorAll(".hud-log").length == 151;
     },
     successFn: testNext,
@@ -63,17 +63,17 @@ function testGen() {
   is(scrollBox.scrollTop, topPosition, "scroll location is still at the top");
 
   // scroll back to the bottom
   outputNode.lastChild.focus();
   EventUtils.synthesizeKey("VK_END", {});
 
   oldScrollTop = outputNode.scrollTop;
 
-  hud.console.log("test message 151");
+  content.console.log("test message 151");
 
   waitForSuccess({
     name: "console.log message no. 152 displayed",
     validatorFn: function()
     {
       return outputNode.querySelectorAll(".hud-log").length == 152;
     },
     successFn: testNext,
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
@@ -19,17 +19,17 @@ function testGen() {
   let outputNode = hud.outputNode;
   let oldPref = Services.prefs.getIntPref("devtools.hud.loglimit.console");
 
   Services.prefs.setIntPref("devtools.hud.loglimit.console", 140);
   let scrollBoxElement = outputNode.scrollBoxObject.element;
   let boxObject = outputNode.scrollBoxObject;
 
   for (let i = 0; i < 150; i++) {
-    hud.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
   waitForSuccess({
     name: "150 console.log messages displayed",
     validatorFn: function()
     {
       return outputNode.querySelectorAll(".hud-log").length == 140;
     },
@@ -52,17 +52,17 @@ function testGen() {
   boxObject.ensureElementIsVisible(msgNode);
 
   isnot(scrollBoxElement.scrollTop, oldScrollTop,
         "scroll location updated (scrolled to message)");
 
   oldScrollTop = scrollBoxElement.scrollTop;
 
   // add a message
-  hud.console.log("hello world");
+  content.console.log("hello world");
 
   waitForSuccess({
     name: "console.log message #151 displayed",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("hello world") > -1;
     },
     successFn: testNext,
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
@@ -9,17 +9,17 @@
 
 function consoleOpened(hud) {
   hud.jsterm.clearOutput();
 
   let outputNode = hud.outputNode;
   let boxObject = outputNode.scrollBoxObject.element;
 
   for (let i = 0; i < 150; i++) {
-    hud.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
   waitForSuccess({
     name: "console.log messages displayed",
     validatorFn: function()
     {
       return outputNode.itemCount == 150;
     },
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
@@ -47,17 +47,17 @@ function testWebDevLimits(aEvent) {
     successFn: testWebDevLimits2,
     failureFn: testWebDevLimits2,
   });
 }
 
 function testWebDevLimits2() {
   // Fill the log with Web Developer errors.
   for (let i = 0; i < 11; i++) {
-    hud.console.log("test message " + i);
+    content.console.log("test message " + i);
   }
 
   waitForSuccess({
     name: "11 console.log messages displayed",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("test message 10") > -1;
     },
@@ -75,17 +75,17 @@ function testWebDevLimits2() {
   });
 }
 
 function testJsLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.exception");
   Services.prefs.setIntPref("devtools.hud.loglimit.exception", 10);
 
   hud.jsterm.clearOutput();
-  hud.console.log("testing JS limits");
+  content.console.log("testing JS limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing JS limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing JS limits") > -1;
     },
@@ -126,17 +126,17 @@ function testJsLimits2() {
 
 var gCounter, gImage;
 
 function testNetLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.network");
   Services.prefs.setIntPref("devtools.hud.loglimit.network", 10);
 
   hud.jsterm.clearOutput();
-  hud.console.log("testing Net limits");
+  content.console.log("testing Net limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing Net limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing Net limits") > -1;
     },
@@ -171,17 +171,17 @@ function loadImage() {
   testCssLimits();
 }
 
 function testCssLimits() {
   gOldPref = Services.prefs.getIntPref("devtools.hud.loglimit.cssparser");
   Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", 10);
 
   hud.jsterm.clearOutput();
-  hud.console.log("testing CSS limits");
+  content.console.log("testing CSS limits");
 
   // Find the sentinel entry.
   waitForSuccess({
     name: "console.log 'testing CSS limits'",
     validatorFn: function()
     {
       return outputNode.textContent.indexOf("testing CSS limits") > -1;
     },
diff --git a/browser/devtools/webconsole/test/browser_webconsole_consoleonpage.js b/browser/devtools/webconsole/test/browser_webconsole_consoleonpage.js
deleted file mode 100644
--- a/browser/devtools/webconsole/test/browser_webconsole_consoleonpage.js
+++ /dev/null
@@ -1,47 +0,0 @@
-/* vim:set ts=2 sw=2 sts=2 et: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/
- *
- * Contributor(s):
- *  Julian Viereck <jviereck@mozilla.com>
- *  Mihai Șucan <mihai.sucan@gmail.com>
- *
- * ***** END LICENSE BLOCK ***** */
-
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-own-console.html";
-
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testOpenWebConsole);
-  }, true);
-}
-
-function testOpenWebConsole(aHud)
-{
-  hud = aHud;
-  ok(hud, "WebConsole was opened");
-
-  testOwnConsole();
-}
-
-function testConsoleOnPage(console) {
-  isnot(console, undefined, "Console object defined on page");
-  is(console.foo, "bar", "Custom console is not overwritten");
-}
-
-function testOwnConsole()
-{
-  let console = browser.contentWindow.wrappedJSObject.console;
-  // Test console on the page. There is already one so it shouldn't be
-  // overwritten by the WebConsole's console.
-  testConsoleOnPage(console);
-
-  // Check that the console object is set on the HUD object although there
-  // is no console object added to the page.
-  ok(hud.console, "HUD console is defined");
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_hud_getters.js b/browser/devtools/webconsole/test/browser_webconsole_hud_getters.js
deleted file mode 100644
--- a/browser/devtools/webconsole/test/browser_webconsole_hud_getters.js
+++ /dev/null
@@ -1,33 +0,0 @@
-/* vim:set ts=2 sw=2 sts=2 et: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// Tests that the HUD can be accessed via the HUD references in the HUD
-// service.
-
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testHUDGetters, false);
-}
-
-function testHUDGetters() {
-  browser.removeEventListener("DOMContentLoaded", testHUDGetters, false);
-
-  openConsole();
-
-  var HUD = HUDService.getHudByWindow(content);
-  var jsterm = HUD.jsterm;
-  var klass = jsterm.inputNode.getAttribute("class");
-  ok(klass == "jsterm-input-node", "We have the input node.");
-
-  var hudconsole = HUD.console;
-  is(typeof hudconsole, "object", "HUD.console is an object");
-  is(typeof hudconsole.log, "function", "HUD.console.log is a function");
-  is(typeof hudconsole.info, "function", "HUD.console.info is a function");
-
-  finishTest();
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_registries.js b/browser/devtools/webconsole/test/browser_webconsole_registries.js
deleted file mode 100644
--- a/browser/devtools/webconsole/test/browser_webconsole_registries.js
+++ /dev/null
@@ -1,30 +0,0 @@
-/* vim:set ts=2 sw=2 sts=2 et: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// Tests that the HUD service keeps an accurate registry of all the Web Console
-// instances.
-
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testRegistries, false);
-}
-
-function testRegistries() {
-  browser.removeEventListener("DOMContentLoaded", testRegistries, false);
-
-  openConsole();
-
-  let hud = HUDService.getHudByWindow(content);
-  ok(hud, "we have a HUD");
-  ok(HUDService.hudReferences[hud.hudId], "we have a HUD in hudReferences");
-
-  let windowID = WebConsoleUtils.getOuterWindowId(content);
-  is(HUDService.windowIds[windowID], hud.hudId, "windowIds are working");
-
-  finishTest();
-}
-
