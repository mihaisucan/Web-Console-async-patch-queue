# HG changeset patch
# Parent e8c0efdeeb3dab6b436dbddf6281e77df86f6b56
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1337371762 -10800

Bug 673148 - (async-webconsole) Part 5 - HUDService.jsm cleanup

diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
--- a/browser/devtools/webconsole/HUDService-content.js
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -256,16 +256,18 @@ let Manager = {
    * Supported features:
    *    - JSTerm - a JavaScript "terminal" which allows code execution.
    *    - ConsoleAPI - support for routing the window.console API to the remote
    *    process.
    *    - PageError - route all the nsIScriptErrors from the nsIConsoleService
    *    to the remote process.
    *    - NetworkMonitor - log all the network activity and send HAR-like
    *    messages to the remote Web Console process.
+   *    - LocationChange - log page location changes. See
+   *    ConsoleProgressListener.
    *
    * @param string aFeature
    *        One of the supported features.
    * @param object [aMessage]
    *        Optional JSON message object coming from the remote Web Console
    *        instance. This can be used for feature-specific options.
    */
   enableFeature: function Manager_enableFeature(aFeature, aMessage)
@@ -282,16 +284,21 @@ let Manager = {
         ConsoleAPIObserver.init(aMessage);
         break;
       case "PageError":
         ConsoleListener.init(aMessage);
         break;
       case "NetworkMonitor":
         NetworkMonitor.init(aMessage);
         break;
+      case "LocationChange":
+        ConsoleProgressListener.startMonitor(ConsoleProgressListener
+                                             .MONITOR_LOCATION_CHANGE);
+        ConsoleProgressListener.sendNewLocation();
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
 
     this._enabledFeatures.push(aFeature);
   },
 
@@ -319,16 +326,20 @@ let Manager = {
         ConsoleAPIObserver.destroy();
         break;
       case "PageError":
         ConsoleListener.destroy();
         break;
       case "NetworkMonitor":
         NetworkMonitor.destroy();
         break;
+      case "LocationChange":
+        ConsoleProgressListener.stopMonitor(ConsoleProgressListener
+                                            .MONITOR_LOCATION_CHANGE);
+        break;
       default:
         Cu.reportError("Web Console content: unknown feature " + aFeature);
         break;
     }
   },
 
   /**
    * Handle the "WebConsole:GetPreferences" messages from the remote Web Console
@@ -1647,20 +1658,18 @@ let NetworkMonitor = {
 
     activityDistributor.addObserver(this);
 
     Services.obs.addObserver(this.httpResponseExaminer,
                              "http-on-examine-response", false);
 
     // Monitor file:// activity as well.
     if (aMessage && aMessage.monitorFileActivity) {
-      let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
-      this.progressListener = new ConsoleProgressListener();
-      webProgress.addProgressListener(this.progressListener,
-        Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+      ConsoleProgressListener.startMonitor(ConsoleProgressListener
+                                           .MONITOR_FILE_ACTIVITY);
     }
   },
 
   /**
    * Observe notifications for the http-on-examine-response topic, coming from
    * the nsIObserverService.
    *
    * @param nsIHttpChannel aSubject
@@ -2197,45 +2206,127 @@ let NetworkMonitor = {
    */
   destroy: function NM_destroy()
   {
     Services.obs.removeObserver(this.httpResponseExaminer,
                                 "http-on-examine-response");
 
     activityDistributor.removeObserver(this);
 
-    if (this.progressListener) {
-      let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
-      webProgress.removeProgressListener(this.progressListener);
-      delete this.progressListener;
-    }
+    ConsoleProgressListener.stopMonitor(ConsoleProgressListener
+                                        .MONITOR_FILE_ACTIVITY);
 
     delete this.openRequests;
     delete this.openResponses;
   },
 };
 
 /**
- * A WebProgressListener that listens for location changes. This progress
- * listener is used to track file loads. When a file:// URI is loaded
- * a "WebConsole:FileActivity" message is sent to the remote Web Console
- * instance. The message JSON holds only one property: uri (the file URI).
+ * A WebProgressListener that listens for location changes.
  *
- * @constructor
+ * This progress listener is used to track file loads and other kinds of
+ * location changes.
+ *
+ * When a file:// URI is loaded a "WebConsole:FileActivity" message is sent to
+ * the remote Web Console instance. The message JSON holds only one property:
+ * uri (the file URI).
+ *
+ * When the current page location changes a "WebConsole:LocationChange" message
+ * is sent. The object holds two properties: location (full URL of the new
+ * document that loaded) and title (document title).
  */
-function ConsoleProgressListener() { }
+let ConsoleProgressListener = {
+  MONITOR_FILE_ACTIVITY: 1,
+  MONITOR_LOCATION_CHANGE: 2,
 
-ConsoleProgressListener.prototype = {
+  /**
+   * Tells if you want to monitor file activity.
+   * @private
+   * @type boolean
+   */
+  _fileActivity: false,
+
+  /**
+   * Tells if you want to monitor location changes.
+   * @private
+   * @type boolean
+   */
+  _locationChange: false,
+
+  _initialized: false,
+
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
                                          Ci.nsISupportsWeakReference]),
 
-  onStateChange: function CPL_onStateChange(aProgress, aRequest, aState,
-                                            aStatus)
+  _init: function CPL__init()
   {
-    if (!_alive || !(aState & Ci.nsIWebProgressListener.STATE_START)) {
+    if (this._initialized) {
+      return;
+    }
+
+    this._initialized = true;
+    let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.addProgressListener(this, Ci.nsIWebProgress.NOTIFY_STATE_ALL);
+  },
+
+  startMonitor: function CPL_startMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = true;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = true;
+        break;
+      default:
+        throw new Error("HUDService-content: unknown monitor type " +
+                        aMonitor + " for the ConsoleProgressListener!");
+    }
+    this._init();
+  },
+
+  stopMonitor: function CPL_stopMonitor(aMonitor)
+  {
+    switch (aMonitor) {
+      case this.MONITOR_FILE_ACTIVITY:
+        this._fileActivity = false;
+        break;
+      case this.MONITOR_LOCATION_CHANGE:
+        this._locationChange = false;
+        break;
+      default:
+        throw new Error("HUDService-content: unknown monitor type " +
+                        aMonitor + " for the ConsoleProgressListener!");
+    }
+
+    if (!this._fileActivity && !this._locationChange) {
+      this.destroy();
+    }
+  },
+
+  onStateChange:
+  function CPL_onStateChange(aProgress, aRequest, aState, aStatus)
+  {
+    if (!_alive) {
+      return;
+    }
+
+    if (this._fileActivity) {
+      this._checkFileActivity(aProgress, aRequest, aState, aStatus);
+    }
+
+    if (this._locationChange) {
+      this._checkLocationChange(aProgress, aRequest, aState, aStatus);
+    }
+  },
+
+  _checkFileActivity:
+  function CPL__checkFileActivity(aProgress, aRequest, aState, aStatus)
+  {
+    if (!(aState & Ci.nsIWebProgressListener.STATE_START)) {
       return;
     }
 
     let uri = null;
     if (aRequest instanceof Ci.imgIRequest) {
       let imgIRequest = aRequest.QueryInterface(Ci.imgIRequest);
       uri = imgIRequest.URI;
     }
@@ -2246,16 +2337,54 @@ ConsoleProgressListener.prototype = {
 
     if (!uri || !uri.schemeIs("file") && !uri.schemeIs("ftp")) {
       return;
     }
 
     Manager.sendMessage("WebConsole:FileActivity", {uri: uri.spec});
   },
 
+  _checkLocationChange:
+  function CPL__checkLocationChange(aProgress, aRequest, aState, aStatus)
+  {
+    let isStop = aState & Ci.nsIWebProgressListener.STATE_STOP;
+    let isNetwork = aState & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
+    let isWindow = aState & Ci.nsIWebProgressListener.STATE_IS_WINDOW;
+
+    // Skip non-interesting states.
+    if (!isStop || !isNetwork || !isWindow ||
+        aProgress.DOMWindow != Manager.window) {
+      return;
+    }
+
+    this.sendNewLocation();
+  },
+
   onLocationChange: function() {},
   onStatusChange: function() {},
   onProgressChange: function() {},
   onSecurityChange: function() {},
+
+  sendNewLocation: function CPL_sendNewLocation()
+  {
+    let message = {
+      "location": Manager.window.location.href,
+      "title": Manager.window.document.title,
+    };
+    Manager.sendMessage("WebConsole:LocationChange", message);
+  },
+
+  destroy: function CPL_destroy()
+  {
+    if (!this._initialized) {
+      return;
+    }
+
+    this._initialized = false;
+    this._fileActivity = false;
+    this._locationChange = false;
+    let webProgress = docShell.QueryInterface(Ci.nsIWebProgress);
+    webProgress.removeProgressListener(this);
+  },
 };
 
 Manager.init();
 })();
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -55,48 +55,25 @@ Cu.import("resource://gre/modules/XPCOMU
 Cu.import("resource://gre/modules/Services.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 
-XPCOMUtils.defineLazyGetter(this, "gcli", function () {
-  var obj = {};
-  Cu.import("resource:///modules/gcli.jsm", obj);
-  return obj.gcli;
-});
-
-XPCOMUtils.defineLazyGetter(this, "template", function () {
-  var obj = {};
-  Cu.import("resource:///modules/devtools/Templater.jsm", obj);
-  return obj.template;
-});
-
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyPanel",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PropertyTreeView",
                                   "resource:///modules/PropertyPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AutocompletePopup",
                                   "resource:///modules/AutocompletePopup.jsm");
 
-XPCOMUtils.defineLazyGetter(this, "ScratchpadManager", function () {
-  var obj = {};
-  try {
-    Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", obj);
-  }
-  catch (err) {
-    Cu.reportError(err);
-  }
-  return obj.ScratchpadManager;
-});
-
 XPCOMUtils.defineLazyModuleGetter(this, "NetworkPanel",
                                   "resource:///modules/NetworkPanel.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "WebConsoleUtils",
                                   "resource:///modules/WebConsoleUtils.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "l10n", function() {
   return WebConsoleUtils.l10n;
@@ -336,46 +313,25 @@ function pruneConsoleOutputIfNecessary(a
   return logLimit;
 }
 
 ///////////////////////////////////////////////////////////////////////////
 //// The HUD service
 
 function HUD_SERVICE()
 {
-  // TODO: provide mixins for FENNEC: bug 568621
-  if (appName() == "FIREFOX") {
-    var mixins = new FirefoxApplicationHooks();
-  }
-  else {
-    throw new Error("Unsupported Application");
-  }
-
-  this.mixins = mixins;
-
   // These methods access the "this" object, but they're registered as
   // event listeners. So we hammer in the "this" binding.
   this.onTabClose = this.onTabClose.bind(this);
   this.onWindowUnload = this.onWindowUnload.bind(this);
 
   // Remembers the last console height, in pixels.
   this.lastConsoleHeight = Services.prefs.getIntPref("devtools.hud.height");
 
   /**
-   * Collection of HUDIds that map to the tabs/windows/contexts
-   * that a HeadsUpDisplay can be activated for.
-   */
-  this.activatedContexts = [];
-
-  /**
-   * Collection of outer window IDs mapping to HUD IDs.
-   */
-  this.windowIds = {};
-
-  /**
    * Each HeadsUpDisplay has a set of filter preferences
    */
   this.filterPrefs = {};
 
   /**
    * Keeps a reference for each HeadsUpDisplay that is created
    */
   this.hudReferences = {};
@@ -394,158 +350,98 @@ HUD_SERVICE.prototype =
 
   /**
    * The sequencer is a generator (after initialization) that returns unique
    * integers
    */
   sequencer: null,
 
   /**
-   * Tell the HUDService that a HeadsUpDisplay can be activated
-   * for the window or context that has 'aContextDOMId' node id
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  registerActiveContext: function HS_registerActiveContext(aContextDOMId)
-  {
-    this.activatedContexts.push(aContextDOMId);
-  },
-
-  /**
    * Firefox-specific current tab getter
    *
    * @returns nsIDOMWindow
    */
   currentContext: function HS_currentContext() {
-    return this.mixins.getCurrentContext();
-  },
-
-  /**
-   * Tell the HUDService that a HeadsUpDisplay should be deactivated
-   *
-   * @param string aContextDOMId
-   * @return void
-   */
-  unregisterActiveContext: function HS_deregisterActiveContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    var idx = this.activatedContexts.indexOf(domId);
-    if (idx > -1) {
-      this.activatedContexts.splice(idx, 1);
-    }
-  },
-
-  /**
-   * Tells callers that a HeadsUpDisplay can be activated for the context
-   *
-   * @param string aContextDOMId
-   * @return boolean
-   */
-  canActivateContext: function HS_canActivateContext(aContextDOMId)
-  {
-    var domId = aContextDOMId.split("_")[1];
-    for (var idx in this.activatedContexts) {
-      if (this.activatedContexts[idx] == domId){
-        return true;
-      }
-    }
-    return false;
+    return Services.wm.getMostRecentWindow("navigator:browser");
   },
 
   /**
    * Activate a HeadsUpDisplay for the given tab context.
    *
-   * @param Element aContext the tab element.
-   * @param boolean aAnimated animate opening the Web Console?
-   * @returns void
+   * @param nsIDOMElement aTab
+   *        The xul:tab element.
+   * @param boolean aAnimated
+   *        True if you want to animate the opening of the Web console.
+   * @return object
+   *         The new HeadsUpDisplay instance.
    */
-  activateHUDForContext: function HS_activateHUDForContext(aContext, aAnimated)
+  activateHUDForContext: function HS_activateHUDForContext(aTab, aAnimated)
   {
     this.wakeup();
 
-    let window = aContext.linkedBrowser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    this.registerActiveContext(nBox.id);
-    this.windowInitializer(window);
-
-    let hudId = "hud_" + nBox.id;
+    let hudId = "hud_" + aTab.linkedPanel;
     let hudRef = this.hudReferences[hudId];
-
-    if (!aAnimated || hudRef.consolePanel) {
+    let window = aTab.ownerDocument.defaultView;
+    let gBrowser = window.gBrowser;
+
+    // TODO: check that this works as intended
+    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
+    window.addEventListener("unload", this.onWindowUnload, false);
+
+    this.registerDisplay(hudId);
+
+    let hud = new HeadsUpDisplay(aTab);
+    this.hudReferences[hudId] = hud;
+
+    // FIXME: Need to detect that the console component has been paved over.
+    //let consoleObject = WebConsoleUtils.unwrap(aContentWindow).console;
+    //if (!("__mozillaConsole__" in consoleObject))
+    //  this.logWarningAboutReplacedAPI(hudId);
+
+    // register the controller to handle "select all" properly
+    this.createController(window);
+
+    if (!aAnimated || hud.consolePanel) {
       this.disableAnimation(hudId);
     }
 
-    // Create a processing instruction for GCLIs CSS stylesheet, but only if
-    // we don't have one for this document. Also record the context we're
-    // adding this for so we know when to remove it.
-    let procInstr = aContext.ownerDocument.gcliCssProcInstr;
-    if (!procInstr) {
-      procInstr = aContext.ownerDocument.createProcessingInstruction(
-              "xml-stylesheet",
-              "href='chrome://browser/skin/devtools/gcli.css' type='text/css'");
-      procInstr.contexts = [];
-
-      let root = aContext.ownerDocument.getElementsByTagName('window')[0];
-      root.parentNode.insertBefore(procInstr, root);
-      aContext.ownerDocument.gcliCssProcInstr = procInstr;
-    }
-    if (procInstr.contexts.indexOf(hudId) == -1) {
-      procInstr.contexts.push(hudId);
-    }
     HeadsUpDisplayUICommands.refreshCommand();
+
+    return hud;
   },
 
   /**
    * Deactivate a HeadsUpDisplay for the given tab context.
    *
-   * @param nsIDOMWindow aContext
-   * @param aAnimated animate closing the web console?
-   * @returns void
+   * @param nsIDOMElement aTab
+   *        The xul:tab element you want to enable the Web Console for.
+   * @param boolean aAnimated
+   *        True if you want to animate the closing of the Web console.
+   * @return void
    */
-  deactivateHUDForContext: function HS_deactivateHUDForContext(aContext, aAnimated)
+  deactivateHUDForContext: function HS_deactivateHUDForContext(aTab, aAnimated)
   {
-    let browser = aContext.linkedBrowser;
-    let window = browser.contentWindow;
-    let chromeDocument = aContext.ownerDocument;
-    let nBox = chromeDocument.defaultView.getNotificationBox(window);
-    let hudId = "hud_" + nBox.id;
-    let displayNode = chromeDocument.getElementById(hudId);
-    let hudFound = (hudId in this.hudReferences) && displayNode;
-
-    if (hudFound) {
-      if (!aAnimated) {
-        this.storeHeight(hudId);
-      }
-
-      this.unregisterDisplay(hudId);
-
-      window.focus();
-      HeadsUpDisplayUICommands.refreshCommand();
+    let hudId = "hud_" + aTab.linkedPanel;
+    if (!(hudId in this.hudReferences)) {
+      return;
     }
 
-    // Remove this context from the list of contexts that need the GCLI CSS
-    // processing instruction and then remove the processing instruction if it
-    // isn't needed any more.
-    let procInstr = aContext.ownerDocument.gcliCssProcInstr;
-    if (procInstr) {
-      procInstr.contexts = procInstr.contexts.filter(function(id) {
-        return id !== hudId;
-      });
-      if (procInstr.contexts.length == 0 && procInstr.parentNode) {
-        procInstr.parentNode.removeChild(procInstr);
-        delete aContext.ownerDocument.gcliCssProcInstr;
-      }
+    if (!aAnimated) {
+      this.storeHeight(hudId);
     }
 
-    if (hudFound) {
-      let id = WebConsoleUtils.supportsString(hudId);
-      Services.obs.notifyObservers(id, "web-console-destroyed", null);
-    }
+    this.unregisterDisplay(hudId);
+
+    let contentWindow = aTab.linkedBrowser.contentWindow;
+    contentWindow.focus();
+
+    HeadsUpDisplayUICommands.refreshCommand();
+
+    let id = WebConsoleUtils.supportsString(hudId);
+    Services.obs.notifyObservers(id, "web-console-destroyed", null);
   },
 
   /**
    * get a unique ID from the sequence generator
    *
    * @returns integer
    */
   sequenceId: function HS_sequencerId()
@@ -734,25 +630,16 @@ HUD_SERVICE.prototype =
         node.classList.add("hud-filtered-by-string");
       }
     }
 
     this.regroupOutput(outputNode);
   },
 
   /**
-   * Register a reference of each HeadsUpDisplay that is created
-   */
-  registerHUDReference:
-  function HS_registerHUDReference(aHUD)
-  {
-    this.hudReferences[aHUD.hudId] = aHUD;
-  },
-
-  /**
    * Register a new Heads Up Display
    *
    * @returns void
    */
   registerDisplay: function HS_registerDisplay(aHUDId)
   {
     // register a display DOM node Id with the service.
     if (!aHUDId){
@@ -781,19 +668,16 @@ HUD_SERVICE.prototype =
    */
   unregisterDisplay: function HS_unregisterDisplay(aHUDId)
   {
     let hud = this.getHudReferenceById(aHUDId);
 
     // Remove children from the output. If the output is not cleared, there can
     // be leaks as some nodes has node.onclick = function; set and GC can't
     // remove the nodes then.
-    if (hud.gcliterm) {
-      hud.gcliterm.clearOutput();
-    }
 
     let document = hud.chromeDocument;
 
     let popupset = document.getElementById("mainPopupSet");
     let panels = popupset.querySelectorAll("panel[hudId=" + aHUDId + "]");
     for (let i = 0; i < panels.length; i++) {
       panels[i].hidePopup();
     }
@@ -815,24 +699,16 @@ HUD_SERVICE.prototype =
     hud.HUDBox.parentNode.removeChild(hud.HUDBox);
 
     if (hud.splitter.parentNode) {
       hud.splitter.parentNode.removeChild(hud.splitter);
     }
 
     delete this.hudReferences[aHUDId];
 
-    for (let windowID in this.windowIds) {
-      if (this.windowIds[windowID] == aHUDId) {
-        delete this.windowIds[windowID];
-      }
-    }
-
-    this.unregisterActiveContext(aHUDId);
-
     if (Object.keys(this.hudReferences).length == 0) {
       let autocompletePopup = document.
                               getElementById("webConsole_autocompletePopup");
       if (autocompletePopup) {
         autocompletePopup.parentNode.removeChild(autocompletePopup);
       }
 
       this.suspend();
@@ -864,33 +740,34 @@ HUD_SERVICE.prototype =
   {
     delete this.defaultFilterPrefs;
     delete this.lastFinishedRequestCallback;
 
     WebConsoleObserver.uninit();
   },
 
   /**
-   * Shutdown all HeadsUpDisplays on xpcom-shutdown
+   * Shutdown all HeadsUpDisplays on quit-application-granted.
    *
    * @returns void
    */
   shutdown: function HS_shutdown()
   {
-    for (let hudId in this.hudReferences) {
-      this.deactivateHUDForContext(this.hudReferences[hudId].tab, false);
+    for (let hud of this.hudReferences) {
+      this.deactivateHUDForContext(hud.tab, false);
     }
   },
 
   /**
    * Returns the HeadsUpDisplay object associated to a content window.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns object
    */
+  // FIXME; this no longer works!
   getHudByWindow: function HS_getHudByWindow(aContentWindow)
   {
     let hudId = this.getHudIdByWindow(aContentWindow);
     return hudId ? this.hudReferences[hudId] : null;
   },
 
   /**
    * Returns the hudId that is corresponding to the hud activated for the
@@ -1096,123 +973,25 @@ HUD_SERVICE.prototype =
 
     if (window.webConsoleCommandController) {
       window.controllers.removeController(window.webConsoleCommandController);
       window.webConsoleCommandController = null;
     }
   },
 
   /**
-   * windowInitializer - checks what Gecko app is running and inits the HUD
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  windowInitializer: function HS_WindowInitalizer(aContentWindow)
-  {
-    var xulWindow = aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-      .getInterface(Ci.nsIWebNavigation)
-                      .QueryInterface(Ci.nsIDocShell)
-                      .chromeEventHandler.ownerDocument.defaultView;
-
-    let xulWindow = WebConsoleUtils.unwrap(xulWindow);
-
-    let docElem = xulWindow.document.documentElement;
-    if (!docElem || docElem.getAttribute("windowtype") != "navigator:browser" ||
-        !xulWindow.gBrowser) {
-      // Do not do anything unless we have a browser window.
-      // This may be a view-source window or other type of non-browser window.
-      return;
-    }
-
-    let gBrowser = xulWindow.gBrowser;
-
-    let _browser = gBrowser.
-      getBrowserForDocument(aContentWindow.top.document);
-
-    // ignore newly created documents that don't belong to a tab's browser
-    if (!_browser) {
-      return;
-    }
-
-    let nBox = gBrowser.getNotificationBox(_browser);
-    let nBoxId = nBox.getAttribute("id");
-    let hudId = "hud_" + nBoxId;
-    let windowUI = nBox.ownerDocument.getElementById("console_window_" + hudId);
-    if (windowUI) {
-      // The Web Console popup is already open, no need to continue.
-      if (aContentWindow == aContentWindow.top) {
-        let hud = this.hudReferences[hudId];
-        hud.reattachConsole(aContentWindow);
-      }
-      return;
-    }
-
-    if (!this.canActivateContext(hudId)) {
-      return;
-    }
-
-    xulWindow.addEventListener("unload", this.onWindowUnload, false);
-    gBrowser.tabContainer.addEventListener("TabClose", this.onTabClose, false);
-
-    this.registerDisplay(hudId);
-
-    let hudNode;
-    let childNodes = nBox.childNodes;
-
-    for (let i = 0; i < childNodes.length; i++) {
-      let id = childNodes[i].getAttribute("id");
-      // `id` is a string with the format "hud_<number>".
-      if (id.split("_")[0] == "hud") {
-        hudNode = childNodes[i];
-        break;
-      }
-    }
-
-    let hud;
-    // If there is no HUD for this tab create a new one.
-    if (!hudNode) {
-      // get nBox object and call new HUD
-      let config = { parentNode: nBox,
-                     contentWindow: aContentWindow.top
-                   };
-
-      hud = new HeadsUpDisplay(config);
-
-      HUDService.registerHUDReference(hud);
-      let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow.top);
-      this.windowIds[windowId] = hudId;
-    }
-    else {
-      hud = this.hudReferences[hudId];
-      if (aContentWindow == aContentWindow.top) {
-        // TODO: name change?? doesn't actually re-attach the console
-        hud.reattachConsole(aContentWindow);
-      }
-    }
-
-    // Need to detect that the console component has been paved over.
-    let consoleObject = WebConsoleUtils.unwrap(aContentWindow).console;
-    if (!("__mozillaConsole__" in consoleObject))
-      this.logWarningAboutReplacedAPI(hudId);
-
-    // register the controller to handle "select all" properly
-    this.createController(xulWindow);
-  },
-
-  /**
    * Adds the command controller to the XUL window if it's not already present.
    *
    * @param nsIDOMWindow aWindow
    *        The browser XUL window.
    * @returns void
    */
-  createController: function HUD_createController(aWindow)
+  createController: function HS_createController(aWindow)
   {
-    if (aWindow.webConsoleCommandController == null) {
+    if (!aWindow.webConsoleCommandController) {
       aWindow.webConsoleCommandController = new CommandController(aWindow);
       aWindow.controllers.insertControllerAt(0,
         aWindow.webConsoleCommandController);
     }
   },
 
   /**
    * Animates the Console appropriately.
@@ -1267,18 +1046,18 @@ HUD_SERVICE.prototype =
   /**
    * Reset the height of the Web Console.
    *
    * @param string aHUDId The ID of the Web Console.
    */
   resetHeight: function HS_resetHeight(aHUDId)
   {
     let HUD = this.hudReferences[aHUDId];
-    let innerHeight = HUD.contentWindow.innerHeight;
-    let chromeWindow = HUD.chromeDocument.defaultView;
+    let innerHeight = HUD.browser.innerHeight;
+    let chromeWindow = HUD.chromeWindow;
     if (!HUD.consolePanel) {
       let splitterStyle = chromeWindow.getComputedStyle(HUD.splitter, null);
       innerHeight += parseInt(splitterStyle.height) +
                      parseInt(splitterStyle.borderTopWidth) +
                      parseInt(splitterStyle.borderBottomWidth);
     }
 
     let boxStyle = chromeWindow.getComputedStyle(HUD.HUDBox, null);
@@ -1363,129 +1142,44 @@ HUD_SERVICE.prototype =
     clipboardHelper.copyString(strings.join("\n"));
   }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplay
 //////////////////////////////////////////////////////////////////////////
 
-/*
+/**
  * HeadsUpDisplay is an interactive console initialized *per tab*  that
  * displays console log data as well as provides an interactive terminal to
  * manipulate the current tab's document content.
- * */
-function HeadsUpDisplay(aConfig)
+ *
+ * @param nsIDOMElement aTab
+ *        The xul:tab for which you want the HeadsUpDisplay object.
+ */
+function HeadsUpDisplay(aTab)
 {
-  // sample config: { parentNode: aDOMNode,
-  //                  // or
-  //                  parentNodeId: "myHUDParent123",
-  //
-  //                  placement: "appendChild"
-  //                  // or
-  //                  placement: "insertBefore",
-  //                  placementChildNodeIndex: 0,
-  //                }
-
-  this.HUDBox = null;
-
-  if (aConfig.parentNode) {
-    // TODO: need to replace these DOM calls with internal functions
-    // that operate on each application's node structure
-    // better yet, we keep these functions in a "bridgeModule" or the HUDService
-    // to keep a registry of nodeGetters for each application
-    // see bug 568647
-    this.parentNode = aConfig.parentNode;
-    this.notificationBox = aConfig.parentNode;
-    this.chromeDocument = aConfig.parentNode.ownerDocument;
-    this.contentWindow = aConfig.contentWindow;
-    this.uriSpec = aConfig.contentWindow.location.href;
-    this.hudId = "hud_" + aConfig.parentNode.getAttribute("id");
-  }
-  else {
-    // parentNodeId is the node's id where we attach the HUD
-    // TODO: is the "navigator:browser" below used in all Gecko Apps?
-    // see bug 568647
-    let windowEnum = Services.wm.getEnumerator("navigator:browser");
-    let parentNode;
-    let contentDocument;
-    let contentWindow;
-    let chromeDocument;
-
-    // TODO: the following  part is still very Firefox specific
-    // see bug 568647
-
-    while (windowEnum.hasMoreElements()) {
-      let window = windowEnum.getNext();
-      try {
-        let gBrowser = window.gBrowser;
-        let _browsers = gBrowser.browsers;
-        let browserLen = _browsers.length;
-
-        for (var i = 0; i < browserLen; i++) {
-          var _notificationBox = gBrowser.getNotificationBox(_browsers[i]);
-          this.notificationBox = _notificationBox;
-
-          if (_notificationBox.getAttribute("id") == aConfig.parentNodeId) {
-            this.parentNodeId = _notificationBox.getAttribute("id");
-            this.hudId = "hud_" + this.parentNodeId;
-
-            parentNode = _notificationBox;
-
-            this.contentDocument =
-              _notificationBox.childNodes[0].contentDocument;
-            this.contentWindow =
-              _notificationBox.childNodes[0].contentWindow;
-            this.uriSpec = aConfig.contentWindow.location.href;
-
-            this.chromeDocument =
-              _notificationBox.ownerDocument;
-
-            break;
-          }
-        }
-      }
-      catch (ex) {
-        Cu.reportError(ex);
-      }
-
-      if (parentNode) {
-        break;
-      }
-    }
-    if (!parentNode) {
-      throw new Error(this.ERRORS.PARENTNODE_NOT_FOUND);
-    }
-    this.parentNode = parentNode;
-    this.notificationBox = parentNode;
-  }
-
-  // create textNode Factory:
-  this.textFactory = NodeFactory("text", "xul", this.chromeDocument);
-
+  this.tab = aTab;
+  this.hudId = "hud_" + this.tab.linkedPanel;
+  this.chromeDocument = this.tab.ownerDocument;
   this.chromeWindow = this.chromeDocument.defaultView;
+  this.notificationBox = this.chromeDocument.getElementById(this.tab.linkedPanel);
   this.browser = this.tab.linkedBrowser;
   this.messageManager = this.browser.messageManager;
 
   // Track callback functions registered for specific async requests sent to the
   // content process.
   this.asyncRequests = {};
 
   // create a panel dynamically and attach to the parentNode
   this.createHUD();
-  this.HUDBox.lastTimestamp = 0;
 
   // create the JSTerm input element
-  this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-  if (this.jsterm) {
-    this.jsterm.inputNode.focus();
-  }
-  else if (this.gcliterm) {
-    this.gcliterm.inputNode.focus();
-  }
+  this.jsterm = new JSTerm(this);
+  this.jsterm.inputNode.focus();
 
   // A cache for tracking repeated CSS Nodes.
   this.cssNodes = {};
 
   this._setupMessageManager();
 }
 
 HeadsUpDisplay.prototype = {
@@ -1495,20 +1189,22 @@ HeadsUpDisplay.prototype = {
    *
    * @private
    * @type array
    */
   _messageListeners: ["JSTerm:EvalObject", "WebConsole:ConsoleAPI",
     "WebConsole:CachedMessages", "WebConsole:PageError", "JSTerm:EvalResult",
     "JSTerm:AutocompleteProperties", "JSTerm:ClearOutput",
     "JSTerm:InspectObject", "WebConsole:NetworkActivity",
-    "WebConsole:FileActivity"],
+    "WebConsole:FileActivity", "WebConsole:LocationChange"],
 
   consolePanel: null,
 
+  contentLocation: "",
+
   /**
    * The nesting depth of the currently active console group.
    */
   groupDepth: 0,
 
   _saveRequestAndResponseBodies: false,
 
   /**
@@ -1538,54 +1234,33 @@ HeadsUpDisplay.prototype = {
   },
 
   get mainPopupSet()
   {
     return this.chromeDocument.getElementById("mainPopupSet");
   },
 
   /**
-   * Get the tab associated to the HeadsUpDisplay object.
-   */
-  get tab()
-  {
-    // TODO: we should only keep a reference to the tab object and use
-    // getters to determine the rest of objects we need - the chrome window,
-    // document, etc. We should simplify the entire code to use only a single
-    // tab object ref. See bug 656231.
-    let tab = null;
-    let id = this.notificationBox.id;
-    Array.some(this.chromeDocument.defaultView.gBrowser.tabs, function(aTab) {
-      if (aTab.linkedPanel == id) {
-        tab = aTab;
-        return true;
-      }
-    });
-
-    return tab;
-  },
-
-  /**
    * Create a panel to open the web console if it should float above
    * the content in its own window.
    */
   createOwnWindowPanel: function HUD_createOwnWindowPanel()
   {
     if (this.uiInOwnWindow) {
       return this.consolePanel;
     }
 
     let width = 0;
     try {
       width = Services.prefs.getIntPref("devtools.webconsole.width");
     }
     catch (ex) {}
 
     if (width < 1) {
-      width = this.HUDBox.clientWidth || this.contentWindow.innerWidth;
+      width = this.HUDBox.clientWidth || this.chromeWindow.innerWidth;
     }
 
     let height = this.HUDBox.clientHeight;
 
     let top = 0;
     try {
       top = Services.prefs.getIntPref("devtools.webconsole.top");
     }
@@ -1631,22 +1306,17 @@ HeadsUpDisplay.prototype = {
 
       panel.setAttribute("height", height);
 
       // Scroll the outputNode back to the last location.
       if (lastIndex > -1 && lastIndex < this.outputNode.getRowCount()) {
         this.outputNode.ensureIndexIsVisible(lastIndex);
       }
 
-      if (this.jsterm) {
-        this.jsterm.inputNode.focus();
-      }
-      if (this.gcliterm) {
-        this.gcliterm.inputNode.focus();
-      }
+      this.jsterm.inputNode.focus();
     }).bind(this);
 
     panel.addEventListener("popupshown", onPopupShown,false);
 
     let onPopupHidden = (function HUD_onPopupHidden(aEvent) {
       if (aEvent.target != panel) {
         return;
       }
@@ -1715,17 +1385,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function HUD_getPanelTitle()
   {
-    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.contentLocation]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -1814,64 +1484,25 @@ HeadsUpDisplay.prototype = {
       this.HUDBox.removeAttribute("flex");
       this.HUDBox.removeAttribute("height");
       this.HUDBox.style.height = height + "px";
     }
 
     if (this.jsterm) {
       this.jsterm.inputNode.focus();
     }
-    if (this.gcliterm) {
-      this.gcliterm.inputNode.focus();
-    }
   },
 
   /**
    * The JSTerm object that contains the console's inputNode
    *
    */
   jsterm: null,
 
   /**
-   * The GcliTerm object that contains the console's GCLI
-   */
-  gcliterm: null,
-
-  /**
-   * creates and attaches the console input node
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns void
-   */
-  createConsoleInput:
-  function HUD_createConsoleInput(aWindow, aParentNode, aExistingConsole)
-  {
-    let usegcli = false;
-    try {
-      // usegcli = Services.prefs.getBoolPref("devtools.gcli.enable");
-    }
-    catch (ex) {}
-
-    if (appName() == "FIREFOX") {
-      if (!usegcli) {
-        let mixin = new JSTermFirefoxMixin(aParentNode, aExistingConsole);
-        this.jsterm = new JSTerm(this, mixin);
-      }
-      else {
-        this.gcliterm = new GcliTerm(aWindow, this.hudId, this.chromeDocument,
-                                     this.console, this.hintNode, this.consoleWrap);
-        aParentNode.appendChild(this.gcliterm.element);
-      }
-    }
-    else {
-      throw new Error("Unsupported Gecko Application");
-    }
-  },
-
-  /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
    * @private
    * @param array aRemoteMessages
    *        Array of cached messages coming from the remote Web Console
    *        content instance.
    */
@@ -1905,40 +1536,16 @@ HeadsUpDisplay.prototype = {
     if (numChildren && this.outputNode.clientHeight) {
       // We also check the clientHeight to force a reflow, otherwise
       // ensureIndexIsVisible() does not work after outputNode.hidden = false.
       this.outputNode.ensureIndexIsVisible(numChildren - 1);
     }
   },
 
   /**
-   * Re-attaches a console when the contentWindow is recreated
-   *
-   * @param nsIDOMWindow aContentWindow
-   * @returns void
-   */
-  reattachConsole: function HUD_reattachConsole(aContentWindow)
-  {
-    this.contentWindow = aContentWindow;
-    this.contentDocument = this.contentWindow.document;
-    this.uriSpec = this.contentWindow.location.href;
-
-    if (this.consolePanel) {
-      this.consolePanel.label = this.getPanelTitle();
-    }
-
-    if (this.gcliterm) {
-      this.gcliterm.reattachConsole(this.contentWindow, this.console);
-    }
-    else if (!this.jsterm) {
-      this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    }
-  },
-
-  /**
    * Shortcut to make XUL nodes
    *
    * @param string aTag
    * @returns nsIDOMNode
    */
   makeXULNode:
   function HUD_makeXULNode(aTag)
   {
@@ -1947,25 +1554,24 @@ HeadsUpDisplay.prototype = {
 
   /**
    * Build the UI of each HeadsUpDisplay
    *
    * @returns nsIDOMNode
    */
   makeHUDNodes: function HUD_makeHUDNodes()
   {
-    let self = this;
-
     this.splitter = this.makeXULNode("splitter");
     this.splitter.setAttribute("class", "hud-splitter");
 
     this.HUDBox = this.makeXULNode("vbox");
     this.HUDBox.setAttribute("id", this.hudId);
     this.HUDBox.setAttribute("class", "hud-box animated");
     this.HUDBox.style.height = 0;
+    this.HUDBox.lastTimestamp = 0;
 
     let outerWrap = this.makeXULNode("vbox");
     outerWrap.setAttribute("class", "hud-outer-wrapper");
     outerWrap.setAttribute("flex", "1");
 
     let consoleCommandSet = this.makeXULNode("commandset");
     outerWrap.appendChild(consoleCommandSet);
 
@@ -2020,17 +1626,17 @@ HeadsUpDisplay.prototype = {
 
     consoleWrap.appendChild(consoleFilterToolbar);
     consoleWrap.appendChild(hbox);
 
     outerWrap.appendChild(consoleWrap);
 
     this.HUDBox.lastTimestamp = 0;
 
-    this.jsTermParentNode = outerWrap;
+    this.jsTermParentNode = this.consoleWrap;
     this.HUDBox.appendChild(outerWrap);
 
     return this.HUDBox;
   },
 
   /**
    * sets the click events for all binary toggle filter buttons
    *
@@ -2330,22 +1936,17 @@ HeadsUpDisplay.prototype = {
    *        The ID of the console.
    * @return void
    */
   makeClearConsoleButton: function HUD_makeClearConsoleButton(aToolbar)
   {
     let hudId = this.hudId;
     function HUD_clearButton_onCommand() {
       let hud = HUDService.getHudReferenceById(hudId);
-      if (hud.jsterm) {
-        hud.jsterm.clearOutput(true);
-      }
-      if (hud.gcliterm) {
-        hud.gcliterm.clearOutput();
-      }
+      hud.jsterm.clearOutput(true);
     }
 
     let clearButton = this.makeXULNode("toolbarbutton");
     clearButton.setAttribute("label", l10n.getStr("btnClear"));
     clearButton.classList.add("webconsole-clear-console-button");
     clearButton.addEventListener("command", HUD_clearButton_onCommand, false);
 
     aToolbar.appendChild(clearButton);
@@ -2384,18 +1985,16 @@ HeadsUpDisplay.prototype = {
       let positionPref = Services.prefs.getCharPref("devtools.webconsole.position");
       this.positionConsole(positionPref);
     }
     return this.HUDBox;
   },
 
   uiInOwnWindow: false,
 
-  get console() { return this.contentWindow.wrappedJSObject.console; },
-
   /**
    * Logs a message to the Web Console that originates from the remote Web
    * Console instance.
    *
    * @param object aMessage
    *        The message received from the remote Web Console instance.
    *        console service. This object needs to hold:
    *          - hudId - the Web Console ID.
@@ -2727,17 +2326,18 @@ HeadsUpDisplay.prototype = {
   {
     this.messageManager.loadFrameScript(CONTENT_SCRIPT_URL, true);
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.addMessageListener(aName, this);
     }, this);
 
     let message = {
-      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor"],
+      features: ["ConsoleAPI", "JSTerm", "PageError", "NetworkMonitor",
+                 "LocationChange"],
       cachedMessages: ["ConsoleAPI", "PageError"],
       NetworkMonitor: { monitorFileActivity: true },
       preferences: {
         "NetworkMonitor.saveRequestAndResponseBodies":
           this.saveRequestAndResponseBodies,
       },
     };
     this.sendMessageToContent("WebConsole:Init", message);
@@ -2781,16 +2381,19 @@ HeadsUpDisplay.prototype = {
         this._onInitComplete();
         break;
       case "WebConsole:NetworkActivity":
         this.handleNetworkActivity(aMessage.json);
         break;
       case "WebConsole:FileActivity":
         this.logFileActivity(aMessage.json.uri);
         break;
+      case "WebConsole:LocationChange":
+        this.onLocationChange(aMessage.json);
+        break;
     }
   },
 
   /**
    * Callback method for when the Web Console initialization is complete. For
    * now this method sends the web-console-created notification using the
    * nsIObserverService.
    *
@@ -2926,16 +2529,24 @@ HeadsUpDisplay.prototype = {
     // once requests complete.
     if (HUDService.lastFinishedRequestCallback &&
         aMessage.meta.stages.indexOf("REQUEST_STOP") > -1 &&
         aMessage.meta.stages.indexOf("TRANSACTION_CLOSE") > -1) {
       HUDService.lastFinishedRequestCallback(aMessage);
     }
   },
 
+  onLocationChange: function HUD_onLocationChange(aMessage)
+  {
+    this.contentLocation = aMessage.location;
+    if (this.consolePanel) {
+      this.consolePanel.label = this.getPanelTitle();
+    }
+  },
+
   /**
    * Make a link given an output element.
    *
    * @param nsIDOMNode aNode
    *        The message element you want to make a link for.
    * @param function aCallback
    *        The function you want invoked when the user clicks on the message
    *        element.
@@ -2979,19 +2590,16 @@ HeadsUpDisplay.prototype = {
 
     this._messageListeners.forEach(function(aName) {
       this.messageManager.removeMessageListener(aName, this);
     }, this);
 
     if (this.jsterm) {
       this.jsterm.destroy();
     }
-    if (this.gcliterm) {
-      this.gcliterm.destroy();
-    }
 
     delete this.asyncRequests;
     delete this.messageManager;
     delete this.browser;
     delete this.chromeDocument;
 
     this.positionMenuitems.above.removeEventListener("command",
       this._positionConsoleAbove, false);
@@ -3043,27 +2651,22 @@ function NodeFactory(aFactoryType, ignor
 
 /**
  * Create a JSTerminal or attach a JSTerm input node to an existing output node,
  * given by the parent node.
  *
  * @constructor
  * @param object aHud
  *        The HeadsUpDisplay object that owns this JSTerm instance.
- * @param object aMixin
- *        Gecko-app (or Jetpack) specific utility object
  */
-function JSTerm(aHud, aMixin)
+function JSTerm(aHud)
 {
-  // attach the UI by appending to aParentNode
-
-  this.application = appName();
   this.hud = aHud;
-  this.mixins = aMixin;
   this.document = this.hud.chromeDocument;
+  this.parentNode = this.hud.jsTermParentNode;
 
   this.hudId = this.hud.hudId;
 
   this.lastCompletion = {};
   this.history = [];
   this.historyIndex = 0;
   this.historyPlaceHolder = 0;  // this.history.length;
   this.autocompletePopup = new AutocompletePopup(this.document);
@@ -3075,47 +2678,53 @@ function JSTerm(aHud, aMixin)
 JSTerm.prototype = {
   lastInputValue: "",
   COMPLETE_FORWARD: 0,
   COMPLETE_BACKWARD: 1,
   COMPLETE_HINT_ONLY: 2,
 
   init: function JST_init()
   {
-    this.inputNode = this.mixins.inputNode;
-    this.outputNode = this.mixins.outputNode;
-    this.completeNode = this.mixins.completeNode;
+    this._generateUI();
 
     this._keyPress = this.keyPress.bind(this);
     this._inputEventHandler = this.inputEventHandler.bind(this);
 
-    this.inputNode.addEventListener("keypress",
-      this._keyPress, false);
-    this.inputNode.addEventListener("input",
-      this._inputEventHandler, false);
-    this.inputNode.addEventListener("keyup",
-      this._inputEventHandler, false);
+    this.inputNode.addEventListener("keypress", this._keyPress, false);
+    this.inputNode.addEventListener("input", this._inputEventHandler, false);
+    this.inputNode.addEventListener("keyup", this._inputEventHandler, false);
   },
 
-  get codeInputString()
+  _generateUI: function JST__generateUI()
   {
-    return this.inputNode.value;
+    this.completeNode = this.hud.makeXULNode("textbox");
+    this.completeNode.setAttribute("class", "jsterm-complete-node");
+    this.completeNode.setAttribute("multiline", "true");
+    this.completeNode.setAttribute("rows", "1");
+    this.completeNode.setAttribute("tabindex", "-1");
+
+    this.inputNode = this.hud.makeXULNode("textbox");
+    this.inputNode.setAttribute("class", "jsterm-input-node");
+    this.inputNode.setAttribute("multiline", "true");
+    this.inputNode.setAttribute("rows", "1");
+
+    let inputStack = this.hud.makeXULNode("stack");
+    inputStack.setAttribute("class", "jsterm-stack-node");
+    inputStack.setAttribute("flex", "1");
+    inputStack.appendChild(this.completeNode);
+    inputStack.appendChild(this.inputNode);
+
+    let term = this.hud.makeXULNode("hbox");
+    term.setAttribute("class", "jsterm-input-container");
+    term.setAttribute("style", "direction: ltr;");
+    term.appendChild(inputStack);
+
+    this.parentNode.appendChild(term);
   },
 
-  generateUI: function JST_generateUI()
-  {
-    this.mixins.generateUI();
-  },
-
-  attachUI: function JST_attachUI()
-  {
-    this.mixins.attachUI();
-  },
-
-
   /**
    * Asynchronously evaluate a string in the content process sandbox.
    *
    * @param string aString
    *        String to evaluate in the content process JavaScript sandbox.
    * @param function [aCallback]
    *        Optional function to be invoked when the evaluation result is
    *        received.
@@ -4031,129 +3640,27 @@ JSTerm.prototype = {
     this.inputNode.removeEventListener("keypress", this._keyPress, false);
     this.inputNode.removeEventListener("input", this._inputEventHandler, false);
     this.inputNode.removeEventListener("keyup", this._inputEventHandler, false);
 
     delete this.history;
     delete this.hud;
     delete this.autocompletePopup;
     delete this.document;
-    delete this.mixins;
-  },
-};
-
-/**
- * Generates and attaches the JS Terminal part of the Web Console, which
- * essentially consists of the interactive JavaScript input facility.
- *
- * @param nsIDOMNode aParentNode
- *        The Web Console wrapper node.
- * @param nsIDOMNode aExistingConsole
- *        The Web Console output node.
- * @return void
- */
-function JSTermFirefoxMixin(aParentNode, aExistingConsole)
-{
-  // aExisting Console is the existing outputNode to use in favor of
-  // creating a new outputNode - this is so we can just attach the inputNode to
-  // a normal HeadsUpDisplay console output, and re-use code.
-  this.parentNode = aParentNode;
-  this.existingConsoleNode = aExistingConsole;
-
-  if (aParentNode.ownerDocument) {
-    this.xulElementFactory =
-      NodeFactory("xul", "xul", aParentNode.ownerDocument);
-
-    this.textFactory = NodeFactory("text", "xul", aParentNode.ownerDocument);
-    this.generateUI();
-    this.attachUI();
-  }
-  else {
-    throw new Error("aParentNode should be a DOM node with an ownerDocument property ");
-  }
-}
-
-JSTermFirefoxMixin.prototype = {
-  /**
-   * Generates and attaches the UI for an entire JS Workspace or
-   * just the input node used under the console output
-   *
-   * @returns void
-   */
-  generateUI: function JSTF_generateUI()
-  {
-    this.completeNode = this.xulElementFactory("textbox");
-    this.completeNode.setAttribute("class", "jsterm-complete-node");
-    this.completeNode.setAttribute("multiline", "true");
-    this.completeNode.setAttribute("rows", "1");
-    this.completeNode.setAttribute("tabindex", "-1");
-
-    this.inputNode = this.xulElementFactory("textbox");
-    this.inputNode.setAttribute("class", "jsterm-input-node");
-    this.inputNode.setAttribute("multiline", "true");
-    this.inputNode.setAttribute("rows", "1");
-
-    let inputStack = this.xulElementFactory("stack");
-    inputStack.setAttribute("class", "jsterm-stack-node");
-    inputStack.setAttribute("flex", "1");
-    inputStack.appendChild(this.completeNode);
-    inputStack.appendChild(this.inputNode);
-
-    if (this.existingConsoleNode == undefined) {
-      throw new Error("This can't happen");
-    }
-
-    this.outputNode = this.existingConsoleNode;
-
-    this.term = this.xulElementFactory("hbox");
-    this.term.setAttribute("class", "jsterm-input-container");
-    this.term.setAttribute("style", "direction: ltr;");
-    this.term.appendChild(inputStack);
-  },
-
-  get inputValue()
-  {
-    return this.inputNode.value;
-  },
-
-  attachUI: function JSTF_attachUI()
-  {
-    this.parentNode.appendChild(this.term);
-  }
-};
-
-/**
- * Firefox-specific Application Hooks.
- * Each Gecko-based application will need an object like this in
- * order to use the Heads Up Display
- */
-function FirefoxApplicationHooks()
-{ }
-
-FirefoxApplicationHooks.prototype = {
-  /**
-   * gets the current contentWindow (Firefox-specific)
-   *
-   * @returns nsIDOMWindow
-   */
-  getCurrentContext: function FAH_getCurrentContext()
-  {
-    return Services.wm.getMostRecentWindow("navigator:browser");
   },
 };
 
 //////////////////////////////////////////////////////////////////////////////
 // Utility functions used by multiple callers
 //////////////////////////////////////////////////////////////////////////////
 
 /**
  * ConsoleUtils: a collection of globally used functions
  *
  */
-
 ConsoleUtils = {
   /**
    * Flag to turn on and off scrolling.
    */
   scroll: true,
 
   /**
    * Scrolls a node so that it's visible in its containing XUL "scrollbox"
@@ -4689,18 +4196,18 @@ HeadsUpDisplayUICommands = {
   /**
    * Find the hudId for the active chrome window.
    * @return string|null
    *         The hudId or null if the active chrome window has no open Web
    *         Console.
    */
   getOpenHUD: function UIC_getOpenHUD() {
     let chromeWindow = HUDService.currentContext();
-    let contentWindow = chromeWindow.gBrowser.selectedBrowser.contentWindow;
-    return HUDService.getHudIdByWindow(contentWindow);
+    let hudId = "hud_" + chromeWindow.gBrowser.selectedTab.linkedPanel;
+    return hudId in HUDService.hudReferences ? hudId : null;
   },
 
   /**
    * The event handler that is called whenever a user switches a filter on or
    * off.
    *
    * @param nsIDOMEvent aEvent
    *        The event that triggered the filter change.
@@ -4797,33 +4304,28 @@ HeadsUpDisplayUICommands = {
 // WebConsoleObserver
 //////////////////////////////////////////////////////////////////////////
 
 let WebConsoleObserver = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
   init: function WCO_init()
   {
-    Services.obs.addObserver(this, "content-document-global-created", false);
     Services.obs.addObserver(this, "quit-application-granted", false);
   },
 
   observe: function WCO_observe(aSubject, aTopic)
   {
-    if (aTopic == "content-document-global-created") {
-      HUDService.windowInitializer(aSubject);
-    }
-    else if (aTopic == "quit-application-granted") {
+    if (aTopic == "quit-application-granted") {
       HUDService.shutdown();
     }
   },
 
   uninit: function WCO_uninit()
   {
-    Services.obs.removeObserver(this, "content-document-global-created");
     Services.obs.removeObserver(this, "quit-application-granted");
   },
 };
 
 ///////////////////////////////////////////////////////////////////////////////
 // CommandController
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -4908,412 +4410,31 @@ CommandController.prototype = {
         break;
       case "cmd_selectAll":
         this.selectAll(outputNode);
         break;
     }
   }
 };
 
-///////////////////////////////////////////////////////////////////////////
-// appName
-///////////////////////////////////////////////////////////////////////////
-
 /**
  * Get the app's name so we can properly dispatch app-specific
  * methods per API call
  * @returns Gecko application name
  */
 function appName()
 {
   let APP_ID = Services.appinfo.QueryInterface(Ci.nsIXULRuntime).ID;
 
   let APP_ID_TABLE = {
     "{ec8030f7-c20a-464f-9b0e-13a3a9e97384}": "FIREFOX" ,
     "{3550f703-e582-4d05-9a08-453d09bdfdc6}": "THUNDERBIRD",
     "{a23983c0-fd0e-11dc-95ff-0800200c9a66}": "FENNEC" ,
     "{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}": "SEAMONKEY",
   };
 
-  let name = APP_ID_TABLE[APP_ID];
-
-  if (name){
-    return name;
-  }
-  throw new Error("appName: UNSUPPORTED APPLICATION UUID");
+  return APP_ID_TABLE[APP_ID];
 }
 
 XPCOMUtils.defineLazyGetter(this, "HUDService", function () {
-  try {
-    return new HUD_SERVICE();
-  }
-  catch (ex) {
-    Cu.reportError(ex);
-  }
+  return new HUD_SERVICE();
 });
 
-///////////////////////////////////////////////////////////////////////////
-// GcliTerm
-///////////////////////////////////////////////////////////////////////////
-
-/**
- * Some commands need customization - this is how we get at them.
- */
-let commandExports = undefined;
-
-/**
- * GcliTerm
- *
- * Initialize GCLI by creating a set of startup options from the available
- * properties.
- *
- * @param nsIDOMWindow aContentWindow
- *        The content window that we're providing as the context to commands
- * @param string aHudId
- *        The HUD to which we should send console messages.
- * @param nsIDOMDocument aDocument
- *        The DOM document from which to create nodes.
- * @param object aConsole
- *        Console object to use within the GcliTerm.
- * @param nsIDOMElement aHintNode
- *        The node to which we add GCLI's hints.
- * @constructor
- */
-function GcliTerm(aContentWindow, aHudId, aDocument, aConsole, aHintNode, aConsoleWrap)
-{
-  this.context = Cu.getWeakReference(aContentWindow);
-  this.hudId = aHudId;
-  this.document = aDocument;
-  this.console = aConsole;
-  this.hintNode = aHintNode;
-  this._window = this.context.get().QueryInterface(Ci.nsIDOMWindow);
-
-  this.createUI();
-  this.createSandbox();
-
-  this.gcliConsole = gcli._internal.createDisplay({
-    contentDocument: aContentWindow.document,
-    chromeDocument: this.document,
-    outputDocument: this.document,
-    chromeWindow: this.document.defaultView,
-
-    hintElement: this.hintNode,
-    inputElement: this.inputNode,
-    completeElement: this.completeNode,
-    backgroundElement: this.inputStack,
-    consoleWrap: aConsoleWrap,
-
-    eval: this.evalInSandbox.bind(this),
-
-    environment: {
-      chromeDocument: this.document,
-      contentDocument: aContentWindow.document
-    },
-
-    tooltipClass: 'gcliterm-tooltip',
-
-    // Allow GCLI:Inputter to decide how and when to open a scratchpad window
-    scratchpad: {
-      shouldActivate: function Scratchpad_shouldActivate(aEvent) {
-        return aEvent.shiftKey &&
-            aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN;
-      },
-      activate: function Scratchpad_activate(aValue) {
-        aValue = aValue.replace(/^\s*{\s*/, '');
-        ScratchpadManager.openScratchpad({ text: aValue });
-        return true;
-      },
-      linkText: stringBundle.GetStringFromName('scratchpad.linkText')
-    },
-  });
-
-  this.gcliConsole.onVisibilityChange.add(this.onVisibilityChange, this);
-  this.gcliConsole.onOutput.add(this.onOutput, this);
-}
-
-GcliTerm.prototype = {
-  /**
-   * Show or remove the hint column from the display.
-   */
-  onVisibilityChange: function GcliTerm_onVisibilityChange(ev)
-  {
-    if (ev.visible) {
-      this.hintNode.parentNode.hidden = false;
-    }
-    else {
-      let permaHint = false;
-      try {
-        permaHint = Services.prefs.getBoolPref("devtools.gcli.permaHint");
-      }
-      catch (ex) {}
-
-      if (!permaHint) {
-        this.hintNode.parentNode.hidden = true;
-      }
-    }
-  },
-
-  /**
-   * Destroy the GcliTerm object. Call this method to avoid memory leaks.
-   */
-  destroy: function Gcli_destroy()
-  {
-    this.gcliConsole.onVisibilityChange.remove(this.onVisibilityChange, this);
-    this.gcliConsole.onOutput.remove(this.onOutput, this);
-    this.gcliConsole.destroy();
-
-    delete this.context;
-    delete this.document;
-    delete this.console;
-    delete this.hintNode;
-    delete this._window;
-
-    delete this.sandbox;
-    delete this.element;
-    delete this.inputStack;
-    delete this.completeNode;
-    delete this.inputNode;
-  },
-
-  /**
-   * Re-attaches a console when the contentWindow is recreated.
-   *
-   * @param nsIDOMWindow aContentWindow
-   *        The content window that we're providing as the context to commands
-   * @param object aConsole
-   *        Console object to use within the GcliTerm.
-   */
-  reattachConsole: function Gcli_reattachConsole(aContentWindow, aConsole)
-  {
-    this.context = Cu.getWeakReference(aContentWindow);
-    this.console = aConsole;
-    this.createSandbox();
-
-    this.gcliConsole.reattach({
-      contentDocument: aContentWindow.document,
-      environment: {
-        chromeDocument: this.document,
-        contentDocument: aContentWindow.document
-      },
-    });
-  },
-
-  /**
-   * Generates and attaches the GCLI Terminal part of the Web Console, which
-   * essentially consists of the interactive JavaScript input facility.
-   */
-  createUI: function Gcli_createUI()
-  {
-    this.element = this.document.createElement("vbox");
-    this.element.setAttribute("class", "gcliterm-input-container");
-    this.element.setAttribute("flex", "0");
-
-    this.inputStack = this.document.createElement("stack");
-    this.inputStack.setAttribute("class", "gcliterm-stack-node");
-    this.element.appendChild(this.inputStack);
-
-    this.completeNode = this.document.createElementNS(HTML_NS, "div");
-    this.completeNode.setAttribute("class", "gcliterm-complete-node");
-    this.completeNode.setAttribute("aria-live", "polite");
-    this.inputStack.appendChild(this.completeNode);
-
-    this.inputNode = this.document.createElement("textbox");
-    this.inputNode.setAttribute("class", "gcliterm-input-node");
-    this.inputNode.setAttribute("rows", "1");
-    this.inputStack.appendChild(this.inputNode);
-  },
-
-  /**
-   * Called by GCLI/canon when command line output changes.
-   */
-  onOutput: function Gcli_onOutput(aEvent)
-  {
-    // When we can update the history of the console, then we should stop
-    // filtering incomplete reports.
-    if (!aEvent.output.completed) {
-      return;
-    }
-
-    this.writeOutput(aEvent.output.typed, CATEGORY_INPUT);
-
-    // This is an experiment to see how much people yell when we stop reporting
-    // undefined replies.
-    if (aEvent.output.output === undefined) {
-      return;
-    }
-
-    let output = aEvent.output.output;
-    let declaredType = aEvent.output.command.returnType || "";
-
-    if (declaredType == "object") {
-      let actualType = typeof output;
-      if (output === null) {
-        output = "null";
-      }
-      else if (actualType == "string") {
-        output = "\"" + output + "\"";
-      }
-      else if (actualType == "object" || actualType == "function") {
-        let formatOpts = [ nameObject(output) ];
-        output = stringBundle.formatStringFromName('gcliterm.instanceLabel',
-                formatOpts, formatOpts.length);
-        let linkNode = this.document.createElementNS(HTML_NS, 'html:span');
-        linkNode.appendChild(this.document.createTextNode(output));
-        linkNode.classList.add("hud-clickable");
-        linkNode.setAttribute("aria-haspopup", "true");
-
-        // Make the object bring up the property panel.
-        linkNode.addEventListener("mousedown", function(aEv) {
-          this._startX = aEv.clientX;
-          this._startY = aEv.clientY;
-        }.bind(this), false);
-
-        linkNode.addEventListener("click", function(aEv) {
-          if (aEv.detail != 1 || aEv.button != 0 ||
-              (this._startX != aEv.clientX && this._startY != aEv.clientY)) {
-            return;
-          }
-
-          if (!this._panelOpen) {
-            let propPanel = this.openPropertyPanel(aEvent.output.typed, aEvent.output.output, this);
-            propPanel.panel.setAttribute("hudId", this.hudId);
-            this._panelOpen = true;
-          }
-        }.bind(this), false);
-
-        output = linkNode;
-      }
-      // else if (actualType == number/boolean/undefined) do nothing
-    }
-
-    if (declaredType == "html" && typeof output == "string") {
-      output = this.document.createRange().createContextualFragment(
-          '<div xmlns="' + HTML_NS + '" xmlns:xul="' + XUL_NS + '">' +
-          output + '</div>');
-    }
-
-    // See https://github.com/mozilla/domtemplate/blob/master/README.md
-    // for docs on the template() function
-    let element = this.document.createRange().createContextualFragment(
-      '<richlistitem xmlns="' + XUL_NS + '" _clipboardText="${clipboardText}"' +
-      '    _timestamp="${timestamp}" _id="${id}" class="hud-msg-node">' +
-      '  <label class="webconsole-timestamp" _value="${timestampString}"/>' +
-      '  <vbox class="webconsole-msg-icon-container" _style="${iconContainerStyle}">' +
-      '    <image class="webconsole-msg-icon"/>' +
-      '    <spacer flex="1"/>' +
-      '  </vbox>' +
-      '  <hbox flex="1" class="gcliterm-msg-body">${output}</hbox>' +
-      '  <hbox align="start"><label value="1" class="webconsole-msg-repeat"/></hbox>' +
-      '</richlistitem>').firstChild;
-
-    let hud = HUDService.getHudReferenceById(this.hudId);
-    let timestamp = Date.now();
-    template(element, {
-      iconContainerStyle: "margin-left=" + (hud.groupDepth * GROUP_INDENT) + "px",
-      output: output,
-      timestamp: timestamp,
-      timestampString: l10n.timestampString(timestamp),
-      clipboardText: output.innerText,
-      id: "console-msg-" + HUDService.sequenceId()
-    });
-
-    ConsoleUtils.setMessageType(element, CATEGORY_OUTPUT, SEVERITY_LOG);
-    ConsoleUtils.outputMessageNode(element, this.hudId);
-  },
-
-  /**
-   * Setup the eval sandbox, should be called whenever we are attached.
-   */
-  createSandbox: function Gcli_createSandbox()
-  {
-    // create a JS Sandbox out of this.context
-    this.sandbox = new Cu.Sandbox(this._window, {
-      sandboxPrototype: this._window,
-      wantXrays: false
-    });
-    this.sandbox.console = this.console;
-
-    JSTermHelper(this);
-  },
-
-  /**
-   * Evaluates a string in the sandbox.
-   *
-   * @param string aString
-   *        String to evaluate in the sandbox
-   * @return The result of the evaluation
-   */
-  evalInSandbox: function Gcli_evalInSandbox(aString)
-  {
-    let window = WebConsoleUtils.unwrap(this.sandbox.window);
-    let temp$ = null;
-    let temp$$ = null;
-
-    // We prefer to execute the page-provided implementations for the $() and
-    // $$() functions.
-    if (typeof window.$ == "function") {
-      temp$ = this.sandbox.$;
-      delete this.sandbox.$;
-    }
-    if (typeof window.$$ == "function") {
-      temp$$ = this.sandbox.$$;
-      delete this.sandbox.$$;
-    }
-
-    let result = Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
-
-    if (temp$) {
-      this.sandbox.$ = temp$;
-    }
-    if (temp$$) {
-      this.sandbox.$$ = temp$$;
-    }
-
-    return result;
-  },
-
-  /**
-   * Writes a message to the HUD that originates from the interactive
-   * JavaScript console.
-   *
-   * @param string aOutputMessage
-   *        The message to display.
-   * @param number aCategory
-   *        One of the CATEGORY_ constants.
-   * @param number aSeverity
-   *        One of the SEVERITY_ constants.
-   */
-  writeOutput: function Gcli_writeOutput(aOutputMessage, aCategory, aSeverity, aOptions)
-  {
-    aOptions = aOptions || {};
-
-    let node = ConsoleUtils.createMessageNode(
-                    this.document,
-                    aCategory || CATEGORY_OUTPUT,
-                    aSeverity || SEVERITY_LOG,
-                    aOutputMessage,
-                    this.hudId,
-                    aOptions.sourceUrl || undefined,
-                    aOptions.sourceLine || undefined,
-                    aOptions.clipboardText || undefined);
-
-    ConsoleUtils.outputMessageNode(node, this.hudId);
-  },
-
-  clearOutput: JSTerm.prototype.clearOutput,
-  openPropertyPanel: JSTerm.prototype.openPropertyPanel,
-
-  formatResult: WebConsoleUtils.formatResult,
-  getResultType: WebConsoleUtils.getResultType,
-  formatString: WebConsoleUtils.formatResultString,
-};
-
-/**
- * A fancy version of toString()
- */
-function nameObject(aObj) {
-  if (aObj.constructor && aObj.constructor.name) {
-    return aObj.constructor.name;
-  }
-  // If that fails, use Objects toString which sometimes gives something
-  // better than 'Object', and at least defaults to Object if nothing better
-  return Object.prototype.toString.call(aObj).slice(8, -1);
-}
