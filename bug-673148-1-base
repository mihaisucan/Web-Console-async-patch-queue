# HG changeset patch
# Parent 61b9c4d798edac83a2d50849a5726796054dfd04
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1333483835 -10800

Bug 673148 - (async-webconsole) Part 1 - Make console API async

diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -10,9 +10,9 @@ browser.jar:
     content/browser/devtools/cssruleview.xul      (styleinspector/cssruleview.xul)
     content/browser/devtools/styleinspector.css   (styleinspector/styleinspector.css)
     content/browser/orion.js                      (sourceeditor/orion/orion.js)
 *   content/browser/source-editor-overlay.xul     (sourceeditor/source-editor-overlay.xul)
 *   content/browser/debugger.xul                  (debugger/debugger.xul)
     content/browser/debugger.css                  (debugger/debugger.css)
     content/browser/debugger.js                   (debugger/debugger.js)
     content/browser/debugger-view.js              (debugger/debugger-view.js)
-
+    content/browser/devtools/HUDService-content.js (webconsole/HUDService-content.js)
diff --git a/browser/devtools/webconsole/HUDService-content.js b/browser/devtools/webconsole/HUDService-content.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/HUDService-content.js
@@ -0,0 +1,456 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Web Console.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com> (original author)
+ *   David Dahl <ddahl@mozilla.com>
+ *   Rob Campbell <rcampbell@mozilla.com>
+ *   Johnathan Nightingale <jnightingale@mozilla.com>
+ *   Patrick Walton <pcwalton@mozilla.com>
+ *   Julian Viereck <jviereck@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+"use strict";
+
+(function() {
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function () {
+  return WebConsoleUtils.l10n;
+});
+
+/**
+ * The Web Console content instance manager.
+ */
+let Manager = {
+  get "window"() content,
+  get console() this.window.console,
+  sandbox: null,
+  hudId: null,
+  _sequence: 0,
+  _messageListeners: ["WebConsole:Init", "WebConsole:Destroy"],
+  _messageHandlers: null,
+
+  /**
+   * Getter for a unique ID for the current Web Console content instance.
+   */
+  get sequenceId() "HUDContent-" + (++this._sequence),
+
+  /**
+   * Initialize the Web Console manager.
+   */
+  init: function Manager_init()
+  {
+    this._messageHandlers = {};
+
+    this._messageListeners.forEach(function(aName) {
+      addMessageListener(aName, this);
+    }, this);
+  },
+
+  /**
+   * The message handler. This method forwards all the messages to the
+   * appropriate code.
+   */
+  receiveMessage: function Manager_receiveMessage(aMessage)
+  {
+    if (!aMessage.json || (aMessage.name != "WebConsole:Init" &&
+                           aMessage.json.hudId != this.hudId)) {
+      Cu.reportError("Web Console content script: received message " +
+                     aMessage.name + " from wrong hudId.");
+      return;
+    }
+
+    switch (aMessage.name) {
+      case "WebConsole:Init":
+        this._onInit(aMessage.json);
+        break;
+      case "WebConsole:EnableFeature":
+        this.enableFeature(aMessage.json.feature, aMessage.json);
+        break;
+      case "WebConsole:DisableFeature":
+        this.disableFeature(aMessage.json.feature);
+        break;
+      case "WebConsole:Destroy":
+        this.destroy();
+        break;
+      default: {
+        let handler = this._messageHandlers[aMessage.name];
+        handler && handler(aMessage.json);
+        break;
+      }
+    }
+  },
+
+  /**
+   * The manager initialization code. This method is called when the Web Console
+   * remote process initializes the content process (this code!).
+   *
+   * @param object aMessage
+   *        The object received from the remote process.
+   */
+  _onInit: function Manager_onInit(aMessage)
+  {
+    this.hudId = aMessage.hudId;
+  },
+
+  /**
+   * Add a remote message handler. This is used by other components of the Web
+   * Console content script.
+   *
+   * @param string aName
+   *        Message name to listen for.
+   * @param function aCallback
+   *        Function to execute when the message is received. This function is
+   *        given the JSON object that came from the remote Web Console
+   *        instance.
+   *        Only one callback per message name is allowed!
+   */
+  addMessageHandler: function Manager_addMessageHandler(aName, aCallback)
+  {
+    if (aName in this._messageHandlers) {
+      return;
+    }
+
+    this._messageHandlers[aName] = aCallback;
+    addMessageListener(aName, this);
+  },
+
+  /**
+   * Remove the message handler for the given name.
+   *
+   * @param string aName
+   *        Message name for the handler you want removed.
+   */
+  removeMessageHandler: function Manager_removeMessageHandler(aName)
+  {
+    if (!(aName in this._messageHandlers)) {
+      return;
+    }
+
+    delete this._messageHandlers[aName];
+    removeMessageListener(aName, this);
+  },
+
+  /**
+   * Enable a feature in the Web Console content script. A feature is generally
+   * a set of observers/listeners that are added in the content process. This
+   * script exposes the data via the message manager for the features you
+   * enable.
+   *
+   * Supported features:
+   *    - JSTerm - a JavaScript "terminal" which allows code execution.
+   *    - ConsoleAPI - support for routing the window.console API to the remote
+   *    process.
+   *
+   * @param string aFeature
+   *        One of the supported features: JSTerm, ConsoleAPI.
+   * @param object [aMessage]
+   *        Optional JSON message object coming from the remote Web Console
+   *        instance. This can be used for feature-specific options.
+   */
+  enableFeature: function Manager_enableFeature(aFeature, aMessage)
+  {
+    if (this._enabledFeatures.indexOf(aFeature) != -1) {
+      return;
+    }
+
+    switch (aFeature) {
+      case "JSTerm":
+        JSTerm.init(aMessage);
+        break;
+      case "ConsoleAPI":
+        ConsoleAPIObserver.init(aMessage);
+        break;
+      default:
+        Cu.reportError("Web Console content: unknown feature " + aFeature);
+        break;
+    }
+
+    this._enabledFeatures.push(aFeature);
+  },
+
+  /**
+   * Disable a Web Console content script feature.
+   *
+   * @see this.enableFeature
+   * @param string aFeature
+   *        One of the supported features: JSTerm, ConsoleAPI.
+   */
+  disableFeature: function Manager_disableFeature(aFeature)
+  {
+    let index = this._enabledFeatures.indexOf(aFeature);
+    if (index == -1) {
+      return;
+    }
+    this._enabledFeatures.splice(index, 1);
+
+    switch (aFeature) {
+      case "JSTerm":
+        JSTerm.destroy();
+        break;
+      case "ConsoleAPI":
+        ConsoleAPIObserver.destroy();
+        break;
+      default:
+        Cu.reportError("Web Console content: unknown feature " + aFeature);
+        break;
+    }
+  },
+
+  /**
+   * Destroy the Web Console content script instance.
+   */
+  destroy: function Manager_destroy()
+  {
+    this._messageListeners.forEach(function(aName) {
+      removeMessageListener(aName, this);
+    }, this);
+
+    this._enabledFeatures.forEach(this.disableFeature, this);
+
+    this.hudId = null;
+    this._messageHandlers = null;
+    Manager = null;
+  },
+};
+
+/**
+ * The JavaScript terminal is meant to allow remote code execution for the Web
+ * Console.
+ */
+let JSTerm = {
+  /**
+   * Evaluation result objects are cached in this object. The chrome process can
+   * request any object based on its ID.
+   */
+  _objectCache: null,
+
+  /**
+   * Initialize the JavaScript terminal feature.
+   */
+  init: function JST_init()
+  {
+    this._objectCache = {};
+
+    Manager.addMessageHandler("JSTerm:GetEvalObject",
+                              this.handleGetEvalObject.bind(this));
+    Manager.addMessageHandler("JSTerm:ClearObjectCache",
+                              this.handleClearObjectCache.bind(this));
+  },
+
+  /**
+   * Handler for the remote "JSTerm:GetEvalObject" message. This allows the
+   * remote Web Console instance to retrieve an object from the content process.
+   *
+   * @param object aRequest
+   *        The message that requests the content object. Properties: cacheId,
+   *        objectId and resultCacheId.
+   *
+   *        Evaluated objects are stored in "buckets" (cache IDs). Each object
+   *        is assigned an ID (object ID). You can request a specific object
+   *        (objectId) from a specific cache (cacheId) and tell where the result
+   *        should be cached (resultCacheId). The requested object can have
+   *        further references to other objects - those references will be
+   *        cached in the "bucket" of your choice (based on resultCacheId). If
+   *        you do not provide any resultCacheId in the request message, then
+   *        cacheId will be used.
+   */
+  handleGetEvalObject: function JST_handleGetEvalObject(aRequest)
+  {
+    if (aRequest.cacheId in this._objectCache &&
+        aRequest.objectId in this._objectCache[aRequest.cacheId]) {
+      let object = this._objectCache[aRequest.cacheId][aRequest.objectId];
+      let resultCacheId = aRequest.resultCacheId || aRequest.cacheId;
+      let message = {
+        hudId: Manager.hudId,
+        id: aRequest.id,
+        cacheId: aRequest.cacheId,
+        objectId: aRequest.objectId,
+        object: this.prepareObjectForRemote(object, resultCacheId),
+        childrenCacheId: resultCacheId,
+      };
+      sendAsyncMessage("JSTerm:EvalObject", message);
+    }
+    else {
+      Cu.reportError("JSTerm:GetEvalObject request " + aRequest.id +
+                     ": stale object.");
+    }
+  },
+
+  /**
+   * Handler for the remote "JSTerm:ClearObjectCache" message. This allows the
+   * remote Web Console instance to clear the cache of objects that it no longer
+   * uses.
+   *
+   * @param object aRequest
+   *        An object that holds one property: the cacheId you want cleared.
+   */
+  handleClearObjectCache: function JST_handleClearObjectCache(aRequest)
+  {
+    if (aRequest.cacheId in this._objectCache) {
+      delete this._objectCache[aRequest.cacheId];
+    }
+  },
+
+  /**
+   * Prepare an object to be sent to the remote Web Console instance.
+   *
+   * @param number aCacheId
+   *        Cache ID where you want object references to be stored into. The
+   *        given object may include references to other objects - those
+   *        references will be stored in the given cache ID so the remote
+   *        process can later retrieve them as well.
+   */
+  prepareObjectForRemote:
+  function JST_prepareObjectForRemote(aObject, aCacheId)
+  {
+    // Cache the properties that have inspectable values.
+    let propCache = this._objectCache[aCacheId] || {};
+    let result = WebConsoleUtils.namesAndValuesOf(aObject, propCache);
+    if (!(aCacheId in this._objectCache) && Object.keys(propCache).length > 0) {
+      this._objectCache[aCacheId] = propCache;
+    }
+
+    return result;
+  },
+
+  /**
+   * Destroy the JSTerm instance.
+   */
+  destroy: function JST_destroy()
+  {
+    Manager.removeMessageHandler("JSTerm:GetEvalObject");
+    Manager.removeMessageHandler("JSTerm:ClearObjectCache");
+
+    delete this._objectCache;
+    JSTerm = null;
+  },
+};
+
+let ConsoleAPIObserver = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+  init: function CAO_init()
+  {
+    // TODO: address the problem of having this observer registered multiple
+    // times in the same process.
+    Services.obs.addObserver(this, "console-api-log-event", false);
+  },
+
+  observe: function CAO_observe(aMessage, aTopic, aData)
+  {
+    if (!aMessage || aTopic != "console-api-log-event") {
+      return;
+    }
+
+    let apiMessage = aMessage.wrappedJSObject;
+
+    let msgWindow =
+      WebConsoleUtils.getWindowByOuterId(apiMessage.ID, Manager.window);
+    if (!msgWindow || msgWindow.top != Manager.window) {
+      // not the same window!
+      return;
+    }
+
+    let messageToChrome = {
+      hudId: Manager.hudId,
+      id: Manager.sequenceId,
+      apiMessage: {},
+    };
+
+    messageToChrome.apiMessage =
+      WebConsoleUtils.cloneObject(apiMessage, true,
+        function(aKey, aValue, aObject) {
+          // We need to skip the arguments property from apiMessage for all
+          // messages, except for trace.
+          if (aKey == "wrappedJSObject" ||
+              aObject === apiMessage && aKey == "arguments" &&
+              apiMessage.level != "trace") {
+            return false;
+          }
+          return true;
+        });
+
+    // TODO: deal with passing result objects to other window.console API
+    // messages, beyond console.dir(). This is sufficient for parity with the
+    // current non-e10s Web Console code.
+
+    // FIXME for console.time and console.group
+    let mapFunction;
+    if (apiMessage.level == "dir" && apiMessage.arguments) {
+      messageToChrome.objectsCacheId = Manager.sequenceId;
+      messageToChrome.argumentsToString = [];
+      mapFunction = function(aItem) {
+        messageToChrome.argumentsToString.push(aItem.toString());
+        return Manager.prepareObjectForRemote(aItem,
+                                              messageToChrome.objectsCacheId);
+      };
+    }
+    else if (apiMessage.level != "dir" && apiMessage.level != "trace") {
+      mapFunction = function(aItem) {
+        return typeof aItem == "string" ? aItem :
+               WebConsoleUtils.formatResult(aItem);
+      };
+    }
+
+    if (apiMessage.arguments && mapFunction) {
+      messageToChrome.apiMessage.arguments =
+        Array.map(apiMessage.arguments, mapFunction);
+    }
+
+    sendAsyncMessage("WebConsole:ConsoleAPI", messageToChrome);
+  },
+
+  destroy: function CAO_destroy()
+  {
+    Services.obs.removeObserver(this, "console-api-log-event");
+    ConsoleAPIObserver = null;
+  },
+};
+
+Manager.init();
+})();
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -137,16 +137,26 @@ XPCOMUtils.defineLazyGetter(this, "names
 });
 
 XPCOMUtils.defineLazyGetter(this, "gConsoleStorage", function () {
   let obj = {};
   Cu.import("resource://gre/modules/ConsoleAPIStorage.jsm", obj);
   return obj.ConsoleAPIStorage;
 });
 
+XPCOMUtils.defineLazyGetter(this, "WebConsoleUtils", function () {
+  let obj = {};
+  Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+  return obj.WebConsoleUtils;
+});
+
+XPCOMUtils.defineLazyGetter(this, "l10n", function() {
+  return WebConsoleUtils.l10n;
+});
+
 function LogFactory(aMessagePrefix)
 {
   function log(aMessage) {
     var _msg = aMessagePrefix + " " + aMessage + "\n";
     dump(_msg);
   }
   return log;
 }
@@ -658,17 +668,17 @@ function unwrap(aObject)
  */
 function NetworkPanel(aParent, aHttpActivity)
 {
   let doc = aParent.ownerDocument;
   this.httpActivity = aHttpActivity;
 
   // Create the underlaying panel
   this.panel = createElement(doc, "panel", {
-    label: HUDService.getStr("NetworkPanel.label"),
+    label: l10n.getStr("NetworkPanel.label"),
     titlebar: "normal",
     noautofocus: "true",
     noautohide: "true",
     close: "true"
   });
 
   // Create the iframe that displays the NetworkPanel XHTML.
   this.iframe = createAndAppendElement(this.panel, "iframe", {
@@ -744,17 +754,17 @@ NetworkPanel.prototype =
    *        "NetworkPanel." before calling the HUDService.getFormatStr function.
    * @param array aArray
    *        Values used as placeholder for the i10n string.
    * @returns string
    *          The i10n formated string.
    */
   _format: function NP_format(aName, aArray)
   {
-    return HUDService.getFormatStr("NetworkPanel." + aName, aArray);
+    return l10n.getFormatStr("NetworkPanel." + aName, aArray);
   },
 
   /**
    * Returns the content type of the response body. This is based on the
    * response.header["Content-Type"] info. If this value is not available, then
    * the content type is tried to be estimated by the url file ending.
    *
    * @returns string or null
@@ -944,17 +954,17 @@ NetworkPanel.prototype =
   {
     let timing = this.httpActivity.timing;
     let request = this.httpActivity.request;
 
     this._appendTextNode("headUrl", this.httpActivity.url);
     this._appendTextNode("headMethod", this.httpActivity.method);
 
     this._appendTextNode("requestHeadersInfo",
-      ConsoleUtils.timestampString(timing.REQUEST_HEADER/1000));
+      l10n.timestampString(timing.REQUEST_HEADER/1000));
 
     this._appendList("requestHeadersContent", request.header, true);
 
     if ("Cookie" in request.header) {
       this._displayNode("requestCookie");
 
       let cookies = request.header.Cookie.split(";");
       let cookieList = {};
@@ -1391,91 +1401,31 @@ HUD_SERVICE.prototype =
    * @returns string
    */
   getStr: function HS_getStr(aName)
   {
     return stringBundle.GetStringFromName(aName);
   },
 
   /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @returns (format) string
-   */
-  getFormatStr: function HS_getFormatStr(aName, aArray)
-  {
-    return stringBundle.formatStringFromName(aName, aArray, aArray.length);
-  },
-
-  /**
    * getter for UI commands to be used by the frontend
    *
    * @returns object
    */
   get consoleUI() {
     return HeadsUpDisplayUICommands;
   },
 
   /**
    * The sequencer is a generator (after initialization) that returns unique
    * integers
    */
   sequencer: null,
 
   /**
-   * Gets the ID of the outer window of this DOM window
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns integer
-   */
-  getWindowId: function HS_getWindowId(aWindow)
-  {
-    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
-  },
-
-  /**
-   * Gets the ID of the inner window of this DOM window
-   *
-   * @param nsIDOMWindow aWindow
-   * @returns integer
-   */
-  getInnerWindowId: function HS_getInnerWindowId(aWindow)
-  {
-    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
-           getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
-  },
-
-  /**
-   * Gets the top level content window that has an outer window with
-   * the given ID or returns null if no such content window exists
-   *
-   * @param integer aId
-   * @returns nsIDOMWindow
-   */
-  getWindowByWindowId: function HS_getWindowByWindowId(aId)
-  {
-    // In the future (post-Electrolysis), getOuterWindowWithId() could
-    // return null, because the originating window could have gone away
-    // while we were in the process of receiving and/or processing a
-    // message. For future-proofing purposes, we do a null check here.
-
-    let someWindow = Services.wm.getMostRecentWindow(null);
-    let content = null;
-
-    if (someWindow) {
-      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                                  .getInterface(Ci.nsIDOMWindowUtils);
-      content = windowUtils.getOuterWindowWithId(aId);
-    }
-
-    return content;
-  },
-
-  /**
    * Whether to save the bodies of network requests and responses. Disabled by
    * default to save memory.
    */
   saveRequestAndResponseBodies: false,
 
   /**
    * Tell the HUDService that a HeadsUpDisplay can be activated
    * for the window or context that has 'aContextDOMId' node id
@@ -1998,17 +1948,17 @@ HUD_SERVICE.prototype =
    * Returns the hudId that is corresponding to the hud activated for the
    * passed aContentWindow. If there is no matching hudId null is returned.
    *
    * @param nsIDOMWindow aContentWindow
    * @returns string or null
    */
   getHudIdByWindow: function HS_getHudIdByWindow(aContentWindow)
   {
-    let windowId = this.getWindowId(aContentWindow);
+    let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow);
     return this.getHudIdByWindowId(windowId);
   },
 
   /**
    * Returns the hudReference for a given id.
    *
    * @param string aId
    * @returns Object
@@ -2095,22 +2045,22 @@ HUD_SERVICE.prototype =
       case "debug":
         let mappedArguments = Array.map(args, formatResult);
         body = Array.join(mappedArguments, " ");
         sourceURL = aMessage.filename;
         sourceLine = aMessage.lineNumber;
         break;
 
       case "trace":
-        let filename = ConsoleUtils.abbreviateSourceURL(args[0].filename);
+        let filename = WebConsoleUtils.abbreviateSourceURL(args[0].filename);
         let functionName = args[0].functionName ||
-                           this.getStr("stacktrace.anonymousFunction");
+                           l10n.getStr("stacktrace.anonymousFunction");
         let lineNumber = args[0].lineNumber;
 
-        body = this.getFormatStr("stacktrace.outputMessage",
+        body = l10n.getFormatStr("stacktrace.outputMessage",
                                  [filename, functionName, lineNumber]);
 
         sourceURL = args[0].filename;
         sourceLine = args[0].lineNumber;
 
         clipboardText = "";
 
         args.forEach(function(aFrame) {
@@ -2143,30 +2093,30 @@ HUD_SERVICE.prototype =
         }
         return;
 
       case "time":
         if (!args) {
           return;
         }
         if (args.error) {
-          Cu.reportError(this.getStr(args.error));
+          Cu.reportError(l10n.getStr(args.error));
           return;
         }
-        body = this.getFormatStr("timerStarted", [args.name]);
+        body = l10n.getFormatStr("timerStarted", [args.name]);
         clipboardText = body;
         sourceURL = aMessage.filename;
         sourceLine = aMessage.lineNumber;
         break;
 
       case "timeEnd":
         if (!args) {
           return;
         }
-        body = this.getFormatStr("timeEnd", [args.name, args.duration]);
+        body = l10n.getFormatStr("timeEnd", [args.name, args.duration]);
         clipboardText = body;
         sourceURL = aMessage.filename;
         sourceLine = aMessage.lineNumber;
         break;
 
       default:
         Cu.reportError("Unknown Console API log level: " + level);
         return;
@@ -2285,17 +2235,17 @@ HUD_SERVICE.prototype =
     // Warnings and legacy strict errors become warnings; other types become
     // errors.
     let severity = SEVERITY_ERROR;
     if ((aScriptError.flags & aScriptError.warningFlag) ||
         (aScriptError.flags & aScriptError.strictFlag)) {
       severity = SEVERITY_WARNING;
     }
 
-    let window = HUDService.getWindowByWindowId(aScriptError.outerWindowID);
+    let window = WebConsoleUtils.getWindowByOuterId(aScriptError.outerWindowID);
     if (window) {
       let hudId = HUDService.getHudIdByWindow(window.top);
       if (hudId) {
         let outputNode = this.hudReferences[hudId].outputNode;
         let chromeDocument = outputNode.ownerDocument;
 
         let node = ConsoleUtils.createMessageNode(chromeDocument,
                                                   category,
@@ -2606,17 +2556,17 @@ HUD_SERVICE.prototype =
                                 timing.REQUEST_HEADER) / 1000);
 
                 // Add the request duration.
                 let linkNode = msgObject.linkNode;
                 let statusNode = linkNode.
                   querySelector(".webconsole-msg-status");
 
                 let statusText = httpActivity.response.status;
-                let timeText = self.getFormatStr("NetworkPanel.durationMS",
+                let timeText = l10n.getFormatStr("NetworkPanel.durationMS",
                                                  [ requestDuration ]);
                 let fullStatusText = "[" + statusText + " " + timeText + "]";
                 statusNode.setAttribute("value", fullStatusText);
 
                 let clipboardTextPieces =
                   [ httpActivity.method, httpActivity.url, fullStatusText ];
                 msgObject.messageNode.clipboardText =
                   clipboardTextPieces.join(" ");
@@ -2954,17 +2904,17 @@ HUD_SERVICE.prototype =
       // get nBox object and call new HUD
       let config = { parentNode: nBox,
                      contentWindow: aContentWindow.top
                    };
 
       hud = new HeadsUpDisplay(config);
 
       HUDService.registerHUDReference(hud);
-      let windowId = this.getWindowId(aContentWindow.top);
+      let windowId = WebConsoleUtils.getOuterWindowId(aContentWindow.top);
       this.windowIds[windowId] = hudId;
 
       hud.progressListener = new ConsoleProgressListener(hudId);
 
       _browser.webProgress.addProgressListener(hud.progressListener,
         Ci.nsIWebProgress.NOTIFY_STATE_ALL);
 
       hud.displayCachedConsoleMessages();
@@ -3135,17 +3085,17 @@ HUD_SERVICE.prototype =
       // copied output.
       if (i > 0 && item.classList.contains("webconsole-new-group")) {
         newGroup = true;
       }
 
       // Ensure the selected item hasn't been filtered by type or string.
       if (!item.classList.contains("hud-filtered-by-type") &&
           !item.classList.contains("hud-filtered-by-string")) {
-        let timestampString = ConsoleUtils.timestampString(item.timestamp);
+        let timestampString = l10n.timestampString(item.timestamp);
         if (newGroup) {
           strings.push("--");
           newGroup = false;
         }
         strings.push("[" + timestampString + "] " + item.clipboardText);
       }
     }
     clipboardHelper.copyString(strings.join("\n"));
@@ -3460,17 +3410,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Retrieve the Web Console panel title.
    *
    * @return string
    *         The Web Console panel title.
    */
   getPanelTitle: function HUD_getPanelTitle()
   {
-    return this.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
+    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [this.uriSpec]);
   },
 
   positions: {
     above: 0, // the childNode index
     below: 2,
     window: null
   },
 
@@ -3565,39 +3515,16 @@ HeadsUpDisplay.prototype = {
       this.jsterm.inputNode.focus();
     }
     if (this.gcliterm) {
       this.gcliterm.inputNode.focus();
     }
   },
 
   /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @returns string
-   */
-  getStr: function HUD_getStr(aName)
-  {
-    return stringBundle.GetStringFromName(aName);
-  },
-
-  /**
-   * L10N shortcut function
-   *
-   * @param string aName
-   * @param array aArray
-   * @returns string
-   */
-  getFormatStr: function HUD_getFormatStr(aName, aArray)
-  {
-    return stringBundle.formatStringFromName(aName, aArray, aArray.length);
-  },
-
-  /**
    * The JSTerm object that contains the console's inputNode
    *
    */
   jsterm: null,
 
   /**
    * The GcliTerm object that contains the console's GCLI
    */
@@ -3639,17 +3566,17 @@ HeadsUpDisplay.prototype = {
   /**
    * Display cached messages that may have been collected before the UI is
    * displayed.
    *
    * @returns void
    */
   displayCachedConsoleMessages: function HUD_displayCachedConsoleMessages()
   {
-    let innerWindowId = HUDService.getInnerWindowId(this.contentWindow);
+    let innerWindowId = WebConsoleUtils.getInnerWindowId(this.contentWindow);
 
     let messages = gConsoleStorage.getEvents(innerWindowId);
 
     let errors = {};
     Services.console.getMessageArray(errors, {});
 
     // Filter the errors to find only those we should display.
     let filteredErrors = (errors.value || []).filter(function(aError) {
@@ -3759,17 +3686,17 @@ HeadsUpDisplay.prototype = {
     consoleWrap.setAttribute("flex", "1");
 
     this.filterSpacer = this.makeXULNode("spacer");
     this.filterSpacer.setAttribute("flex", "1");
 
     this.filterBox = this.makeXULNode("textbox");
     this.filterBox.setAttribute("class", "compact hud-filter-box");
     this.filterBox.setAttribute("hudId", this.hudId);
-    this.filterBox.setAttribute("placeholder", this.getStr("stringFilter"));
+    this.filterBox.setAttribute("placeholder", l10n.getStr("stringFilter"));
     this.filterBox.setAttribute("type", "search");
 
     this.setFilterTextBoxEvents();
 
     this.createConsoleMenu(this.consoleWrap);
 
     this.filterPrefs = HUDService.getDefaultFilterPrefs(this.hudId);
 
@@ -3937,38 +3864,38 @@ HeadsUpDisplay.prototype = {
       this.positionConsole("below");
     }).bind(this);
     this._positionConsoleWindow = (function HUD_positionWindow() {
       this.positionConsole("window");
     }).bind(this);
 
     let button = this.makeXULNode("toolbarbutton");
     button.setAttribute("type", "menu");
-    button.setAttribute("label", this.getStr("webConsolePosition"));
-    button.setAttribute("tooltip", this.getStr("webConsolePositionTooltip"));
+    button.setAttribute("label", l10n.getStr("webConsolePosition"));
+    button.setAttribute("tooltip", l10n.getStr("webConsolePositionTooltip"));
 
     let menuPopup = this.makeXULNode("menupopup");
     button.appendChild(menuPopup);
 
     let itemAbove = this.makeXULNode("menuitem");
-    itemAbove.setAttribute("label", this.getStr("webConsolePositionAbove"));
+    itemAbove.setAttribute("label", l10n.getStr("webConsolePositionAbove"));
     itemAbove.setAttribute("type", "checkbox");
     itemAbove.setAttribute("autocheck", "false");
     itemAbove.addEventListener("command", this._positionConsoleAbove, false);
     menuPopup.appendChild(itemAbove);
 
     let itemBelow = this.makeXULNode("menuitem");
-    itemBelow.setAttribute("label", this.getStr("webConsolePositionBelow"));
+    itemBelow.setAttribute("label", l10n.getStr("webConsolePositionBelow"));
     itemBelow.setAttribute("type", "checkbox");
     itemBelow.setAttribute("autocheck", "false");
     itemBelow.addEventListener("command", this._positionConsoleBelow, false);
     menuPopup.appendChild(itemBelow);
 
     let itemWindow = this.makeXULNode("menuitem");
-    itemWindow.setAttribute("label", this.getStr("webConsolePositionWindow"));
+    itemWindow.setAttribute("label", l10n.getStr("webConsolePositionWindow"));
     itemWindow.setAttribute("type", "checkbox");
     itemWindow.setAttribute("autocheck", "false");
     itemWindow.addEventListener("command", this._positionConsoleWindow, false);
     menuPopup.appendChild(itemWindow);
 
     this.positionMenuitems = {
       last: null,
       above: itemAbove,
@@ -3991,38 +3918,38 @@ HeadsUpDisplay.prototype = {
     let id = this.hudId + "-output-contextmenu";
     menuPopup.setAttribute("id", id);
     menuPopup.addEventListener("popupshowing", function() {
       saveBodiesItem.setAttribute("checked",
         HUDService.saveRequestAndResponseBodies);
     }, true);
 
     let saveBodiesItem = this.makeXULNode("menuitem");
-    saveBodiesItem.setAttribute("label", this.getStr("saveBodies.label"));
+    saveBodiesItem.setAttribute("label", l10n.getStr("saveBodies.label"));
     saveBodiesItem.setAttribute("accesskey",
-                                 this.getStr("saveBodies.accesskey"));
+                                 l10n.getStr("saveBodies.accesskey"));
     saveBodiesItem.setAttribute("type", "checkbox");
     saveBodiesItem.setAttribute("buttonType", "saveBodies");
     saveBodiesItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
     menuPopup.appendChild(saveBodiesItem);
 
     menuPopup.appendChild(this.makeXULNode("menuseparator"));
 
     let copyItem = this.makeXULNode("menuitem");
-    copyItem.setAttribute("label", this.getStr("copyCmd.label"));
-    copyItem.setAttribute("accesskey", this.getStr("copyCmd.accesskey"));
+    copyItem.setAttribute("label", l10n.getStr("copyCmd.label"));
+    copyItem.setAttribute("accesskey", l10n.getStr("copyCmd.accesskey"));
     copyItem.setAttribute("key", "key_copy");
     copyItem.setAttribute("command", "cmd_copy");
     copyItem.setAttribute("buttonType", "copy");
     menuPopup.appendChild(copyItem);
 
     let selectAllItem = this.makeXULNode("menuitem");
-    selectAllItem.setAttribute("label", this.getStr("selectAllCmd.label"));
+    selectAllItem.setAttribute("label", l10n.getStr("selectAllCmd.label"));
     selectAllItem.setAttribute("accesskey",
-                               this.getStr("selectAllCmd.accesskey"));
+                               l10n.getStr("selectAllCmd.accesskey"));
     selectAllItem.setAttribute("hudId", this.hudId);
     selectAllItem.setAttribute("buttonType", "selectAll");
     selectAllItem.setAttribute("oncommand", "HUDConsoleUI.command(this);");
     menuPopup.appendChild(selectAllItem);
 
     aConsoleWrapper.appendChild(menuPopup);
     aConsoleWrapper.setAttribute("context", id);
   },
@@ -4043,30 +3970,30 @@ HeadsUpDisplay.prototype = {
     let toolbarButton = this.makeXULNode("toolbarbutton");
     aParent.appendChild(toolbarButton);
 
     let toggleFilter = HeadsUpDisplayUICommands.toggleFilter;
     toolbarButton.addEventListener("click", toggleFilter, false);
 
     let name = aDescriptor.name;
     toolbarButton.setAttribute("type", "menu-button");
-    toolbarButton.setAttribute("label", this.getStr("btn" + name));
-    toolbarButton.setAttribute("tooltip", this.getStr("tip" + name));
+    toolbarButton.setAttribute("label", l10n.getStr("btn" + name));
+    toolbarButton.setAttribute("tooltip", l10n.getStr("tip" + name));
     toolbarButton.setAttribute("category", aDescriptor.category);
     toolbarButton.setAttribute("hudId", this.hudId);
     toolbarButton.classList.add("webconsole-filter-button");
 
     let menuPopup = this.makeXULNode("menupopup");
     toolbarButton.appendChild(menuPopup);
 
     let someChecked = false;
     for (let i = 0; i < aDescriptor.severities.length; i++) {
       let severity = aDescriptor.severities[i];
       let menuItem = this.makeXULNode("menuitem");
-      menuItem.setAttribute("label", this.getStr("btn" + severity.name));
+      menuItem.setAttribute("label", l10n.getStr("btn" + severity.name));
       menuItem.setAttribute("type", "checkbox");
       menuItem.setAttribute("autocheck", "false");
       menuItem.setAttribute("hudId", this.hudId);
 
       let prefKey = severity.prefKey;
       menuItem.setAttribute("prefKey", prefKey);
 
       let checked = this.filterPrefs[prefKey];
@@ -4123,17 +4050,17 @@ HeadsUpDisplay.prototype = {
         hud.jsterm.clearOutput(true);
       }
       if (hud.gcliterm) {
         hud.gcliterm.clearOutput();
       }
     }
 
     let clearButton = this.makeXULNode("toolbarbutton");
-    clearButton.setAttribute("label", this.getStr("btnClear"));
+    clearButton.setAttribute("label", l10n.getStr("btnClear"));
     clearButton.classList.add("webconsole-clear-console-button");
     clearButton.addEventListener("command", HUD_clearButton_onCommand, false);
 
     aToolbar.appendChild(clearButton);
   },
 
   /**
    * Destroy the property inspector message node. This performs the necessary
@@ -4229,17 +4156,17 @@ let ConsoleAPIObserver = {
     Services.obs.addObserver(this, "console-api-log-event", false);
   },
 
   observe: function CAO_observe(aMessage, aTopic, aData)
   {
     if (aTopic == "console-api-log-event") {
       aMessage = aMessage.wrappedJSObject;
       let windowId = parseInt(aData);
-      let win = HUDService.getWindowByWindowId(windowId);
+      let win = WebConsoleUtils.getWindowByOuterId(windowId);
       if (!win)
         return;
 
       // Find the HUD ID for the topmost window
       let hudId = HUDService.getHudIdByWindow(win.top);
       if (!hudId)
         return;
 
@@ -4758,17 +4685,17 @@ function JSTermHelper(aJSTerm)
    * @param object aObject
    *        Object to print to the output.
    * @returns void
    */
   aJSTerm.sandbox.pprint = function JSTH_pprint(aObject)
   {
     aJSTerm.helperEvaluated = true;
     if (aObject === null || aObject === undefined || aObject === true || aObject === false) {
-      aJSTerm.console.error(HUDService.getStr("helperFuncUnsupportedTypeError"));
+      aJSTerm.console.error(l10n.getStr("helperFuncUnsupportedTypeError"));
       return;
     }
     else if (typeof aObject === TYPEOF_FUNCTION) {
       aJSTerm.writeOutput(aObject + "\n", CATEGORY_OUTPUT, SEVERITY_LOG);
       return;
     }
 
     let output = [];
@@ -5004,18 +4931,18 @@ JSTerm.prototype = {
     //    result will be inspected by this panel.
     let buttons = [];
 
     // If there is a evalString passed to this function, then add a `Update`
     // button to the panel so that the evalString can be reexecuted to update
     // the content of the panel.
     if (aEvalString !== null) {
       buttons.push({
-        label: HUDService.getStr("update.button"),
-        accesskey: HUDService.getStr("update.accesskey"),
+        label: l10n.getStr("update.button"),
+        accesskey: l10n.getStr("update.accesskey"),
         oncommand: function () {
           try {
             var result = self.evalInSandbox(aEvalString);
 
             if (result !== undefined) {
               // TODO: This updates the value of the tree.
               // However, the states of opened nodes is not saved.
               // See bug 586246.
@@ -5027,18 +4954,18 @@ JSTerm.prototype = {
           }
         }
       });
     }
 
     let doc = self.document;
     let parent = doc.getElementById("mainPopupSet");
     let title = (aEvalString
-        ? HUDService.getFormatStr("jsPropertyInspectTitle", [aEvalString])
-        : HUDService.getStr("jsPropertyTitle"));
+        ? l10n.getFormatStr("jsPropertyInspectTitle", [aEvalString])
+        : l10n.getStr("jsPropertyTitle"));
 
     propPanel = new PropertyPanel(parent, doc, title, aOutputObject, buttons);
     propPanel.linkNode = aAnchor;
 
     let panel = propPanel.panel;
     panel.openPopup(aAnchor, "after_pointer", 0, 0, false, false);
     panel.sizeTo(350, 450);
     return propPanel;
@@ -5253,17 +5180,17 @@ JSTerm.prototype = {
         hud.outputNode.removeChild(node.firstChild);
       }
     }
 
     hud.HUDBox.lastTimestamp = 0;
     hud.groupDepth = 0;
 
     if (aClearStorage) {
-      let windowId = HUDService.getInnerWindowId(hud.contentWindow);
+      let windowId = WebConsoleUtils.getInnerWindowId(hud.contentWindow);
       gConsoleStorage.clearEvents(windowId);
     }
   },
 
   /**
    * Updates the size of the input field (command line) to fit its contents.
    *
    * @returns void
@@ -5393,17 +5320,17 @@ JSTerm.prototype = {
       case Ci.nsIDOMKeyEvent.DOM_VK_TAB:
         // Generate a completion and accept the first proposed value.
         if (this.complete(this.COMPLETE_HINT_ONLY) &&
             this.lastCompletion &&
             this.acceptProposedCompletion()) {
           aEvent.preventDefault();
         }
         else {
-          this.updateCompleteNode(HUDService.getStr("Autocomplete.blank"));
+          this.updateCompleteNode(l10n.getStr("Autocomplete.blank"));
           aEvent.preventDefault();
         }
         break;
 
       default:
         break;
     }
   },
@@ -5800,42 +5727,16 @@ ConsoleUtils = {
   {
     let str = Cc["@mozilla.org/supports-string;1"].
       createInstance(Ci.nsISupportsString);
     str.data = aString;
     return str;
   },
 
   /**
-   * Generates a millisecond resolution timestamp.
-   *
-   * @returns integer
-   */
-  timestamp: function ConsoleUtils_timestamp()
-  {
-    return Date.now();
-  },
-
-  /**
-   * Generates a formatted timestamp string for displaying in console messages.
-   *
-   * @param integer [ms] Optional, allows you to specify the timestamp in
-   * milliseconds since the UNIX epoch.
-   * @returns string The timestamp formatted for display.
-   */
-  timestampString: function ConsoleUtils_timestampString(ms)
-  {
-    var d = new Date(ms ? ms : null);
-    let hours = d.getHours(), minutes = d.getMinutes();
-    let seconds = d.getSeconds(), milliseconds = d.getMilliseconds();
-    let parameters = [ hours, minutes, seconds, milliseconds ];
-    return HUDService.getFormatStr("timestampFormat", parameters);
-  },
-
-  /**
    * Scrolls a node so that it's visible in its containing XUL "scrollbox"
    * element.
    *
    * @param nsIDOMNode aNode
    *        The node to make visible.
    * @returns void
    */
   scrollToVisible: function ConsoleUtils_scrollToVisible(aNode) {
@@ -5946,18 +5847,18 @@ ConsoleUtils = {
     let repeatNode = aDocument.createElementNS(XUL_NS, "label");
     repeatNode.setAttribute("value", "1");
     repeatNode.classList.add("webconsole-msg-repeat");
     repeatContainer.appendChild(repeatNode);
 
     // Create the timestamp.
     let timestampNode = aDocument.createElementNS(XUL_NS, "label");
     timestampNode.classList.add("webconsole-timestamp");
-    let timestamp = aTimeStamp || ConsoleUtils.timestamp();
-    let timestampString = ConsoleUtils.timestampString(timestamp);
+    let timestamp = aTimeStamp || Date.now();
+    let timestampString = l10n.timestampString(timestamp);
     timestampNode.setAttribute("value", timestampString);
 
     // Create the source location (e.g. www.example.com:6) that sits on the
     // right side of the message, if applicable.
     let locationNode;
     if (aSourceURL) {
       locationNode = this.createLocationNode(aDocument, aSourceURL,
                                              aSourceLine);
@@ -6073,17 +5974,17 @@ ConsoleUtils = {
    */
   createLocationNode:
   function ConsoleUtils_createLocationNode(aDocument, aSourceURL,
                                            aSourceLine) {
     let locationNode = aDocument.createElementNS(XUL_NS, "label");
 
     // Create the text, which consists of an abbreviated version of the URL
     // plus an optional line number.
-    let text = ConsoleUtils.abbreviateSourceURL(aSourceURL);
+    let text = WebConsoleUtils.abbreviateSourceURL(aSourceURL);
     if (aSourceLine) {
       text += ":" + aSourceLine;
     }
     locationNode.setAttribute("value", text);
 
     // Style appropriately.
     locationNode.setAttribute("crop", "center");
     locationNode.setAttribute("title", aSourceURL);
@@ -6293,46 +6194,16 @@ ConsoleUtils = {
   {
     let lastNodeHeight = aOutputNode.lastChild ?
                          aOutputNode.lastChild.clientHeight : 0;
     let scrollBox = aOutputNode.scrollBoxObject.element;
 
     return scrollBox.scrollTop + scrollBox.clientHeight >=
            scrollBox.scrollHeight - lastNodeHeight / 2;
   },
-
-  /**
-   * Abbreviates the given source URL so that it can be displayed flush-right
-   * without being too distracting.
-   *
-   * @param string aSourceURL
-   *        The source URL to shorten.
-   * @return string
-   *         The abbreviated form of the source URL.
-   */
-  abbreviateSourceURL: function ConsoleUtils_abbreviateSourceURL(aSourceURL) {
-    // Remove any query parameters.
-    let hookIndex = aSourceURL.indexOf("?");
-    if (hookIndex > -1) {
-      aSourceURL = aSourceURL.substring(0, hookIndex);
-    }
-
-    // Remove a trailing "/".
-    if (aSourceURL[aSourceURL.length - 1] == "/") {
-      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
-    }
-
-    // Remove all but the last path component.
-    let slashIndex = aSourceURL.lastIndexOf("/");
-    if (slashIndex > -1) {
-      aSourceURL = aSourceURL.substring(slashIndex + 1);
-    }
-
-    return aSourceURL;
-  }
 };
 
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplayUICommands
 //////////////////////////////////////////////////////////////////////////
 
 HeadsUpDisplayUICommands = {
   toggleHUD: function UIC_toggleHUD() {
@@ -7061,22 +6932,22 @@ GcliTerm.prototype = {
       '    <image class="webconsole-msg-icon"/>' +
       '    <spacer flex="1"/>' +
       '  </vbox>' +
       '  <hbox flex="1" class="gcliterm-msg-body">${output}</hbox>' +
       '  <hbox align="start"><label value="1" class="webconsole-msg-repeat"/></hbox>' +
       '</richlistitem>').firstChild;
 
     let hud = HUDService.getHudReferenceById(this.hudId);
-    let timestamp = ConsoleUtils.timestamp();
+    let timestamp = Date.now();
     template(element, {
       iconContainerStyle: "margin-left=" + (hud.groupDepth * GROUP_INDENT) + "px",
       output: output,
       timestamp: timestamp,
-      timestampString: ConsoleUtils.timestampString(timestamp),
+      timestampString: l10n.timestampString(timestamp),
       clipboardText: output.innerText,
       id: "console-msg-" + HUDService.sequenceId()
     });
 
     ConsoleUtils.setMessageType(element, CATEGORY_OUTPUT, SEVERITY_LOG);
     ConsoleUtils.outputMessageNode(element, this.hudId);
   },
 
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -43,16 +43,17 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 		PropertyPanel.jsm \
 		NetworkHelper.jsm \
 		AutocompletePopup.jsm \
+		WebConsoleUtils.jsm \
 		gcli.jsm \
 		GcliCommands.jsm \
 		GcliTiltCommands.jsm \
 		$(NULL)
 
 EXTRA_PP_JS_MODULES = \
 		HUDService.jsm \
 		$(NULL)
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -0,0 +1,730 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Web Console.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com>
+ *   David Dahl <ddahl@mozilla.com>
+ *   Rob Campbell <rcampbell@mozilla.com>
+ *   Johnathan Nightingale <jnightingale@mozilla.com>
+ *   Patrick Walton <pcwalton@mozilla.com>
+ *   Julian Viereck <jviereck@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+let Cc = Components.classes;
+let Ci = Components.interfaces;
+let Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+var EXPORTED_SYMBOLS = ["WebConsoleUtils"];
+
+const STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
+
+const TYPES = { OBJECT: 0,
+                FUNCTION: 1,
+                ARRAY: 2,
+                OTHER: 3,
+                ITERATOR: 4,
+                GETTER: 5,
+                GENERATOR: 6,
+                STRING: 7
+              };
+
+var gObjectId = 0;
+
+var WebConsoleUtils = {
+  TYPES: TYPES,
+
+  /**
+   * Convenience function to unwrap a wrapped object.
+   *
+   * @param aObject the object to unwrap.
+   * @return aObject unwrapped.
+   */
+  unwrap: function WCU_unwrap(aObject)
+  {
+    try {
+      return XPCNativeWrapper.unwrap(aObject);
+    }
+    catch (ex) {
+      return aObject;
+    }
+  },
+
+  /**
+   * Clone an object.
+   *
+   * @param object aObject
+   *        The object you want cloned.
+   * @param boolean aRecursive
+   *        Tells if you want to dig deeper into the object, to clone
+   *        recursively.
+   * @param function [aFilter]
+   *        Optional, filter function, called for every property. Three
+   *        arguments are passed: key, value and object. Return true if the
+   *        property should be added to the cloned object. Return false to skip
+   *        the property.
+   * @return object
+   *         The cloned object.
+   */
+  cloneObject: function WCU_cloneObject(aObject, aRecursive, aFilter)
+  {
+    if (typeof aObject != "object") {
+      return aObject;
+    }
+
+    let temp;
+
+    if (Array.isArray(aObject)) {
+      temp = [];
+      Array.forEach(aObject, function(aValue, aIndex) {
+        if (!aFilter || aFilter(aIndex, aValue, aObject)) {
+          temp.push(aRecursive ? WCU_cloneObject(aValue) : aValue);
+        }
+      });
+    }
+    else {
+      temp = {};
+      for (let key in aObject) {
+        let value = aObject[key];
+        if (aObject.hasOwnProperty(key) &&
+            (!aFilter || aFilter(key, value, aObject))) {
+          temp[key] = aRecursive ? WCU_cloneObject(value) : value;
+        }
+      }
+    }
+
+    return temp;
+  },
+
+  /**
+   * Gets the ID of the inner window of this DOM window.
+   *
+   * @param nsIDOMWindow aWindow
+   * @return integer
+   *         Inner ID for the given aWindow.
+   */
+  getInnerWindowId: function WCU_getInnerWindowId(aWindow)
+  {
+    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+           getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
+  },
+
+  /**
+   * Gets the ID of the outer window of this DOM window.
+   *
+   * @param nsIDOMWindow aWindow
+   * @return integer
+   *         Outer ID for the given aWindow.
+   */
+  getOuterWindowId: function WCU_getOuterWindowId(aWindow)
+  {
+    return aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+           getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+  },
+
+  /**
+   * Gets the window that has the given outer ID.
+   *
+   * @param integer aOuterId
+   * @param nsIDOMWindow [aHintWindow]
+   *        Optional, the window object used to QueryInterface to
+   *        nsIDOMWindowUtils. If this is not given,
+   *        Services.wm.getMostRecentWindow() is used.
+   * @return nsIDOMWindow|null
+   *         The window object with the given outer ID.
+   */
+  getWindowByOuterId: function WCU_getWindowByOuterId(aOuterId, aHintWindow)
+  {
+    let someWindow = aHintWindow || Services.wm.getMostRecentWindow(null);
+    let content = null;
+
+    if (someWindow) {
+      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+                                   getInterface(Ci.nsIDOMWindowUtils);
+      content = windowUtils.getOuterWindowWithId(aOuterId);
+    }
+
+    return content;
+  },
+
+  /**
+   * Gets the window that has the given inner ID.
+   *
+   * @param integer aInnerId
+   * @param nsIDOMWindow [aHintWindow]
+   *        Optional, the window object used to QueryInterface to
+   *        nsIDOMWindowUtils. If this is not given,
+   *        Services.wm.getMostRecentWindow() is used.
+   * @return nsIDOMWindow|null
+   *         The window object with the given inner ID.
+   */
+  getWindowByInnerId: function WCU_getWindowByInnerId(aInnerId, aHintWindow)
+  {
+    let someWindow = aHintWindow || Services.wm.getMostRecentWindow(null);
+    let content = null;
+
+    if (someWindow) {
+      let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+                                   getInterface(Ci.nsIDOMWindowUtils);
+      content = windowUtils.getInnerWindowWithId(aInnerId);
+    }
+
+    return content;
+  },
+
+  /**
+   * Abbreviates the given source URL so that it can be displayed flush-right
+   * without being too distracting.
+   *
+   * @param string aSourceURL
+   *        The source URL to shorten.
+   * @return string
+   *         The abbreviated form of the source URL.
+   */
+  abbreviateSourceURL: function WCU_abbreviateSourceURL(aSourceURL)
+  {
+    // Remove any query parameters.
+    let hookIndex = aSourceURL.indexOf("?");
+    if (hookIndex > -1) {
+      aSourceURL = aSourceURL.substring(0, hookIndex);
+    }
+
+    // Remove a trailing "/".
+    if (aSourceURL[aSourceURL.length - 1] == "/") {
+      aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
+    }
+
+    // Remove all but the last path component.
+    let slashIndex = aSourceURL.lastIndexOf("/");
+    if (slashIndex > -1) {
+      aSourceURL = aSourceURL.substring(slashIndex + 1);
+    }
+
+    return aSourceURL;
+  },
+
+  /**
+   * Format the jsterm execution result based on its type.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want displayed.
+   * @return string
+   *         The string that can be displayed.
+   */
+  formatResult: function WCU_formatResult(aResult)
+  {
+    let output = "";
+    let type = this.getResultType(aResult);
+
+    switch (type) {
+      case "string":
+        output = this.formatResultString(aResult);
+        break;
+      case "boolean":
+      case "date":
+      case "error":
+      case "number":
+      case "regexp":
+        output = aResult.toString();
+        break;
+      case "null":
+      case "undefined":
+        output = type;
+        break;
+      default:
+        if (aResult.toSource) {
+          try {
+            output = aResult.toSource();
+          } catch (ex) { }
+        }
+        if (!output || output == "({})") {
+          output = aResult.toString();
+        }
+        break;
+    }
+
+    return output;
+  },
+
+  /**
+   * Format a string for output.
+   *
+   * @param string aString
+   *        The string you want to display.
+   * @return string
+   *         The string that can be displayed.
+   */
+  formatResultString: function WCU_formatResultString(aString)
+  {
+    function isControlCode(c) {
+      // See http://en.wikipedia.org/wiki/C0_and_C1_control_codes
+      // C0 is 0x00-0x1F, C1 is 0x80-0x9F (inclusive).
+      // We also include DEL (U+007F) and NBSP (U+00A0), which are not strictly
+      // in C1 but border it.
+      return (c <= 0x1F) || (0x7F <= c && c <= 0xA0);
+    }
+
+    function replaceFn(aMatch, aType, aHex) {
+      // Leave control codes escaped, but unescape the rest of the characters.
+      let c = parseInt(aHex, 16);
+      return isControlCode(c) ? aMatch : String.fromCharCode(c);
+    }
+
+    let output = uneval(aString).replace(/\\(x)([0-9a-fA-F]{2})/g, replaceFn)
+                 .replace(/\\(u)([0-9a-fA-F]{4})/g, replaceFn);
+
+    return output;
+  },
+
+  /**
+   * Determine if the jsterm execution result is inspectable or not.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want to check if it is inspectable.
+   * @return boolean
+   *         True if the object is inspectable or false otherwise.
+   */
+  isResultInspectable: function WCU_isResultInspectable(aResult)
+  {
+    let isEnumerable = false;
+
+    // Skip Iterators and Generators.
+    if (this.isIteratorOrGenerator(aResult)) {
+      return false;
+    }
+
+    try {
+      for (let p in aResult) {
+        isEnumerable = true;
+        break;
+      }
+    }
+    catch (ex) {
+      // Proxy objects can lack an enumerable method.
+    }
+
+    return isEnumerable && typeof(aResult) != "string";
+  },
+
+  /**
+   * Determine the type of the jsterm execution result.
+   *
+   * @param mixed aResult
+   *        The evaluation result object you want to check.
+   * @return string
+   *         Constructor name or type: string, number, boolean, regexp, date,
+   *         function, object, null, undefined...
+   */
+  getResultType: function WCU_getResultType(aResult)
+  {
+    let type = aResult === null ? "null" : typeof aResult;
+    if (type == "object" && aResult.constructor && aResult.constructor.name) {
+      type = aResult.constructor.name;
+    }
+
+    return type.toLowerCase();
+  },
+
+  /**
+   * Figures out the type of aObject and the string to display as the object
+   * value.
+   *
+   * @param object aObject
+   *        The object to operate on.
+   * @return object
+   *         An object of the form:
+   *         {
+   *           type: TYPES.OBJECT || TYPES.FUNCTION || ...
+   *           display: string for displaying the object
+   *         }
+   */
+  presentableValueFor: function WCU_presentableValueFor(aObject)
+  {
+    let type = this.getResultType(aObject);
+    let presentable;
+
+    switch (type) {
+      case "undefined":
+      case "null":
+        return {
+          type: TYPES.OTHER,
+          display: type
+        };
+
+      case "array":
+        return {
+          type: TYPES.ARRAY,
+          display: "Array"
+        };
+
+      case "string":
+        return {
+          type: TYPES.STRING,
+          display: "\"" + aObject + "\""
+        };
+
+      case "date":
+      case "regexp":
+      case "number":
+      case "boolean":
+        return {
+          type: TYPES.OTHER,
+          display: aObject.toString()
+        };
+
+      case "iterator":
+        return {
+          type: TYPES.ITERATOR,
+          display: "Iterator"
+        };
+
+      case "function":
+        presentable = aObject.toString();
+        return {
+          type: TYPES.FUNCTION,
+          display: presentable.substring(0, presentable.indexOf(')') + 1)
+        };
+
+      default:
+        presentable = aObject.toString();
+        let m = /^\[object (\S+)\]/.exec(presentable);
+
+        try {
+          if (type == "object" && typeof aObject.next == "function" &&
+              m && m[1] == "Generator") {
+            return {
+              type: TYPES.GENERATOR,
+              display: m[1]
+            };
+          }
+        }
+        catch (ex) {
+          // window.history.next throws in the typeof check above.
+          return {
+            type: TYPES.OBJECT,
+            display: m ? m[1] : "Object"
+          };
+        }
+
+        if (type == "object" && typeof aObject.__iterator__ == "function") {
+          return {
+            type: TYPES.ITERATOR,
+            display: "Iterator"
+          };
+        }
+
+        return {
+          type: TYPES.OBJECT,
+          display: m ? m[1] : "Object"
+        };
+    }
+  },
+
+  /**
+   * Tells if the given function is native or not.
+   *
+   * @param function aFunction
+   *        The function you want to check if it is native or not.
+   *
+   * @return boolean
+   *         True if the given function is native, false otherwise.
+   */
+  isNativeFunction: function WCU_isNativeFunction(aFunction)
+  {
+    return typeof aFunction == "function" && !("prototype" in aFunction);
+  },
+
+  /**
+   * Tells if the given property of the provided object is a non-native getter or
+   * not.
+   *
+   * @param object aObject
+   *        The object that contains the property.
+   *
+   * @param string aProp
+   *        The property you want to check if it is a getter or not.
+   *
+   * @return boolean
+   *         True if the given property is a getter, false otherwise.
+   */
+  isNonNativeGetter: function WCU_isNonNativeGetter(aObject, aProp)
+  {
+    if (typeof aObject != "object") {
+      return false;
+    }
+    let desc;
+    while (aObject) {
+      try {
+        if (desc = Object.getOwnPropertyDescriptor(aObject, aProp)) {
+          break;
+        }
+      }
+      catch (ex) {
+        // Native getters throw here. See bug 520882.
+        if (ex.name == "NS_ERROR_XPC_BAD_CONVERT_JS" ||
+            ex.name == "NS_ERROR_XPC_BAD_OP_ON_WN_PROTO") {
+          return false;
+        }
+        throw ex;
+      }
+      aObject = Object.getPrototypeOf(aObject);
+    }
+    if (desc && desc.get && !this.isNativeFunction(desc.get)) {
+      return true;
+    }
+    return false;
+  },
+
+  /**
+   * Get an array that describes the properties of the given object.
+   *
+   * @param object aObject
+   *        The object to get the properties from.
+   * @param object aObjectCache
+   *        Optional object cache where to store references to properties of
+   *        aObject that are inspectable.
+   * @return array
+   *         An array that describes each property from the given object. Each
+   *         array element is an object (a property descriptor). Each property
+   *         descriptor has the following properties:
+   *         - name - property name
+   *         - value - a presentable property value representation (see
+   *                   this.presentableValueFor())
+   *         - type - value type (see this.presentableValueFor())
+   *         - inspectable - tells if the property value holds further
+   *                         properties.
+   *         - objectId - optional, available only if aObjectCache is given and
+   *         if |inspectable| is true. You can do
+   *         aObjectCache[propertyDescriptor.objectId] to get the actual object
+   *         referenced by the property of aObject.
+   */
+  namesAndValuesOf: function WCU_namesAndValuesOf(aObject, aObjectCache)
+  {
+    let pairs = [];
+    let value, presentable;
+
+    let isDOMDocument = aObject instanceof Ci.nsIDOMDocument;
+
+    for (let propName in aObject) {
+      // See bug 632275: skip deprecated width and height properties.
+      if (isDOMDocument && (propName == "width" || propName == "height")) {
+        continue;
+      }
+
+      // Also skip non-native getters.
+      if (this.isNonNativeGetter(aObject, propName)) {
+        value = "";
+        presentable = {type: TYPES.GETTER, display: "Getter"};
+      }
+      else {
+        value = aObject[propName];
+        presentable = this.presentableValueFor(value);
+      }
+
+      let pair = {};
+      pair.name = propName;
+      pair.value = presentable.display;
+      pair.inspectable = false;
+      pair.type = presentable.type;
+
+      switch (presentable.type) {
+        case TYPES.GETTER:
+        case TYPES.ITERATOR:
+        case TYPES.GENERATOR:
+        case TYPES.STRING:
+          break;
+        default:
+          try {
+            for (let p in value) {
+              pair.inspectable = true;
+              break;
+            }
+          }
+          catch (ex) { }
+          break;
+      }
+
+      // Store the inspectable object.
+      if (pair.inspectable && aObjectCache) {
+        pair.objectId = ++gObjectId;
+        aObjectCache[pair.objectId] = value;
+      }
+
+      pairs.push(pair);
+    }
+
+    pairs.sort(function(a, b)
+    {
+      // Convert the pair.name to a number for later sorting.
+      let aNumber = parseFloat(a.name);
+      let bNumber = parseFloat(b.name);
+
+      // Sort numbers.
+      if (!isNaN(aNumber) && isNaN(bNumber)) {
+        return -1;
+      }
+      else if (isNaN(aNumber) && !isNaN(bNumber)) {
+        return 1;
+      }
+      else if (!isNaN(aNumber) && !isNaN(bNumber)) {
+        return aNumber - bNumber;
+      }
+      // Sort string.
+      else if (a.name < b.name) {
+        return -1;
+      }
+      else if (a.name > b.name) {
+        return 1;
+      }
+      else {
+        return 0;
+      }
+    });
+
+    return pairs;
+  },
+
+  /**
+   * Check if the given object is an iterator or a generator.
+   *
+   * @param object aObject
+   *        The object you want to check.
+   * @return boolean
+   *         True if the given object is an iterator or a generator, otherwise
+   *         false is returned.
+   */
+  isIteratorOrGenerator: function WCU_isIteratorOrGenerator(aObject)
+  {
+    if (aObject === null) {
+      return false;
+    }
+
+    if (typeof aObject == "object") {
+      if (typeof aObject.__iterator__ == "function" ||
+          aObject.constructor && aObject.constructor.name == "Iterator") {
+        return true;
+      }
+
+      try {
+        let str = aObject.toString();
+        if (typeof aObject.next == "function" &&
+            str.indexOf("[object Generator") == 0) {
+          return true;
+        }
+      }
+      catch (ex) {
+        // window.history.next throws in the typeof check above.
+        return false;
+      }
+    }
+
+    return false;
+  },
+};
+
+//////////////////////////////////////////////////////////////////////////
+// Localization
+//////////////////////////////////////////////////////////////////////////
+
+WebConsoleUtils.l10n = {
+  /**
+   * Generates a formatted timestamp string for displaying in console messages.
+   *
+   * @param integer [aMilliseconds]
+   *        Optional, allows you to specify the timestamp in milliseconds since
+   *        the UNIX epoch.
+   * @return string
+   *         The timestamp formatted for display.
+   */
+  timestampString: function WCU_l10n_timestampString(aMilliseconds)
+  {
+    let d = new Date(aMilliseconds ? aMilliseconds : null);
+    let hours = d.getHours(), minutes = d.getMinutes();
+    let seconds = d.getSeconds(), milliseconds = d.getMilliseconds();
+    let parameters = [hours, minutes, seconds, milliseconds];
+    return this.getFormatStr("timestampFormat", parameters);
+  },
+
+  /**
+   * Retrieve a localized string.
+   *
+   * @param string aName
+   *        The string name you want from the Web Console string bundle.
+   * @return string
+   *         The localized string.
+   */
+  getStr: function WCU_l10n_getStr(aName)
+  {
+    let result;
+    try {
+      result = this.stringBundle.GetStringFromName(aName);
+    }
+    catch (ex) {
+      Cu.reportError("Failed to get string: " + aName);
+      throw ex;
+    }
+    return result;
+  },
+
+  /**
+   * Retrieve a localized string formatted with values coming from the given
+   * array.
+   *
+   * @param string aName
+   *        The string name you want from the Web Console string bundle.
+   * @param array aArray
+   *        The array of values you want in the formatted string.
+   * @return string
+   *         The formatted local string.
+   */
+  getFormatStr: function WCU_l10n_getFormatStr(aName, aArray)
+  {
+    let result;
+    try {
+      result = this.stringBundle.formatStringFromName(aName, aArray, aArray.length);
+    }
+    catch (ex) {
+      Cu.reportError("Failed to format string: " + aName);
+      throw ex;
+    }
+    return result;
+  },
+};
+
+XPCOMUtils.defineLazyGetter(WebConsoleUtils.l10n, "stringBundle", function() {
+  return Services.strings.createBundle(STRINGS_URI);
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
--- a/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_network_panel.js
@@ -95,16 +95,22 @@ function checkNodeKeyValue(aPanel, aId, 
   }
 
   ok(false, "content check failed for " + aId + ", key " + aKey);
 }
 
 function testGen() {
   let filterBox = HUDService.getHudByWindow(content).filterBox;
 
+  XPCOMUtils.defineLazyGetter(this, "l10n", function () {
+    let obj = {};
+    Cu.import("resource:///modules/WebConsoleUtils.jsm", obj);
+    return obj.WebConsoleUtils.l10n;
+  });
+
   var httpActivity = {
     url: "http://www.testpage.com",
     method: "GET",
 
     panels: [],
     request: {
       header: {
         foo: "bar"
@@ -433,17 +439,19 @@ function testGen() {
     responseBody: false,
     responseBodyCached: false,
     responseBodyUnknownType: true,
     responseNoBody: false,
     responseImage: false,
     responseImageCached: false
   });
 
-  let responseString = HUDService.getFormatStr("NetworkPanel.responseBodyUnableToDisplay.content", ["application/x-shockwave-flash"]);
+  let responseString =
+    l10n.getFormatStr("NetworkPanel.responseBodyUnableToDisplay.content",
+                      ["application/x-shockwave-flash"]);
   checkNodeContent(networkPanel, "responseBodyUnknownTypeContent", responseString);
   networkPanel.panel.hidePopup();
 
   /*
 
   // This test disabled. See bug 603620.
 
   // Test if the NetworkPanel figures out the content type based on an URL as
